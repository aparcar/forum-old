<!DOCTYPE html>
<html lang="en-US">
<head>

	<title>OpenWrt Forum Archive</title>

	<meta charset="UTF-8">

	<meta http-equiv="X-UA-Compatible" content="IE=edge">

	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="assets/css/common.css">

</head>
<body>

<div class="container">

<header class="main-header">
	<h1 class="logo"><a href="index.html"><img src="assets/img/logo.png" width="376" height="88" alt="OpenWrt Forum Archive"></a></h1>
</header>

<aside>
	<p>This is a read-only archive of the old OpenWrt forum. The current OpenWrt forum resides at <a href="https://forum.openwrt.org/">https://forum.openwrt.org/</a>.</p>
	<p class="minor">In May 2018, the OpenWrt forum suffered a total data loss. This archive is an effort to restore and make available as much content as possible. Content may be missing or not representing the latest edited version.</p>
</aside>

<main>
	<header>
		<h1><span class="minor">Topic:</span> usb network interface with usbnet</h1>
	</header>
	<div class="notice minor">
		<p>
			The content of this topic has been archived
							on 22 Apr 2018.
										There are no obvious gaps in this topic, but there may still be some posts missing at the end.
					</p>
	</div>

	<div class="pagination"><div class="pagination-number">Page 1 of 1</div><nav><ul><li class="pagination-current"><span>1</span></li></ul></nav></div>
			
		
		
			<article class="post" id="p43291">
				<div class="post-metadata">
					<div class="post-num">Post #1</div>
					<div class="post-author">masc</div>
					<div class="post-datetime">
						26 Feb 2007, 16:33					</div>
				</div>
				<div class="post-content content">
					<p>hi!</p><p>i need a second wire ethernet on my wl-hdd. it&#039;s runing on a whiterussian rc6. </p><p>i bought a linksys USB200M adapter, got a hint from <a href="http://www.nslu2-linux.org/wiki/Peripherals/EthernetAdapter">http://www.nslu2-linux.org/wiki/Periphe … netAdapter</a>. i compiled the usbnet and the mii modules, they are loading fine. there was a problem with the usb-id&#039;s in the driver, with changing it to the values reported in the syslog, i got finally a log entry </p><p>Feb 26 15:24:24 (none) kern.info kernel: hub.c: new USB device 00:04.0-1, assigned address 11<br />Feb 26 15:24:25 (none) kern.warn kernel: usb_control/bulk_msg: timeout<br />Feb 26 15:24:25 (none) kern.info kernel: usb0: register usbnet usb-00:04.0-1, ASIX AX8817x USB 2.0 Ethernet</p><p>but it doesn&#039;t create a eth device, and i can&#039;t set a interface up.</p><p>anyone does know something about it?</p><p>bye...masc.</p>									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p43296">
				<div class="post-metadata">
					<div class="post-num">Post #2</div>
					<div class="post-author">masc</div>
					<div class="post-datetime">
						26 Feb 2007, 17:27					</div>
				</div>
				<div class="post-content content">
					<p>oh. i saw that there is a rev2 of this device, which is different. it works with 2.6.something. </p><p>do anybody know if there is a backport to the 2.4 series or do i have to install kamikaze?</p><p>bye...masc.</p>									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p43303">
				<div class="post-metadata">
					<div class="post-num">Post #3</div>
					<div class="post-author">masc</div>
					<div class="post-datetime">
						26 Feb 2007, 19:54					</div>
				</div>
				<div class="post-content content">
					<p>i found a backport of the usbnet driver at <a href="http://sourceforge.net/project/showfiles.php?group_id=138561">http://sourceforge.net/project/showfile … _id=138561</a> , but for 2.4.27. i deleted something that caused errors, added missing defines in mii.h and the final product usbnet.o works, as far as i have tested. </p><br /><p>here is the patch, against 2.4.30:</p><p>diff -ruN linux-2.4.30/drivers/usb/usbnet.c linux-2.4.30_mo/drivers/usb/usbnet.c<br />--- linux-2.4.30/drivers/usb/usbnet.c&nbsp; &nbsp; 2004-04-14 15:05:36.000000000 +0200<br />+++ linux-2.4.30_mo/drivers/usb/usbnet.c&nbsp; &nbsp; 2007-02-26 18:00:28.000000000 +0100<br />@@ -121,6 +121,8 @@<br />&nbsp; * 15-dec-2002&nbsp; &nbsp; Partial sync with 2.5 code: cleanups and stubbed PXA-250<br />&nbsp; * &nbsp; &nbsp; &nbsp; &nbsp; support (db), fix for framing issues on Z, net1080, and<br />&nbsp; * &nbsp; &nbsp; &nbsp; &nbsp; gl620a (Toby Milne)<br />+ * 19-jun-2005&nbsp; &nbsp; ax88772 and ax88178 support backported from 2.6.12, with<br />+ *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; some tuning for performance on mips tivos (Jamie).<br />&nbsp; *<br />&nbsp; *-------------------------------------------------------------------------*/</p><p>@@ -157,6 +159,7 @@</p> <br /><p> /* minidrivers _could_ be individually configured */<br />+#define&nbsp; &nbsp; CONFIG_USB_ALI_M5632<br /> #define&nbsp; &nbsp; CONFIG_USB_AN2720<br /> #define&nbsp; &nbsp; CONFIG_USB_AX8817X<br /> #define&nbsp; &nbsp; CONFIG_USB_BELKIN<br />@@ -168,10 +171,26 @@<br /> #define&nbsp; &nbsp; CONFIG_USB_ZAURUS</p> <br /><p>-#define DRIVER_VERSION&nbsp; &nbsp; &nbsp; &nbsp; &quot;18-Oct-2002&quot;<br />+// Define this to use experimental code that sets up a custom<br />+// hard_header to avoid a data copy for ax88178/ax88772 framing.<br />+#define&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;AX_CUSTOM_HARD_HEADER<br />+<br />+// Force packets to be aligned.&nbsp; An extra data copy in some cases, but avoids alignment errors<br />+#define&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AX_ALIGN<br />+<br />+#define DRIVER_VERSION&nbsp; &nbsp; &nbsp; &nbsp; &quot;20-Jun-2005&quot;</p><p> /*-------------------------------------------------------------------------*/</p><p>+static int max_rxq_mem = 150000;<br />+MODULE_PARM (max_rxq_mem, &quot;i&quot;;)<br />+MODULE_PARM_DESC (max_rxq_mem, &quot;bytes to use for rx queue&quot;);<br />+<br />+static int max_txq_mem = 150000;<br />+MODULE_PARM (max_txq_mem, &quot;i&quot;);<br />+MODULE_PARM_DESC (max_tzq_mem, &quot;bytes to use for tx queue&quot;);<br />+<br />+<br /> /*<br />&nbsp; * Nineteen USB 1.1 max size bulk transactions per frame (ms), max.<br />&nbsp; * Several dozen bytes of IPv4 data can fit in two such transactions.<br />@@ -179,13 +198,8 @@<br />&nbsp; * For high speed, each frame comfortably fits almost 36 max size<br />&nbsp; * Ethernet packets (so queues should be bigger).<br />&nbsp; */<br />-#ifdef REALLY_QUEUE<br />-#define&nbsp; &nbsp; RX_QLEN&nbsp; &nbsp; &nbsp; &nbsp; 4<br />-#define&nbsp; &nbsp; TX_QLEN&nbsp; &nbsp; &nbsp; &nbsp; 4<br />-#else<br />-#define&nbsp; &nbsp; RX_QLEN&nbsp; &nbsp; &nbsp; &nbsp; 1<br />-#define&nbsp; &nbsp; TX_QLEN&nbsp; &nbsp; &nbsp; &nbsp; 1<br />-#endif<br />+#define&nbsp; &nbsp; RX_QLEN(dev) ((dev)-&gt;rx_qlen)<br />+#define&nbsp; &nbsp; TX_QLEN(dev) ((dev)-&gt;tx_qlen)</p><p> // packets are always ethernet inside<br /> // ... except they can be bigger (limit of 64K with NetChip framing)<br />@@ -222,6 +236,7 @@</p><p> &nbsp; &nbsp; // i/o info: pipes etc<br /> &nbsp; &nbsp; unsigned&nbsp; &nbsp; &nbsp; &nbsp; in, out;<br />+&nbsp; &nbsp; struct usb_endpoint_descriptor *status;<br /> &nbsp; &nbsp; unsigned&nbsp; &nbsp; &nbsp; &nbsp; maxpacket;<br /> &nbsp; &nbsp; //struct timer_list&nbsp; &nbsp; delay;</p><p>@@ -230,6 +245,7 @@<br /> &nbsp; &nbsp; struct net_device_stats&nbsp; &nbsp; stats;<br /> &nbsp; &nbsp; int&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg_level;<br /> &nbsp; &nbsp; struct mii_if_info&nbsp; &nbsp; mii;<br />+&nbsp; &nbsp; &nbsp; unsigned long&nbsp; &nbsp; &nbsp; &nbsp; data [5];</p><p> #ifdef CONFIG_USB_NET1080<br /> &nbsp; &nbsp; u16&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; packet_id;<br />@@ -239,13 +255,24 @@<br /> &nbsp; &nbsp; struct sk_buff_head&nbsp; &nbsp; rxq;<br /> &nbsp; &nbsp; struct sk_buff_head&nbsp; &nbsp; txq;<br /> &nbsp; &nbsp; struct sk_buff_head&nbsp; &nbsp; done;<br />+&nbsp; &nbsp; struct urb&nbsp; &nbsp; &nbsp; &nbsp; *interrupt;<br />+&nbsp; &nbsp; char *intr_buf;&nbsp; &nbsp; &nbsp; &nbsp; /*&nbsp; interrupt buffer*/<br />+<br /> &nbsp; &nbsp; struct tasklet_struct&nbsp; &nbsp; bh;</p><p> &nbsp; &nbsp; struct tq_struct&nbsp; &nbsp; kevent;<br /> &nbsp; &nbsp; unsigned long&nbsp; &nbsp; &nbsp; &nbsp; flags;<br />+<br />+<br />+&nbsp; &nbsp; // transmit and receive queue lengths, dependent on MTU and USB speed<br />+&nbsp; &nbsp; unsigned short rx_qlen;<br />+&nbsp; &nbsp; unsigned short tx_qlen;<br />+<br /> #&nbsp; &nbsp; &nbsp; &nbsp; define EVENT_TX_HALT&nbsp; &nbsp; 0<br /> #&nbsp; &nbsp; &nbsp; &nbsp; define EVENT_RX_HALT&nbsp; &nbsp; 1<br /> #&nbsp; &nbsp; &nbsp; &nbsp; define EVENT_RX_MEMORY&nbsp; &nbsp; 2<br />+#&nbsp; &nbsp; &nbsp; &nbsp; define EVENT_LINK_RESET&nbsp; &nbsp; 4<br />+<br /> };</p><p> // device-specific info used by the driver<br />@@ -259,8 +286,11 @@<br /> #define FLAG_NO_SETINT&nbsp; &nbsp; 0x0010&nbsp; &nbsp; &nbsp; &nbsp; /* device can&#039;t set_interface() */<br /> #define FLAG_ETHER&nbsp; &nbsp; 0x0020&nbsp; &nbsp; &nbsp; &nbsp; /* maybe use &quot;eth%d&quot; names */</p><p>+#define FLAG_FRAMING_AX 0x0040&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* AX88772/178 packets */<br />+#define FLAG_FRAMING_JUMBO_AX 0x0080&nbsp; &nbsp; /* AX88772/178 jumbo packets */<br />+<br /> &nbsp; &nbsp; /* init device ... can sleep, or cause probe() failure */<br />-&nbsp; &nbsp; int&nbsp; &nbsp; (*bind)(struct usbnet *, struct usb_device *);<br />+&nbsp; &nbsp; int&nbsp; &nbsp; (*bind)(struct usbnet *, struct usb_interface *);</p><p> &nbsp; &nbsp; /* reset device ... can sleep */<br /> &nbsp; &nbsp; int&nbsp; &nbsp; (*reset)(struct usbnet *);<br />@@ -268,6 +298,12 @@<br /> &nbsp; &nbsp; /* see if peer is connected ... can sleep */<br /> &nbsp; &nbsp; int&nbsp; &nbsp; (*check_connect)(struct usbnet *);</p><p>+&nbsp; &nbsp; /* for status polling */<br />+&nbsp; &nbsp; void&nbsp; &nbsp; (*status)(struct usbnet *, struct urb *);<br />+<br />+&nbsp; &nbsp; /* link reset handling, called from defer_kevent */<br />+&nbsp; &nbsp; int&nbsp; &nbsp; (*link_reset)(struct usbnet *);<br />+<br /> &nbsp; &nbsp; /* fixup rx packet (strip framing) */<br /> &nbsp; &nbsp; int&nbsp; &nbsp; (*rx_fixup)(struct usbnet *dev, struct sk_buff *skb);</p><p>@@ -303,9 +339,9 @@<br /> static const char driver_name [] = &quot;usbnet&quot;;</p><p> /* use ethtool to change the level for any given device */<br />-static int msg_level = 1;<br />+static int msg_level = 2;<br /> MODULE_PARM (msg_level, &quot;i&quot;);<br />-MODULE_PARM_DESC (msg_level, &quot;Initial message level (default = 1)&quot;);<br />+MODULE_PARM_DESC (msg_level, &quot;Initial message level (default = 2)&quot;);</p> <br /><p> #define&nbsp; &nbsp; mutex_lock(x)&nbsp; &nbsp; down(x)<br />@@ -314,7 +350,9 @@<br /> #define&nbsp; &nbsp; RUN_CONTEXT (in_irq () ? &quot;in_irq&quot; \<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : (in_interrupt () ? &quot;in_interrupt&quot; : &quot;can sleep&quot;))</p><p>+#ifdef ETHTOOL<br /> static struct ethtool_ops usbnet_ethtool_ops;<br />+#endif</p><p> /* mostly for PDA style devices, which are always present */<br /> static int always_connected (struct usbnet *dev)<br />@@ -329,38 +367,52 @@<br /> get_endpoints (struct usbnet *dev, struct usb_interface *intf)<br /> {<br /> &nbsp; &nbsp; int&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp;<br />-&nbsp; &nbsp; struct usb_interface_descriptor&nbsp; &nbsp; *alt;<br />-&nbsp; &nbsp; struct usb_endpoint_descriptor&nbsp; &nbsp; *in, *out;<br />+&nbsp; &nbsp; struct usb_interface_descriptor&nbsp; &nbsp; *alt = NULL;<br />+&nbsp; &nbsp; struct usb_endpoint_descriptor&nbsp; &nbsp; &nbsp; *in = NULL, *out = NULL;<br />+&nbsp; &nbsp; struct usb_endpoint_descriptor&nbsp; &nbsp; *status = NULL;</p><p>-&nbsp; &nbsp; for (tmp = 0; tmp &lt; intf-&gt;max_altsetting; tmp++) {<br />+&nbsp; &nbsp; for (tmp = 0; tmp &lt; intf-&gt;num_altsetting; tmp++) {<br /> &nbsp; &nbsp; &nbsp; &nbsp; unsigned&nbsp; &nbsp; ep;</p><p>-&nbsp; &nbsp; &nbsp; &nbsp; in = out = 0;<br />+&nbsp; &nbsp; &nbsp; &nbsp; in = out = status = NULL;<br /> &nbsp; &nbsp; &nbsp; &nbsp; alt = intf-&gt;altsetting + tmp;</p><p> &nbsp; &nbsp; &nbsp; &nbsp; /* take the first altsetting with in-bulk + out-bulk;<br />+&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remember any status endpoint, just in case;<br /> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ignore other endpoints and altsetttings.<br /> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br /> &nbsp; &nbsp; &nbsp; &nbsp; for (ep = 0; ep &lt; alt-&gt;bNumEndpoints; ep++) {<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct usb_endpoint_descriptor&nbsp; &nbsp; *e;<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intr = 0;</p><p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e = alt-&gt;endpoint + ep;<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e-&gt;bmAttributes != USB_ENDPOINT_XFER_BULK)<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; switch (e-&gt;bmAttributes) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case USB_ENDPOINT_XFER_INT:<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!(e-&gt;bEndpointAddress &amp; USB_DIR_IN))<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intr = 1;<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* FALLTHROUGH */<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case USB_ENDPOINT_XFER_BULK:<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; default:<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e-&gt;bEndpointAddress &amp; USB_DIR_IN) {<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!in)<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!intr &amp;&amp; !in)<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in = e;<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (intr &amp;&amp; !status)<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = e;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!out)<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out = e;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (in &amp;&amp; out)<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto found;<br /> &nbsp; &nbsp; &nbsp; &nbsp; }<br />+&nbsp; &nbsp; &nbsp; &nbsp; if (in &amp;&amp; out)<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br /> &nbsp; &nbsp; }<br />-&nbsp; &nbsp; return -EINVAL;<br />+&nbsp; &nbsp; if (!alt || !in || !out)<br />+&nbsp; &nbsp; &nbsp; &nbsp; return -EINVAL;</p><p>-found:<br /> &nbsp; &nbsp; if (alt-&gt;bAlternateSetting != 0<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || !(dev-&gt;driver_info-&gt;flags &amp; FLAG_NO_SETINT)) {<br /> &nbsp; &nbsp; &nbsp; &nbsp; tmp = usb_set_interface (dev-&gt;udev, alt-&gt;bInterfaceNumber,<br />@@ -374,6 +426,7 @@<br /> &nbsp; &nbsp; dev-&gt;out = usb_sndbulkpipe (dev-&gt;udev,<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out-&gt;bEndpointAddress &amp; USB_ENDPOINT_NUMBER_MASK);<br /> &nbsp; &nbsp; dev-&gt;maxpacket = usb_maxpacket (dev-&gt;udev, dev-&gt;out, 1);<br />+&nbsp; &nbsp; dev-&gt;status = status;<br /> &nbsp; &nbsp; return 0;<br /> }</p><p>@@ -382,15 +435,166 @@<br /> #ifdef DEBUG<br /> #define devdbg(usbnet, fmt, arg...) \<br /> &nbsp; &nbsp; printk(KERN_DEBUG &quot;%s: &quot; fmt &quot;\n&quot; , (usbnet)-&gt;net.name , ## arg)<br />+#define dbg(fmt, arg...) \<br />+&nbsp; &nbsp; printk(KERN_DEBUG fmt &quot;\n&quot; , ## arg)<br />+<br /> #else<br /> #define devdbg(usbnet, fmt, arg...) do {} while(0)<br /> #endif</p><p>+#define deverr(usbnet, fmt, arg...) \<br />+&nbsp; &nbsp; printk(KERN_ERR &quot;%s: &quot; fmt &quot;\n&quot; , (usbnet)-&gt;net.name , ## arg); \<br />+<br /> #define devinfo(usbnet, fmt, arg...) \<br /> &nbsp; &nbsp; do { if ((usbnet)-&gt;msg_level &gt;= 1) \<br /> &nbsp; &nbsp; printk(KERN_INFO &quot;%s: &quot; fmt &quot;\n&quot; , (usbnet)-&gt;net.name , ## arg); \<br /> &nbsp; &nbsp; } while (0)</p><p>+<br />+/*-------------------------------------------------------------------------*/<br />+<br />+static void intr_complete (struct urb *urb);<br />+<br />+static int init_status (struct usbnet *dev)<br />+{<br />+&nbsp; &nbsp; unsigned&nbsp; &nbsp; maxp;<br />+&nbsp; &nbsp; unsigned&nbsp; &nbsp; pipe = 0;<br />+<br />+&nbsp; &nbsp; dev-&gt;intr_buf = NULL;<br />+&nbsp; &nbsp; dev-&gt;interrupt = NULL;<br />+<br />+<br />+&nbsp; &nbsp; pipe = usb_rcvintpipe (dev-&gt;udev,<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; dev-&gt;status-&gt;bEndpointAddress<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &amp; USB_ENDPOINT_NUMBER_MASK);<br />+&nbsp; &nbsp; maxp = usb_maxpacket (dev-&gt;udev, pipe, 0);<br />+<br />+&nbsp; &nbsp; if (!dev-&gt;driver_info-&gt;status)<br />+&nbsp; &nbsp; &nbsp; &nbsp; return 0;<br />+<br />+&nbsp; &nbsp; dev-&gt;intr_buf = kmalloc (maxp, GFP_KERNEL);<br />+&nbsp; &nbsp; if (dev-&gt;intr_buf) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dev-&gt;interrupt = ALLOC_URB (0, GFP_KERNEL);<br />+&nbsp; &nbsp; &nbsp; &nbsp; if (!dev-&gt;interrupt) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kfree (dev-&gt;intr_buf);<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dev-&gt;intr_buf = NULL;<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -ENOMEM;<br />+&nbsp; &nbsp; &nbsp; &nbsp; }<br />+&nbsp; &nbsp; }<br />+&nbsp; &nbsp; return&nbsp; 0;<br />+}<br />+<br />+#ifdef DEBUG<br />+void usb_dump_urb (struct urb *urb)<br />+{<br />+&nbsp; &nbsp; printk (&quot;urb&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:%p\n&quot;, urb);<br />+&nbsp; &nbsp; printk (&quot;next&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :%p\n&quot;, urb-&gt;next);<br />+&nbsp; &nbsp; printk (&quot;dev&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:%p\n&quot;, urb-&gt;dev);<br />+&nbsp; &nbsp; printk (&quot;pipe&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :%08X\n&quot;, urb-&gt;pipe);<br />+&nbsp; &nbsp; printk (&quot;status&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :%d\n&quot;, urb-&gt;status);<br />+&nbsp; &nbsp; printk (&quot;transfer_flags&nbsp; &nbsp; &nbsp; &nbsp; :%08X\n&quot;, urb-&gt;transfer_flags);<br />+&nbsp; &nbsp; printk (&quot;transfer_buffer&nbsp; &nbsp; &nbsp; &nbsp;:%p\n&quot;, urb-&gt;transfer_buffer);<br />+&nbsp; &nbsp; printk (&quot;transfer_buffer_length:%d\n&quot;, urb-&gt;transfer_buffer_length);<br />+&nbsp; &nbsp; printk (&quot;actual_length&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:%d\n&quot;, urb-&gt;actual_length);<br />+&nbsp; &nbsp; printk (&quot;setup_packet&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :%p\n&quot;, urb-&gt;setup_packet);<br />+&nbsp; &nbsp; printk (&quot;start_frame&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:%d\n&quot;, urb-&gt;start_frame);<br />+&nbsp; &nbsp; printk (&quot;number_of_packets&nbsp; &nbsp; &nbsp;:%d\n&quot;, urb-&gt;number_of_packets);<br />+&nbsp; &nbsp; printk (&quot;interval&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :%d\n&quot;, urb-&gt;interval);<br />+&nbsp; &nbsp; printk (&quot;error_count&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:%d\n&quot;, urb-&gt;error_count);<br />+&nbsp; &nbsp; printk (&quot;context&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:%p\n&quot;, urb-&gt;context);<br />+&nbsp; &nbsp; printk (&quot;complete&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :%p\n&quot;, urb-&gt;complete);<br />+}<br />+#endif<br />+<br />+static int submit_intr_urb (struct usbnet *dev)<br />+{<br />+&nbsp; &nbsp; unsigned&nbsp; &nbsp; maxp;<br />+&nbsp; &nbsp; unsigned&nbsp; &nbsp; pipe = 0;<br />+&nbsp; &nbsp; unsigned&nbsp; &nbsp; period;<br />+<br />+&nbsp; &nbsp; if (!dev-&gt;driver_info-&gt;status)<br />+&nbsp; &nbsp; &nbsp; &nbsp; return 0;<br />+<br />+&nbsp; &nbsp; pipe = usb_rcvintpipe (dev-&gt;udev,<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; dev-&gt;status-&gt;bEndpointAddress<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &amp; USB_ENDPOINT_NUMBER_MASK);<br />+&nbsp; &nbsp; maxp = usb_maxpacket (dev-&gt;udev, pipe, 0);<br />+<br />+&nbsp; &nbsp; /* avoid 1 msec chatter:&nbsp; min&lt; 100 msec poll rate */<br />+&nbsp; &nbsp; period = (dev-&gt;udev-&gt;speed == USB_SPEED_HIGH) ? 7 : 3;<br />+&nbsp; &nbsp; if (period &lt; dev-&gt;status-&gt;bInterval) period = dev-&gt;status-&gt;bInterval;<br />+<br />+&nbsp; &nbsp; if (dev-&gt;udev-&gt;speed == USB_SPEED_HIGH)<br />+&nbsp; &nbsp; &nbsp; &nbsp; period = (1 &lt;&lt; period);<br />+<br />+&nbsp; &nbsp; if (dev-&gt;intr_buf &amp;&amp; dev-&gt;interrupt) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; usb_fill_int_urb(dev-&gt;interrupt, dev-&gt;udev, pipe,<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;dev-&gt;intr_buf, maxp, intr_complete, dev, period);<br />+&nbsp; &nbsp; &nbsp; &nbsp; //&nbsp; &nbsp; &nbsp; &nbsp; FILL_INT_URB(dev-&gt;interrupt, dev-&gt;udev, pipe,<br />+&nbsp; &nbsp; &nbsp; &nbsp; //&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; dev-&gt;intr_buf, maxp, intr_complete, dev, period);<br />+&nbsp; &nbsp; &nbsp; &nbsp; devdbg( dev,<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;status ep%din, %d bytes period %d bInterval: %d\n&quot;,<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usb_pipeendpoint(pipe), maxp, period, dev-&gt;status-&gt;bInterval);<br />+#ifdef DEBUG<br />+&nbsp; &nbsp; &nbsp; &nbsp; usb_dump_urb(dev-&gt;interrupt);<br />+#endif<br />+&nbsp; &nbsp; &nbsp; &nbsp; return usb_submit_urb(dev-&gt;interrupt);<br />+&nbsp; &nbsp; }<br />+&nbsp; &nbsp; return -ENOMEM;<br />+}<br />+<br />+/*-------------------------------------------------------------------------*/<br />+<br />+static void intr_complete (struct urb *urb)<br />+{<br />+&nbsp; &nbsp; struct usbnet&nbsp; &nbsp; *dev = urb-&gt;context;<br />+&nbsp; &nbsp; int&nbsp; &nbsp; &nbsp; &nbsp; status = urb-&gt;status;<br />+<br />+&nbsp; &nbsp; switch (status) {<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;/* success */<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;case 0:<br />+&nbsp; &nbsp; &nbsp; &nbsp; dev-&gt;driver_info-&gt;status(dev, urb);<br />+&nbsp; &nbsp; &nbsp; &nbsp; break;<br />+<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;/* software-driven interface shutdown */<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;case -ENOENT:&nbsp; &nbsp; &nbsp; &nbsp; // urb killed<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;case -ESHUTDOWN:&nbsp; &nbsp; &nbsp; &nbsp; // hardware gone<br />+&nbsp; &nbsp; &nbsp; &nbsp; devdbg (dev, &quot;intr shutdown, code %d&quot;, status);<br />+&nbsp; &nbsp; &nbsp; &nbsp; return;<br />+<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;/* NOTE:&nbsp; not throttling like RX/TX, since this endpoint<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; * already polls infrequently<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; */<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;default:<br />+&nbsp; &nbsp; &nbsp; &nbsp; devdbg (dev, &quot;intr status %d&quot;, status);<br />+&nbsp; &nbsp; &nbsp; &nbsp; break;<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; memset(urb-&gt;transfer_buffer, 0, urb-&gt;transfer_buffer_length);<br />+&nbsp; &nbsp; if (!netif_running (&amp;dev-&gt;net))<br />+&nbsp; &nbsp; &nbsp; &nbsp; return;<br />+&nbsp; &nbsp; /* 2.4 has automagic resubmit */<br />+}<br />+<br />+/*-------------------------------------------------------------------------*/<br />+<br />+<br />+#ifdef&nbsp; &nbsp; CONFIG_USB_ALI_M5632<br />+#define&nbsp; &nbsp; HAVE_HARDWARE<br />+<br />+/*-------------------------------------------------------------------------<br />+ *<br />+ * ALi M5632 driver ... does high speed<br />+ *<br />+ *-------------------------------------------------------------------------*/<br />+<br />+static const struct driver_info&nbsp; &nbsp; ali_m5632_info = {<br />+&nbsp; &nbsp; .description =&nbsp; &nbsp; &quot;ALi M5632&quot;,<br />+};<br />+<br />+<br />+#endif<br />+</p><p> #ifdef&nbsp; &nbsp; CONFIG_USB_AN2720</p><p>@@ -429,6 +633,11 @@<br /> #define AX_CMD_READ_MII_REG&nbsp; &nbsp; &nbsp; &nbsp; 0x07<br /> #define AX_CMD_WRITE_MII_REG&nbsp; &nbsp; &nbsp; &nbsp; 0x08<br /> #define AX_CMD_SET_HW_MII&nbsp; &nbsp; &nbsp; &nbsp; 0x0a<br />+#define AX_CMD_READ_EEPROM&nbsp; &nbsp; &nbsp; &nbsp; 0x0b<br />+#define AX_CMD_WRITE_EEPROM&nbsp; &nbsp; &nbsp; &nbsp; 0x0c<br />+#define AX_CMD_WRITE_ENABLE&nbsp; &nbsp; &nbsp; &nbsp; 0x0d<br />+#define AX_CMD_WRITE_DISABLE&nbsp; &nbsp; &nbsp; &nbsp; 0x0e<br />+#define AX_CMD_READ_RX_CTL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0f<br /> #define AX_CMD_WRITE_RX_CTL&nbsp; &nbsp; &nbsp; &nbsp; 0x10<br /> #define AX_CMD_READ_IPG012&nbsp; &nbsp; &nbsp; &nbsp; 0x11<br /> #define AX_CMD_WRITE_IPG0&nbsp; &nbsp; &nbsp; &nbsp; 0x12<br />@@ -437,12 +646,94 @@<br /> #define AX_CMD_WRITE_MULTI_FILTER&nbsp; &nbsp; 0x16<br /> #define AX_CMD_READ_NODE_ID&nbsp; &nbsp; &nbsp; &nbsp; 0x17<br /> #define AX_CMD_READ_PHY_ID&nbsp; &nbsp; &nbsp; &nbsp; 0x19<br />+#define AX_CMD_READ_MEDIUM_STATUS&nbsp; &nbsp; 0x1a<br /> #define AX_CMD_WRITE_MEDIUM_MODE&nbsp; &nbsp; 0x1b<br />+#define AX_CMD_READ_MONITOR_MODE&nbsp; &nbsp; 0x1c<br />+#define AX_CMD_WRITE_MONITOR_MODE&nbsp; &nbsp; 0x1d<br /> #define AX_CMD_WRITE_GPIOS&nbsp; &nbsp; &nbsp; &nbsp; 0x1f<br />+#define AX_CMD_SW_RESET&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x20<br />+#define AX_CMD_SW_PHY_STATUS&nbsp; &nbsp; &nbsp; &nbsp; 0x21<br />+#define AX_CMD_SW_PHY_SELECT&nbsp; &nbsp; &nbsp; &nbsp; 0x22<br />+#define AX88772_CMD_READ_NODE_ID&nbsp; &nbsp; 0x13<br />+<br />+#define AX_MONITOR_MODE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x01<br />+#define AX_MONITOR_LINK&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x02<br />+#define AX_MONITOR_MAGIC&nbsp; &nbsp; &nbsp; &nbsp; 0x04<br />+#define AX_MONITOR_HSFS&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x10<br />+<br />+/* AX88172 Medium Status Register values */<br />+#define AX_MEDIUM_FULL_DUPLEX&nbsp; &nbsp; &nbsp; &nbsp; 0x02<br />+#define AX_MEDIUM_TX_ABORT_ALLOW&nbsp; &nbsp; 0x04<br />+#define AX_MEDIUM_FLOW_CONTROL_EN&nbsp; &nbsp; 0x10<br />+<br />+#define AX_MEDIUM_FULL_DUPLEX_MODE&nbsp; &nbsp; &nbsp; &nbsp;(AX_MEDIUM_FULL_DUPLEX|AX_MEDIUM_TX_ABORT_ALLOW|AX_MEDIUM_FLOW_CONTROL_EN)<br />+#define AX_MEDIUM_HALF_DUPLEX_MODE&nbsp; &nbsp; &nbsp; &nbsp;(AX_MEDIUM_TX_ABORT_ALLOW|AX_MEDIUM_FLOW_CONTROL_EN)<br />+<br />+/* AX88xxx Rx Control register values */<br />+#define AX_RX_CTL_PROMISCUOUS&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0001<br />+#define AX_RX_CTL_ALL_MULTICAST&nbsp; &nbsp; &nbsp; &nbsp; 0x0002<br />+#define AX_RX_CTL_SAVE_ERROR&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x0004<br />+#define AX_RX_CTL_BROADCAST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0008<br />+#define AX_RX_CTL_MULTICAST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0010<br />+#define AX_RX_CTL_AP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x0020<br />+#define AX_RX_CTL_STARTOP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0080<br />+#define AX_RX_CTL_MFB&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0300<br />+</p><p> #define AX_MCAST_FILTER_SIZE&nbsp; &nbsp; &nbsp; &nbsp; 8<br /> #define AX_MAX_MCAST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 64</p><p>+#define AX_EEPROM_LEN&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x40<br />+<br />+#define AX_SWRESET_CLEAR&nbsp; &nbsp; &nbsp; &nbsp; 0x00<br />+#define AX_SWRESET_RR&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x01<br />+#define AX_SWRESET_RT&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x02<br />+#define AX_SWRESET_PRTE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x04<br />+#define AX_SWRESET_PRL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x08<br />+#define AX_SWRESET_BZ&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x10<br />+#define AX_SWRESET_IPRL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x20<br />+#define AX_SWRESET_IPPD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x40<br />+<br />+#define AX88772_IPG0_DEFAULT&nbsp; &nbsp; &nbsp; &nbsp; 0x15<br />+#define AX88772_IPG1_DEFAULT&nbsp; &nbsp; &nbsp; &nbsp; 0x0c<br />+#define AX88772_IPG2_DEFAULT&nbsp; &nbsp; &nbsp; &nbsp; 0x12<br />+<br />+#define AX88178_MEDIUM_GIGABIT&nbsp; &nbsp; &nbsp; &nbsp; 0x0001<br />+#define AX88178_MEDIUM_JUMBO&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0040<br />+#define AX88178_MEDIUM_ENCK&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x0008<br />+<br />+#define AX88772_MEDIUM_FULL_DUPLEX&nbsp; &nbsp; 0x0002<br />+#define AX88772_MEDIUM_RESERVED&nbsp; &nbsp; &nbsp; &nbsp; 0x0004<br />+#define AX88772_MEDIUM_RX_FC_ENABLE&nbsp; &nbsp; 0x0010<br />+#define AX88772_MEDIUM_TX_FC_ENABLE&nbsp; &nbsp; 0x0020<br />+#define AX88772_MEDIUM_PAUSE_FORMAT&nbsp; &nbsp; 0x0080<br />+#define AX88772_MEDIUM_RX_ENABLE&nbsp; &nbsp; 0x0100<br />+#define AX88772_MEDIUM_100MB&nbsp; &nbsp; &nbsp; &nbsp; 0x0200<br />+#define AX88772_MEDIUM_DEFAULT&nbsp; &nbsp; \<br />+&nbsp; &nbsp; (AX88772_MEDIUM_FULL_DUPLEX | AX88772_MEDIUM_RX_FC_ENABLE | \<br />+&nbsp; &nbsp;&nbsp; AX88772_MEDIUM_TX_FC_ENABLE | AX88772_MEDIUM_100MB | \<br />+&nbsp; &nbsp;&nbsp; AX88772_MEDIUM_RESERVED | AX88772_MEDIUM_RX_ENABLE )<br />+#define AX88178_MEDIUM_DEFAULT&nbsp; &nbsp; AX88772_MEDIUM_DEFAULT<br />+<br />+#define AX88178_IPG0_DEFAULT&nbsp; &nbsp; &nbsp; &nbsp; 0x15<br />+#define AX88178_IPG1_DEFAULT&nbsp; &nbsp; &nbsp; &nbsp; 0x0c<br />+#define AX88178_IPG2_DEFAULT&nbsp; &nbsp; &nbsp; &nbsp; 0x12<br />+<br />+#define AX_EEPROM_MAGIC&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0xdeadbeef<br />+<br />+/* This structure cannot exceed sizeof(unsigned long [5]) AKA 20 bytes */<br />+struct ax8817x_data {<br />+&nbsp; &nbsp; u8 multi_filter[AX_MCAST_FILTER_SIZE];<br />+};<br />+<br />+struct ax88172_int_data {<br />+&nbsp; &nbsp; u16 res1;<br />+&nbsp; &nbsp; u8 link;<br />+&nbsp; &nbsp; u16 res2;<br />+&nbsp; &nbsp; u8 status;<br />+&nbsp; &nbsp; u16 res3;<br />+} __attribute__ ((packed));<br />+<br /> static int ax8817x_read_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;u16 size, void *data)<br /> {<br />@@ -485,6 +776,7 @@<br /> &nbsp; &nbsp; usb_free_urb(urb);<br /> }</p><p>+<br /> static void ax8817x_write_cmd_async(struct usbnet *dev, u8 cmd, u16 value, u16 index,<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;u16 size, void *data)<br /> {<br />@@ -518,52 +810,93 @@<br /> &nbsp; &nbsp; &nbsp; &nbsp; devdbg(dev, &quot;Error submitting the control message: status=%d&quot;, status);<br /> }</p><p>+/* some work can&#039;t be done in tasklets, so we use keventd<br />+ *<br />+ * NOTE:&nbsp; annoying asymmetry:&nbsp; if it&#039;s active, schedule_task() fails,<br />+ * but tasklet_schedule() doesn&#039;t.&nbsp; hope the failure is rare.<br />+ */<br />+static void defer_kevent (struct usbnet *dev, int work)<br />+{<br />+&nbsp; &nbsp; set_bit (work, &amp;dev-&gt;flags);<br />+&nbsp; &nbsp; if (!schedule_task (&amp;dev-&gt;kevent)) {<br />+&nbsp; &nbsp;&nbsp; &nbsp;if (work != EVENT_RX_MEMORY)<br />+&nbsp; &nbsp; &nbsp; &nbsp; err (&quot;%s: kevent %d may have been dropped&quot;,<br />+&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; dev-&gt;net.name, work);<br />+&nbsp; &nbsp; } else {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg (&quot;%s: kevent %d scheduled&quot;, dev-&gt;net.name, work);<br />+&nbsp; &nbsp; }<br />+}<br />+<br />+<br />+static void ax8817x_status(struct usbnet *dev, struct urb *urb)<br />+{<br />+&nbsp; &nbsp; struct ax88172_int_data *event;<br />+&nbsp; &nbsp; int link;<br />+<br />+&nbsp; &nbsp; if (urb-&gt;actual_length &lt; 8)<br />+&nbsp; &nbsp; &nbsp; &nbsp; return;<br />+<br />+&nbsp; &nbsp; event = urb-&gt;transfer_buffer;<br />+&nbsp; &nbsp; link = event-&gt;link &amp; 0x01;<br />+&nbsp; &nbsp; if (netif_carrier_ok(&amp;dev-&gt;net) != link) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; if (link) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; netif_carrier_on(&amp;dev-&gt;net);<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defer_kevent (dev, EVENT_LINK_RESET );<br />+&nbsp; &nbsp; &nbsp; &nbsp; } else {<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; netif_carrier_off(&amp;dev-&gt;net);<br />+&nbsp; &nbsp; &nbsp; &nbsp; }<br />+&nbsp; &nbsp; &nbsp; &nbsp; devdbg(dev, &quot;ax8817x - Link Status is: %d&quot;, link);<br />+&nbsp; &nbsp; }<br />+}<br />+<br /> static void ax8817x_set_multicast(struct net_device *net)<br /> {<br /> &nbsp; &nbsp; struct usbnet *dev = (struct usbnet *) net-&gt;priv;<br />-&nbsp; &nbsp; u8 rx_ctl = 0x8c;<br />+&nbsp; &nbsp; struct ax8817x_data *data = (struct ax8817x_data *)&amp;dev-&gt;data;<br />+&nbsp; &nbsp; u16 rx_ctl = AX_RX_CTL_STARTOP | AX_RX_CTL_BROADCAST;</p><p> &nbsp; &nbsp; if (net-&gt;flags &amp; IFF_PROMISC) {<br />-&nbsp; &nbsp; &nbsp; &nbsp; rx_ctl |= 0x01;<br />+&nbsp; &nbsp; &nbsp; &nbsp; rx_ctl |= AX_RX_CTL_PROMISCUOUS;<br /> &nbsp; &nbsp; } else if (net-&gt;flags &amp; IFF_ALLMULTI<br /> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; || net-&gt;mc_count &gt; AX_MAX_MCAST) {<br />-&nbsp; &nbsp; &nbsp; &nbsp; rx_ctl |= 0x02;<br />+&nbsp; &nbsp; &nbsp; &nbsp; rx_ctl |= AX_RX_CTL_ALL_MULTICAST;<br /> &nbsp; &nbsp; } else if (net-&gt;mc_count == 0) {<br /> &nbsp; &nbsp; &nbsp; &nbsp; /* just broadcast and directed */<br /> &nbsp; &nbsp; } else {<br />+&nbsp; &nbsp; &nbsp; &nbsp; /* We use the 20 byte dev-&gt;data<br />+&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for our 8 byte filter buffer<br />+&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to avoid allocating memory that<br />+&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is tricky to free later */<br /> &nbsp; &nbsp; &nbsp; &nbsp; struct dev_mc_list *mc_list = net-&gt;mc_list;<br />-&nbsp; &nbsp; &nbsp; &nbsp; u8 *multi_filter;<br /> &nbsp; &nbsp; &nbsp; &nbsp; u32 crc_bits;<br /> &nbsp; &nbsp; &nbsp; &nbsp; int i;</p><p>-&nbsp; &nbsp; &nbsp; &nbsp; multi_filter = kmalloc(AX_MCAST_FILTER_SIZE, GFP_ATOMIC);<br />-&nbsp; &nbsp; &nbsp; &nbsp; if (multi_filter == NULL) {<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Oops, couldn&#039;t allocate a buffer for setting the multicast<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; filter. Try all multi mode. */<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rx_ctl |= 0x02;<br />-&nbsp; &nbsp; &nbsp; &nbsp; } else {<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(multi_filter, 0, AX_MCAST_FILTER_SIZE);<br />+&nbsp; &nbsp; &nbsp; &nbsp; memset(data-&gt;multi_filter, 0, AX_MCAST_FILTER_SIZE);</p><p>-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Build the multicast hash filter. */<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i = 0; i &lt; net-&gt;mc_count; i++) {<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; crc_bits =<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ether_crc(ETH_ALEN,<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;mc_list-&gt;dmi_addr) &gt;&gt; 26;<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; multi_filter[crc_bits &gt;&gt; 3] |=<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1 &lt;&lt; (crc_bits &amp; 7);<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mc_list = mc_list-&gt;next;<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />+&nbsp; &nbsp; &nbsp; &nbsp; /* Build the multicast hash filter. */<br />+&nbsp; &nbsp; &nbsp; &nbsp; for (i = 0; i &lt; net-&gt;mc_count; i++) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; crc_bits =<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ether_crc(ETH_ALEN,<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;mc_list-&gt;dmi_addr) &gt;&gt; 26;<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data-&gt;multi_filter[crc_bits &gt;&gt; 3] |=<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1 &lt;&lt; (crc_bits &amp; 7);<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mc_list = mc_list-&gt;next;<br />+&nbsp; &nbsp; &nbsp; &nbsp; }</p><p>-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ax8817x_write_cmd_async(dev, AX_CMD_WRITE_MULTI_FILTER, 0, 0,<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; AX_MCAST_FILTER_SIZE, multi_filter);<br />+&nbsp; &nbsp; &nbsp; &nbsp; ax8817x_write_cmd_async(dev, AX_CMD_WRITE_MULTI_FILTER, 0, 0,<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; AX_MCAST_FILTER_SIZE, data-&gt;multi_filter);</p><p>-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rx_ctl |= 0x10;<br />-&nbsp; &nbsp; &nbsp; &nbsp; }<br />+&nbsp; &nbsp; &nbsp; &nbsp; rx_ctl |= AX_RX_CTL_MULTICAST;<br /> &nbsp; &nbsp; }<br />-<br />+&nbsp; &nbsp; if (dev-&gt;driver_info-&gt;flags &amp; FLAG_FRAMING_JUMBO_AX &amp;&amp;<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;net-&gt;mtu &gt; 1500 ) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; rx_ctl |= AX_RX_CTL_MFB; /* largest framing */<br />+&nbsp; &nbsp; }<br />+&nbsp; &nbsp; devdbg( dev, &quot;ax8818x_set_multicast: writing rx_ctl: 0x%08x&quot;, rx_ctl );<br /> &nbsp; &nbsp; ax8817x_write_cmd_async(dev, AX_CMD_WRITE_RX_CTL, rx_ctl, 0, 0, NULL);<br /> }</p><p>+<br /> static int ax8817x_mdio_read(struct net_device *netdev, int phy_id, int loc)<br /> {<br /> &nbsp; &nbsp; struct usbnet *dev = netdev-&gt;priv;<br />@@ -577,6 +910,7 @@<br /> &nbsp; &nbsp; return res &amp; 0xffff;<br /> }</p><p>+<br /> static void ax8817x_mdio_write(struct net_device *netdev, int phy_id, int loc, int val)<br /> {<br /> &nbsp; &nbsp; struct usbnet *dev = netdev-&gt;priv;<br />@@ -588,7 +922,7 @@<br /> &nbsp; &nbsp; ax8817x_write_cmd(dev, AX_CMD_SET_HW_MII, 0, 0, 0, &amp;buf);<br /> }</p><p>-static int ax8817x_bind(struct usbnet *dev, struct usb_device *intf)<br />+static int ax8817x_bind(struct usbnet *dev, struct usb_interface *intf)<br /> {<br /> &nbsp; &nbsp; int ret;<br /> &nbsp; &nbsp; u8 buf[6];<br />@@ -596,8 +930,9 @@<br /> &nbsp; &nbsp; int i;<br /> &nbsp; &nbsp; unsigned long gpio_bits = dev-&gt;driver_info-&gt;data;</p><p>-&nbsp; &nbsp; dev-&gt;in = usb_rcvbulkpipe(dev-&gt;udev, 3);<br />-&nbsp; &nbsp; dev-&gt;out = usb_sndbulkpipe(dev-&gt;udev, 2);<br />+&nbsp; &nbsp; get_endpoints(dev,intf);<br />+&nbsp; &nbsp; //dev-&gt;in = usb_rcvbulkpipe(dev-&gt;udev, 3);<br />+&nbsp; &nbsp; //dev-&gt;out = usb_sndbulkpipe(dev-&gt;udev, 2);</p><p> &nbsp; &nbsp; /* Toggle the GPIOs in a manufacturer/model specific way */<br /> &nbsp; &nbsp; for (i = 2; i &gt;= 0; i--) {<br />@@ -645,8 +980,8 @@<br /> &nbsp; &nbsp; dev-&gt;mii.dev = &amp;dev-&gt;net;<br /> &nbsp; &nbsp; dev-&gt;mii.mdio_read = ax8817x_mdio_read;<br /> &nbsp; &nbsp; dev-&gt;mii.mdio_write = ax8817x_mdio_write;<br />-&nbsp; &nbsp; dev-&gt;mii.phy_id_mask = 0x3f;<br />-&nbsp; &nbsp; dev-&gt;mii.reg_num_mask = 0x1f;<br />+&nbsp; &nbsp; //&nbsp; &nbsp; dev-&gt;mii.phy_id_mask = 0x3f;<br />+&nbsp; &nbsp; //&nbsp; &nbsp; dev-&gt;mii.reg_num_mask = 0x1f;<br /> &nbsp; &nbsp; dev-&gt;mii.phy_id = buf[1];</p><p> &nbsp; &nbsp; if ((ret = ax8817x_write_cmd(dev, AX_CMD_SET_SW_MII, 0, 0, 0, &amp;buf)) &lt; 0) {<br />@@ -662,7 +997,7 @@<br /> &nbsp; &nbsp; }</p><p> &nbsp; &nbsp; /* Advertise that we can do full-duplex pause */<br />-&nbsp; &nbsp; *buf16 = cpu_to_le16(ADVERTISE_ALL | ADVERTISE_CSMA | 0x0400);<br />+&nbsp; &nbsp; *buf16 = cpu_to_le16( ADVERTISE_ALL| ADVERTISE_CSMA | 0x0400);<br /> &nbsp; &nbsp; if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_MII_REG,<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; dev-&gt;mii.phy_id, MII_ADVERTISE, <br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 2, buf16)) &lt; 0) {<br />@@ -685,12 +1020,647 @@</p><p> &nbsp; &nbsp; dev-&gt;net.set_multicast_list = ax8817x_set_multicast;</p><p>+<br />+&nbsp; &nbsp; return 0;<br />+}<br />+<br />+static int ax8817x_link_reset( struct usbnet *dev)<br />+{<br />+&nbsp; &nbsp; // Set the MEDIUM_MODE to enable flow control if in 100baseTx-FD mode and<br />+&nbsp; &nbsp; // if the module parameters allow.<br />+&nbsp; &nbsp; u8 buf = -1;<br />+&nbsp; &nbsp; int lpa = le16_to_cpu(ax8817x_mdio_read(&amp;dev-&gt;net,dev-&gt;mii.phy_id, MII_LPA));<br />+&nbsp; &nbsp; int fullduplex = ((lpa &amp; 0x0100) != 0); /* 100baseTx-FD */<br />+&nbsp; &nbsp; int mode = fullduplex ? AX_MEDIUM_FULL_DUPLEX_MODE&nbsp; :<br />+&nbsp; &nbsp;&nbsp; &nbsp;AX_MEDIUM_HALF_DUPLEX_MODE;<br />+&nbsp; &nbsp; ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE, mode, 0, 0, NULL);<br />+&nbsp; &nbsp; ax8817x_read_cmd(dev, AX_CMD_READ_MEDIUM_STATUS, 0, 0, 1, &amp;buf);<br />+&nbsp; &nbsp; devinfo(dev,&quot;Medium status: 0x%02x&quot;, buf );<br />+&nbsp; &nbsp; return 0;<br />+}<br />+<br />+static int ax88772_link_reset(struct usbnet *dev)<br />+{<br />+&nbsp; &nbsp; u16 lpa;<br />+&nbsp; &nbsp; u16 mode;<br />+<br />+&nbsp; &nbsp; mode = AX88772_MEDIUM_DEFAULT;<br />+&nbsp; &nbsp; lpa = le16_to_cpu(ax8817x_mdio_read(&amp;dev-&gt;net, dev-&gt;mii.phy_id, MII_LPA));<br />+&nbsp; &nbsp; if ((lpa &amp; LPA_DUPLEX) == 0)<br />+&nbsp; &nbsp; &nbsp; &nbsp; mode &amp;= ~AX88772_MEDIUM_FULL_DUPLEX;<br />+&nbsp; &nbsp; if ((lpa &amp; LPA_100) == 0)<br />+&nbsp; &nbsp; &nbsp; &nbsp; mode &amp;= ~AX88772_MEDIUM_100MB;<br />+<br />+&nbsp; &nbsp; devdbg( dev, &quot;ax88772_link_reset&nbsp; lpa: 0x%04x&nbsp; mode: 0x%04x&quot;, lpa, mode );<br />+&nbsp; &nbsp; ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE, mode, 0, 0, NULL);<br />+<br />+&nbsp; &nbsp; return 0;<br />+}<br />+<br />+static int ax88178_link_reset(struct usbnet *dev)<br />+{<br />+&nbsp; &nbsp; u16 lpa,lpa2,mode, rx_ctl;<br />+&nbsp; &nbsp; <br />+&nbsp; &nbsp; mode = AX88178_MEDIUM_DEFAULT;<br />+&nbsp; &nbsp; lpa = le16_to_cpu(ax8817x_mdio_read(&amp;dev-&gt;net, dev-&gt;mii.phy_id, MII_LPA));<br />+&nbsp; &nbsp; if ((lpa &amp; LPA_DUPLEX) == 0)<br />+&nbsp; &nbsp; &nbsp; &nbsp; mode &amp;= ~AX88772_MEDIUM_FULL_DUPLEX;<br />+&nbsp; &nbsp; if ((lpa &amp; LPA_100) == 0)<br />+&nbsp; &nbsp; &nbsp; &nbsp; mode &amp;= ~AX88772_MEDIUM_100MB;<br />+&nbsp; &nbsp; <br />+&nbsp; &nbsp; lpa2 = le16_to_cpu(ax8817x_mdio_read(&amp;dev-&gt;net, dev-&gt;mii.phy_id, MII_STAT1000));<br />+&nbsp; &nbsp; devdbg( dev, &quot;lpa: 0x%04x&nbsp; lpa2: 0x%04x&nbsp; phy_id: %08x&quot;, lpa, lpa2, dev-&gt;mii.phy_id );<br />+<br />+&nbsp; &nbsp; if ( (lpa2 &amp; LPA_1000FULL) || (lpa2 &amp; LPA_1000HALF)) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; mode |= AX88178_MEDIUM_GIGABIT|AX88178_MEDIUM_ENCK;<br />+&nbsp; &nbsp; &nbsp; &nbsp; if (dev-&gt;net.mtu &gt; 1500)<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mode |= AX88178_MEDIUM_JUMBO;<br />+&nbsp; &nbsp; }<br />+&nbsp; &nbsp; devdbg( dev, &quot;ax88178_link_reset: medium_mode: 0x%04x&quot;, mode );<br />+&nbsp; &nbsp; ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE, mode, 0, 0, NULL);<br />+&nbsp; &nbsp; ax8817x_read_cmd(dev, AX_CMD_READ_MEDIUM_STATUS, 0, 0, 0, &amp;mode );<br />+&nbsp; &nbsp; devdbg( dev, &quot;ax88178_link_reset: medium_mode: 0x%04x after reset&quot;, mode );<br />+<br />+&nbsp; &nbsp; if ( ax8817x_read_cmd(dev, AX_CMD_READ_RX_CTL, 0, 0, 2, &amp;rx_ctl) == 2) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; rx_ctl = le16_to_cpu(rx_ctl);<br />+&nbsp; &nbsp; &nbsp; &nbsp; if (dev-&gt;driver_info-&gt;flags &amp; FLAG_FRAMING_JUMBO_AX &amp;&amp;<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;dev-&gt;net.mtu &gt; 1500 )<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rx_ctl |= AX_RX_CTL_MFB; /* largest framing */<br />+&nbsp; &nbsp; &nbsp; &nbsp; else<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rx_ctl &amp;= ~AX_RX_CTL_MFB; /* smallest framing */<br />+&nbsp; &nbsp; &nbsp; &nbsp; devdbg( dev, &quot;ax88178_link_reset: writing rx_ctl: 0x%08x&quot;, rx_ctl );<br />+&nbsp; &nbsp; &nbsp; &nbsp; ax8817x_write_cmd_async(dev, AX_CMD_WRITE_RX_CTL, rx_ctl, 0, 0, NULL);<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; return 0;<br />+}<br />+<br />+static int ax88772_bind(struct usbnet *dev, struct usb_interface *intf)<br />+{<br />+&nbsp; &nbsp; int ret;<br />+&nbsp; &nbsp; void *buf;<br />+&nbsp; &nbsp; u32 rx_ctl;<br />+&nbsp; &nbsp; unsigned long phy_addr = dev-&gt;driver_info-&gt;data;<br />+<br />+&nbsp; &nbsp; get_endpoints(dev,intf);<br />+<br />+&nbsp; &nbsp; //dev-&gt;in = usb_rcvbulkpipe(dev-&gt;udev, 2);<br />+&nbsp; &nbsp; //dev-&gt;out = usb_sndbulkpipe(dev-&gt;udev, 3);<br />+<br />+&nbsp; &nbsp; buf = kmalloc(6, GFP_KERNEL);<br />+&nbsp; &nbsp; if(!buf) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg (&quot;Cannot allocate memory for buffer&quot;);<br />+&nbsp; &nbsp; &nbsp; &nbsp; ret = -ENOMEM;<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out1;<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 0x00B0, 0, 0, buf)) &lt; 0)<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+<br />+&nbsp; &nbsp; msleep(5);<br />+&nbsp; &nbsp; //&nbsp; &nbsp; if ((ret = ax8817x_write_cmd(dev, AX_CMD_SW_PHY_SELECT, 0x0001, 0, 0, buf)) &lt; 0) {<br />+&nbsp; &nbsp; if ((ret = ax8817x_write_cmd(dev, AX_CMD_SW_PHY_SELECT, phy_addr, 0, 0, buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Select PHY #1 failed: %d&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; if ((ret =<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_IPPD, 0, 0, buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Failed to power down internal PHY: %d&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; msleep(150);<br />+&nbsp; &nbsp; if ((ret =<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_CLEAR, 0, 0, buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Failed to perform software reset: %d&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; msleep(150);<br />+&nbsp; &nbsp; if ((ret =<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_IPRL | AX_SWRESET_PRL, 0, 0, buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Failed to set Internal/External PHY reset control: %d&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; msleep(150);<br />+&nbsp; &nbsp; if ((ret =<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL, 0x0000, 0, 0,<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Failed to reset RX_CTL: %d&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; /* Get the MAC address */<br />+&nbsp; &nbsp; memset(buf, 0, ETH_ALEN);<br />+&nbsp; &nbsp; if ((ret = ax8817x_read_cmd(dev, AX88772_CMD_READ_NODE_ID, 0, 0, ETH_ALEN, buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Failed to read MAC address: %d&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+&nbsp; &nbsp; memcpy(dev-&gt;net.dev_addr, buf, ETH_ALEN);<br />+<br />+&nbsp; &nbsp; if ((ret = ax8817x_write_cmd(dev, AX_CMD_SET_SW_MII, 0, 0, 0, buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Enabling software MII failed: %d&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; // Take out for DUB-E100 rev B1.&nbsp; See <a href="http://lkml.org/lkml/2006/7/6/132">http://lkml.org/lkml/2006/7/6/132</a><br />+#ifdef NOT_ACTIVE&nbsp; &nbsp; <br />+&nbsp; &nbsp; if (((ret =<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;ax8817x_read_cmd(dev, AX_CMD_READ_MII_REG, 0x0010, 2, 2, buf)) &lt; 0)<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;|| (*((u16 *)buf) != 0x3b00)) {<br />+&nbsp; &nbsp;&nbsp; &nbsp;dbg(&quot;Read PHY register 2 must be 0x3b00: 0x%04x ret: %d&quot;, *((u16*)buf), ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;&nbsp; &nbsp;<br />+&nbsp; &nbsp; }<br />+#endif<br />+<br />+&nbsp; &nbsp; /* Initialize MII structure */<br />+&nbsp; &nbsp; dev-&gt;mii.dev = &amp;dev-&gt;net;<br />+&nbsp; &nbsp; dev-&gt;mii.mdio_read = ax8817x_mdio_read;<br />+&nbsp; &nbsp; dev-&gt;mii.mdio_write = ax8817x_mdio_write;<br />+<br />+&nbsp; &nbsp; /* Get the PHY id */<br />+&nbsp; &nbsp; if ((ret = ax8817x_read_cmd(dev, AX_CMD_READ_PHY_ID, 0, 0, 2, buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Error reading PHY ID: %02x&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; } else if (ret &lt; 2) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; /* this should always return 2 bytes */<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;AX_CMD_READ_PHY_ID returned less than 2 bytes: ret=%02x&quot;,<br />+&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; ret = -EIO;<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+&nbsp; &nbsp; dev-&gt;mii.phy_id = *((u8 *)buf + 1);<br />+<br />+&nbsp; &nbsp; if ((ret =<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_PRL, 0, 0, buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Set external PHY reset pin level: %d&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+&nbsp; &nbsp; msleep(150);<br />+&nbsp; &nbsp; if ((ret =<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_IPRL | AX_SWRESET_PRL, 0, 0, buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Set Internal/External PHY reset control: %d&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+&nbsp; &nbsp; msleep(150);<br />+<br />+<br />+&nbsp; &nbsp; dev-&gt;net.set_multicast_list = ax8817x_set_multicast;<br />+<br />+&nbsp; &nbsp; ax8817x_mdio_write(&amp;dev-&gt;net, dev-&gt;mii.phy_id, MII_BMCR, <br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; cpu_to_le16(BMCR_RESET|BMCR_ANENABLE));<br />+&nbsp; &nbsp; ax8817x_mdio_write(&amp;dev-&gt;net, dev-&gt;mii.phy_id, MII_ADVERTISE,<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; cpu_to_le16( ADVERTISE_ALL | ADVERTISE_CSMA | 0x0400));<br />+&nbsp; &nbsp; mii_nway_restart(&amp;dev-&gt;mii);<br />+<br />+&nbsp; &nbsp; if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE, AX88772_MEDIUM_DEFAULT, 0, 0, buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Write medium mode register: %d&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_IPG0, AX88772_IPG0_DEFAULT | AX88772_IPG1_DEFAULT,AX88772_IPG2_DEFAULT, 0, buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Write IPG,IPG1,IPG2 failed: %d&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+&nbsp; &nbsp; if ((ret =<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; ax8817x_write_cmd(dev, AX_CMD_SET_HW_MII, 0, 0, 0, &amp;buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Failed to set hardware MII: %02x&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; /* Set RX_CTL to default values with 16k buffer, and enable cactus */<br />+&nbsp; &nbsp; rx_ctl = AX_RX_CTL_STARTOP | AX_RX_CTL_BROADCAST;<br />+&nbsp; &nbsp; if (dev-&gt;driver_info-&gt;flags &amp; FLAG_FRAMING_JUMBO_AX &amp;&amp;<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;dev-&gt;net.mtu &gt; 1500 ) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; rx_ctl |= AX_RX_CTL_MFB; /* largest framing */<br />+&nbsp; &nbsp; }<br />+&nbsp; &nbsp; devdbg( dev, &quot;ax88772_bind: writing rx_ctl: 0x%08x&quot;, rx_ctl );<br />+&nbsp; &nbsp; if ((ret =<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL, rx_ctl, 0, 0,<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Reset RX_CTL failed: %d&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+&nbsp; &nbsp; kfree(buf);<br />+<br />+&nbsp; &nbsp; return 0;<br />+<br />+out2:<br />+&nbsp; &nbsp; kfree(buf);<br />+out1:<br />+&nbsp; &nbsp; return ret;<br />+}<br />+<br />+static int ax88178_bind(struct usbnet *dev, struct usb_interface *intf)<br />+{<br />+&nbsp; &nbsp; int ret;<br />+&nbsp; &nbsp; void *buf;<br />+&nbsp; &nbsp; int i;<br />+&nbsp; &nbsp; unsigned long gpio_bits = dev-&gt;driver_info-&gt;data;<br />+&nbsp; &nbsp; u32 rx_ctl;<br />+&nbsp; &nbsp; get_endpoints(dev,intf);<br />+<br />+//&nbsp; &nbsp; dev-&gt;status = usb_rcvintpip(dev-&gt;udev, 1);<br />+//&nbsp; &nbsp; dev-&gt;in = usb_rcvbulkpipe(dev-&gt;udev, 2);<br />+//&nbsp; &nbsp; dev-&gt;out = usb_sndbulkpipe(dev-&gt;udev, 3);<br />+<br />+&nbsp; &nbsp; buf = kmalloc(6, GFP_KERNEL);<br />+&nbsp; &nbsp; if(!buf) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg (&quot;Cannot allocate memory for buffer&quot;);<br />+&nbsp; &nbsp; &nbsp; &nbsp; ret = -ENOMEM;<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out1;<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; /* Toggle the GPIOs in a manufacturer/model specific way */<br />+&nbsp; &nbsp; for (i = 2; i &gt;= 0; i--) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (gpio_bits &gt;&gt; (i * 8)) &amp; 0xff, 0, 0,<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf)) &lt; 0)<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; &nbsp; &nbsp; msleep(5);<br />+&nbsp; &nbsp; }<br />+<br />+<br />+&nbsp; &nbsp; if ((ret =<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_IPPD, 0, 0, buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Failed to power down internal PHY: %d&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; msleep(150);<br />+&nbsp; &nbsp; if ((ret =<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_CLEAR, 0, 0, buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Failed to perform software reset: %d&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; msleep(150);<br />+&nbsp; &nbsp; if ((ret =<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_IPRL | AX_SWRESET_PRL, 0, 0, buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Failed to set Internal/External PHY reset control: %d&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; msleep(150);<br />+<br />+&nbsp; &nbsp; if ((ret =<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL, 0x0000, 0, 0,<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Failed to reset RX_CTL: %d&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; /* Get the MAC address */<br />+&nbsp; &nbsp; memset(buf, 0, ETH_ALEN);<br />+&nbsp; &nbsp; if ((ret = ax8817x_read_cmd(dev, AX88772_CMD_READ_NODE_ID, 0, 0, ETH_ALEN, buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Failed to read MAC address: %d&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+&nbsp; &nbsp; memcpy(dev-&gt;net.dev_addr, buf, ETH_ALEN);<br />+<br />+&nbsp; &nbsp; if ((ret = ax8817x_write_cmd(dev, AX_CMD_SET_SW_MII, 0, 0, 0, buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Enabling software MII failed: %d&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; /* Initialize MII structure */<br />+&nbsp; &nbsp; dev-&gt;mii.dev = &amp;dev-&gt;net;<br />+&nbsp; &nbsp; dev-&gt;mii.mdio_read = ax8817x_mdio_read;<br />+&nbsp; &nbsp; dev-&gt;mii.mdio_write = ax8817x_mdio_write;<br />+#ifdef ETHTOOL<br />+&nbsp; &nbsp; dev-&gt;mii.supports_gmii = 1;<br />+#endif<br />+<br />+&nbsp; &nbsp; /* Get the PHY id */<br />+&nbsp; &nbsp; if ((ret = ax8817x_read_cmd(dev, AX_CMD_READ_PHY_ID, 0, 0, 2, buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Error reading PHY ID: %02x&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; } else if (ret &lt; 2) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; /* this should always return 2 bytes */<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;AX_CMD_READ_PHY_ID returned less than 2 bytes: ret=%02x&quot;,<br />+&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; ret = -EIO;<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+&nbsp; &nbsp; dev-&gt;mii.phy_id = *((u8 *)buf + 1);<br />+<br />+<br />+&nbsp; &nbsp; if ((ret =<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_PRL, 0, 0, buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Set external PHY reset pin level: %d&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+&nbsp; &nbsp; msleep(150);<br />+&nbsp; &nbsp; if ((ret =<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_IPRL | AX_SWRESET_PRL, 0, 0, buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Set Internal/External PHY reset control: %d&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+&nbsp; &nbsp; msleep(150);<br />+<br />+<br />+&nbsp; &nbsp; dev-&gt;net.set_multicast_list = ax8817x_set_multicast;<br />+#ifdef ETHTOOL<br />+&nbsp; &nbsp; dev-&gt;net.ethtool_ops = &amp;ax88772_ethtool_ops;<br />+#endif<br />+<br />+&nbsp; &nbsp; ax8817x_mdio_write(&amp;dev-&gt;net, dev-&gt;mii.phy_id, MII_BMCR, <br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; cpu_to_le16(BMCR_RESET|BMCR_ANENABLE));<br />+&nbsp; &nbsp; ax8817x_mdio_write(&amp;dev-&gt;net, dev-&gt;mii.phy_id, MII_ADVERTISE,<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; cpu_to_le16( ADVERTISE_ALL | ADVERTISE_CSMA | 0x0400));<br />+&nbsp; &nbsp; ax8817x_mdio_write(&amp;dev-&gt;net, dev-&gt;mii.phy_id, MII_CTRL1000,<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; cpu_to_le16(ADVERTISE_1000FULL));<br />+&nbsp; &nbsp; mii_nway_restart(&amp;dev-&gt;mii);<br />+<br />+<br />+<br />+&nbsp; &nbsp; /* Set IPG values */<br />+&nbsp; &nbsp; if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_IPG0, AX88178_IPG0_DEFAULT | (AX88178_IPG1_DEFAULT&lt;&lt;8),AX88178_IPG2_DEFAULT, 0, buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Write IPG,IPG1,IPG2 failed: %d&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; if ((ret =<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; ax8817x_write_cmd(dev, AX_CMD_SET_HW_MII, 0, 0, 0, &amp;buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Failed to set hardware MII: %02x&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; /* Set RX_CTL to default values with 8k buffer, and enable cactus */<br />+&nbsp; &nbsp; rx_ctl = AX_RX_CTL_STARTOP | AX_RX_CTL_BROADCAST;<br />+&nbsp; &nbsp; if (dev-&gt;driver_info-&gt;flags &amp; FLAG_FRAMING_JUMBO_AX &amp;&amp;<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;dev-&gt;net.mtu &gt; 1500 ) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; rx_ctl |= AX_RX_CTL_MFB; /* largest framing */<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; devdbg( dev, &quot;ax88178_bind: writing rx_ctl: 0x%08x&quot;, rx_ctl );<br />+&nbsp; &nbsp; if ((ret =<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL, rx_ctl, 0, 0,<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; buf)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg(&quot;Reset RX_CTL failed: %d&quot;, ret);<br />+&nbsp; &nbsp; &nbsp; &nbsp; goto out2;<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; kfree(buf);<br />+<br /> &nbsp; &nbsp; return 0;<br />+<br />+out2:<br />+&nbsp; &nbsp; kfree(buf);<br />+out1:<br />+&nbsp; &nbsp; return ret;<br /> }</p><p>+<br />+#ifdef AX_CUSTOM_HARD_HEADER<br />+/*<br />+ *&nbsp; &nbsp; This is based on the standard version in eth.c, but pull&#039;s ETH_HLEN instead of<br />+ *&nbsp; &nbsp; dev-&gt;hard_header_len.<br />+ *<br />+ *&nbsp; &nbsp; Determine the packet&#039;s protocol ID. The rule here is that we <br />+ *&nbsp; &nbsp; assume 802.3 if the type field is short enough to be a length.<br />+ *&nbsp; &nbsp; This is normal practice and works for any &#039;now in use&#039; protocol.<br />+ */<br />+ <br />+static unsigned short ax_eth_type_trans(struct sk_buff *skb, struct net_device *dev)<br />+{<br />+&nbsp; &nbsp; struct ethhdr *eth;<br />+&nbsp; &nbsp; unsigned char *rawp;<br />+&nbsp; &nbsp; <br />+&nbsp; &nbsp; skb-&gt;mac.raw=skb-&gt;data;<br />+&nbsp; &nbsp; skb_pull(skb,ETH_HLEN);<br />+&nbsp; &nbsp; eth= skb-&gt;mac.ethernet;<br />+&nbsp; &nbsp; <br />+&nbsp; &nbsp; if(*eth-&gt;h_dest&amp;1)<br />+&nbsp; &nbsp; {<br />+&nbsp; &nbsp; &nbsp; &nbsp; if(memcmp(eth-&gt;h_dest,dev-&gt;broadcast, ETH_ALEN)==0)<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skb-&gt;pkt_type=PACKET_BROADCAST;<br />+&nbsp; &nbsp; &nbsp; &nbsp; else<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skb-&gt;pkt_type=PACKET_MULTICAST;<br />+&nbsp; &nbsp; }<br />+&nbsp; &nbsp; <br />+&nbsp; &nbsp; /*<br />+&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; This ALLMULTI check should be redundant by 1.4<br />+&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; so don&#039;t forget to remove it.<br />+&nbsp; &nbsp;&nbsp; *<br />+&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; Seems, you forgot to remove it. All silly devices<br />+&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; seems to set IFF_PROMISC.<br />+&nbsp; &nbsp;&nbsp; */<br />+&nbsp; &nbsp;&nbsp; <br />+&nbsp; &nbsp; else if(1 /*dev-&gt;flags&amp;IFF_PROMISC*/)<br />+&nbsp; &nbsp; {<br />+&nbsp; &nbsp; &nbsp; &nbsp; if(memcmp(eth-&gt;h_dest,dev-&gt;dev_addr, ETH_ALEN))<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skb-&gt;pkt_type=PACKET_OTHERHOST;<br />+&nbsp; &nbsp; }<br />+&nbsp; &nbsp; <br />+&nbsp; &nbsp; if (ntohs(eth-&gt;h_proto) &gt;= 1536)<br />+&nbsp; &nbsp; &nbsp; &nbsp; return eth-&gt;h_proto;<br />+&nbsp; &nbsp; &nbsp; &nbsp; <br />+&nbsp; &nbsp; rawp = skb-&gt;data;<br />+&nbsp; &nbsp; <br />+&nbsp; &nbsp; /*<br />+&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; This is a magic hack to spot IPX packets. Older Novell breaks<br />+&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; the protocol design and runs IPX over 802.3 without an 802.2 LLC<br />+&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; layer. We look for FFFF which isn&#039;t a used 802.2 SSAP/DSAP. This<br />+&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; won&#039;t work for fault tolerant netware but does for the rest.<br />+&nbsp; &nbsp;&nbsp; */<br />+&nbsp; &nbsp; if (*(unsigned short *)rawp == 0xFFFF)<br />+&nbsp; &nbsp; &nbsp; &nbsp; return htons(ETH_P_802_3);<br />+&nbsp; &nbsp; &nbsp; &nbsp; <br />+&nbsp; &nbsp; /*<br />+&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; Real 802.2 LLC<br />+&nbsp; &nbsp;&nbsp; */<br />+&nbsp; &nbsp; return htons(ETH_P_802_2);<br />+}<br />+#endif<br />+<br />+static void skb_return (struct usbnet *dev, struct sk_buff *skb)<br />+{<br />+&nbsp; &nbsp; int&nbsp; &nbsp; status;<br />+<br />+&nbsp; &nbsp; skb-&gt;dev = &amp;dev-&gt;net;<br />+#ifdef AX_CUSTOM_HARD_HEADER<br />+&nbsp; &nbsp; skb-&gt;protocol = ax_eth_type_trans (skb, &amp;dev-&gt;net);<br />+#else<br />+&nbsp; &nbsp; skb-&gt;protocol = eth_type_trans (skb, &amp;dev-&gt;net);<br />+#endif&nbsp; &nbsp; <br />+<br />+&nbsp; &nbsp; dev-&gt;stats.rx_packets++;<br />+&nbsp; &nbsp; dev-&gt;stats.rx_bytes += skb-&gt;len;<br />+<br />+&nbsp; &nbsp; if (msg_level &gt;= 3)<br />+&nbsp; &nbsp; &nbsp; &nbsp; devdbg (dev, &quot;&lt; rx, len %u, type 0x%x&quot;,<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skb-&gt;len + sizeof (struct ethhdr), skb-&gt;protocol);<br />+&nbsp; &nbsp; memset (skb-&gt;cb, 0, sizeof (struct skb_data));<br />+&nbsp; &nbsp; status = netif_rx (skb);<br />+&nbsp; &nbsp; if (status != NET_RX_SUCCESS &amp;&amp; msg_level &gt;= 2)<br />+&nbsp; &nbsp; &nbsp; &nbsp; devdbg (dev, &quot;netif_rx status %d&quot;, status);<br />+}<br />+<br />+static int ax88772_rx_fixup(struct usbnet *dev, struct sk_buff *skb)<br />+{<br />+&nbsp; &nbsp; char *header;<br />+&nbsp; &nbsp; u32&nbsp; &nbsp;head;<br />+&nbsp; &nbsp; char *packet;<br />+&nbsp; &nbsp; struct sk_buff *ax_skb;<br />+&nbsp; &nbsp; u16 size;<br />+&nbsp; &nbsp; unsigned int count = 0;<br />+<br />+&nbsp; &nbsp; header = (char *)skb-&gt;data;<br />+&nbsp; &nbsp; memcpy (&amp;head,header,sizeof(head));<br />+&nbsp; &nbsp; le32_to_cpus(&amp;head); <br />+&nbsp; &nbsp; packet = (char *)(header + 4);<br />+<br />+&nbsp; &nbsp; skb_pull(skb, 4);<br />+&nbsp; &nbsp; while (skb-&gt;len &gt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; if ((short)(head &amp; 0x0000ffff) !=<br />+&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;~((short)((head &amp; 0xffff0000) &gt;&gt; 16))) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; devdbg(dev,&quot;header length data is error: 0x%08x&quot;, head);<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;<br />+&nbsp; &nbsp; &nbsp; &nbsp; }<br />+&nbsp; &nbsp; &nbsp; &nbsp; /* get the packet length */<br />+&nbsp; &nbsp; &nbsp; &nbsp; size = (u16) (head &amp; 0x0000ffff);<br />+&nbsp; &nbsp; &nbsp; &nbsp; count++;<br />+<br />+&nbsp; &nbsp; &nbsp; &nbsp; if ((skb-&gt;len) - ((size + 1) &amp; 0xfffe) == 0) {<br />+#ifdef AX_ALIGN<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (( (u32)packet &amp; 0x2) == 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // This is the pits, but we&#039;ve got to shuffle<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // the packet down in memory if it isn&#039;t<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // properly aligned to avoid &quot;Unaligned<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Access&quot; errors on mips.&nbsp; We&#039;re overwriting<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 2 bytes of our header, which is ok.<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // We&#039;ve aligned things so this won&#039;t happen<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // on the first eth packet, but it might when<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // more than one packet is packed into a<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // single usb bulk transfer.<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; devdbg( dev, &quot;rx_fixup had to shift.&nbsp; size: %d&quot;, size);<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memmove( packet-2, packet, size );<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skb-&gt;data -= 2;<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skb-&gt;tail -= 2;<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />+#endif<br />+<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (count &gt; 1)<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; devdbg( dev, &quot;rx_fixup: count: %d&quot;, count );<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 2;<br />+&nbsp; &nbsp; &nbsp; &nbsp; }<br />+&nbsp; &nbsp; &nbsp; &nbsp; if (size &gt; dev-&gt;net.mtu + 20) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; devdbg(dev,&quot;invalid rx length %d&quot;, size);<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; devdbg( dev, &quot;rx_fixup: count: %d&quot;, count );<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;<br />+&nbsp; &nbsp; &nbsp; &nbsp; }<br />+<br />+#ifdef AX_ALIGN<br />+&nbsp; &nbsp; &nbsp; &nbsp; if (( (u32)packet &amp; 0x2) == 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; devdbg( dev, &quot;alloc_skb&quot; );<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ax_skb = alloc_skb (size+2, GFP_ATOMIC);<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ax_skb) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skb_reserve(ax_skb,2); /* alignment */<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy( skb_put(ax_skb,size), packet, size );<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skb_return(dev, ax_skb);<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; devdbg( dev, &quot;rx_fixup: copy failed.&nbsp; count: %d&quot;, count );<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />+&nbsp; &nbsp; &nbsp; &nbsp; } else <br />+#endif<br />+&nbsp; &nbsp; &nbsp; &nbsp; {<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; devdbg( dev, &quot;skb_clone&quot; );<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ax_skb = skb_clone(skb, GFP_ATOMIC);<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ax_skb) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ax_skb-&gt;len = size;<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ax_skb-&gt;data = packet;<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ax_skb-&gt;tail = packet + size;<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skb_return(dev, ax_skb);<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; devdbg( dev, &quot;rx_fixup: clone failed.&nbsp; count: %d&quot;, count );<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />+&nbsp; &nbsp; &nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; &nbsp; &nbsp; skb_pull(skb, ((size + 1) &amp; 0xfffe));<br />+<br />+&nbsp; &nbsp; &nbsp; &nbsp; if (skb-&gt;len == 0)<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />+<br />+&nbsp; &nbsp; &nbsp; &nbsp; header = (char *) skb-&gt;data;<br />+&nbsp; &nbsp; &nbsp; &nbsp; memcpy (&amp;head,header,sizeof(head));<br />+&nbsp; &nbsp; &nbsp; &nbsp; le32_to_cpus(&amp;head); <br />+&nbsp; &nbsp; &nbsp; &nbsp; packet = (char *)(header + 4);<br />+&nbsp; &nbsp; &nbsp; &nbsp; <br />+&nbsp; &nbsp; &nbsp; &nbsp; skb_pull(skb, 4);<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; if (skb-&gt;len &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; devdbg(dev,&quot;invalid rx length %d&quot;, skb-&gt;len);<br />+&nbsp; &nbsp; &nbsp; &nbsp; if (count &gt; 1)<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; devdbg( dev, &quot;rx_fixup: clone failed.&nbsp; count: %d&quot;, count );<br />+&nbsp; &nbsp; &nbsp; &nbsp; return 0;<br />+&nbsp; &nbsp; }<br />+&nbsp; &nbsp; if (count &gt; 1)<br />+&nbsp; &nbsp; &nbsp; &nbsp; devdbg( dev, &quot;rx_fixup: clone failed.&nbsp; count: %d&quot;, count );<br />+&nbsp; &nbsp; return 1;<br />+}<br />+<br />+static struct sk_buff *ax88772_tx_fixup(struct usbnet *dev, struct sk_buff *skb,<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int flags)<br />+{<br />+&nbsp; &nbsp; int padlen;<br />+&nbsp; &nbsp; int headroom = skb_headroom(skb);<br />+&nbsp; &nbsp; int tailroom = skb_tailroom(skb);<br />+&nbsp; &nbsp; u32 padbytes;<br />+&nbsp; &nbsp; const int headersz = 4;<br />+<br />+&nbsp; &nbsp; padlen = ((skb-&gt;len + headersz) % 512) ? 0 : 4;<br />+&nbsp; &nbsp; if (headersz==0 &amp;&amp; padlen == 0) return skb;<br />+<br />+&nbsp; &nbsp; //&nbsp; &nbsp; devdbg( dev, &quot;headroom: %d&nbsp; tailroom: %d skb-&gt;len: %d cloned?: %d&nbsp; padlen: %d&quot;, <br />+&nbsp; &nbsp; //&nbsp; &nbsp; &nbsp; &nbsp; headroom, tailroom, skb-&gt;len, skb_cloned(skb), padlen );<br />+<br />+&nbsp; &nbsp; //&nbsp; &nbsp; if ((!skb_cloned(skb)) &amp;&amp;<br />+&nbsp; &nbsp; if (<br />+&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;((headroom + tailroom) &gt;= (headersz + padlen))) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; if ((headroom &lt; headersz) || (tailroom &lt; padlen)) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skb-&gt;data = memmove(skb-&gt;head + headersz, skb-&gt;data, skb-&gt;len);<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skb-&gt;tail = skb-&gt;data + skb-&gt;len;<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; devdbg(dev, &quot;tx_fixup: had to shift&quot; );<br />+&nbsp; &nbsp; &nbsp; &nbsp; }<br />+&nbsp; &nbsp; } else {<br />+&nbsp; &nbsp; &nbsp; &nbsp; struct sk_buff *skb2;<br />+&nbsp; &nbsp; &nbsp; &nbsp; skb2 = skb_copy_expand(skb, headersz, padlen, flags);<br />+&nbsp; &nbsp; &nbsp; &nbsp; dev_kfree_skb_any(skb);<br />+&nbsp; &nbsp; &nbsp; &nbsp; devdbg(dev, &quot;tx_fixup: had to copy_expand&quot; );<br />+&nbsp; &nbsp; &nbsp; &nbsp; skb = skb2;<br />+&nbsp; &nbsp; &nbsp; &nbsp; if (!skb)<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return NULL;<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; skb_push(skb,4);&nbsp; &nbsp; /* our header */<br />+&nbsp; &nbsp; {<br />+&nbsp; &nbsp;&nbsp; &nbsp;u32 l = cpu_to_le32((((skb-&gt;len - 4) ^ 0x0000ffff) &lt;&lt; 16) + (skb-&gt;len - 4));<br />+&nbsp; &nbsp;&nbsp; &nbsp;memcpy( skb-&gt;data, &amp;l, sizeof(l) );<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; if (padlen != 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; padbytes = cpu_to_le32(0xffff0000);<br />+&nbsp; &nbsp; &nbsp; &nbsp; memcpy( skb-&gt;tail, &amp;padbytes, padlen );<br />+&nbsp; &nbsp; &nbsp; &nbsp; skb_put(skb, padlen);<br />+&nbsp; &nbsp; }<br />+&nbsp; &nbsp; return skb;<br />+}<br />+<br />+<br /> static const struct driver_info ax8817x_info = {<br /> &nbsp; &nbsp; .description = &quot;ASIX AX8817x USB 2.0 Ethernet&quot;,<br /> &nbsp; &nbsp; .bind = ax8817x_bind,<br />+&nbsp; &nbsp; .reset = ax8817x_link_reset,<br />+&nbsp; &nbsp; .link_reset = ax8817x_link_reset,<br />+&nbsp; &nbsp; .status = ax8817x_status,<br /> &nbsp; &nbsp; .flags =&nbsp; FLAG_ETHER,<br /> &nbsp; &nbsp; .data = 0x00130103,<br /> };<br />@@ -698,6 +1668,9 @@<br /> static const struct driver_info dlink_dub_e100_info = {<br /> &nbsp; &nbsp; .description = &quot;DLink DUB-E100 USB Ethernet&quot;,<br /> &nbsp; &nbsp; .bind = ax8817x_bind,<br />+&nbsp; &nbsp; .reset = ax8817x_link_reset,<br />+&nbsp; &nbsp; .link_reset = ax8817x_link_reset,<br />+&nbsp; &nbsp; .status = ax8817x_status,<br /> &nbsp; &nbsp; .flags =&nbsp; FLAG_ETHER,<br /> &nbsp; &nbsp; .data = 0x009f9d9f,<br /> };<br />@@ -705,6 +1678,9 @@<br /> static const struct driver_info netgear_fa120_info = {<br /> &nbsp; &nbsp; .description = &quot;Netgear FA-120 USB Ethernet&quot;,<br /> &nbsp; &nbsp; .bind = ax8817x_bind,<br />+&nbsp; &nbsp; .reset = ax8817x_link_reset,<br />+&nbsp; &nbsp; .link_reset = ax8817x_link_reset,<br />+&nbsp; &nbsp; .status = ax8817x_status,<br /> &nbsp; &nbsp; .flags =&nbsp; FLAG_ETHER,<br /> &nbsp; &nbsp; .data = 0x00130103,<br /> };<br />@@ -712,9 +1688,73 @@<br /> static const struct driver_info hawking_uf200_info = {<br /> &nbsp; &nbsp; .description = &quot;Hawking UF200 USB Ethernet&quot;,<br /> &nbsp; &nbsp; .bind = ax8817x_bind,<br />+&nbsp; &nbsp; .reset = ax8817x_link_reset,<br />+&nbsp; &nbsp; .link_reset = ax8817x_link_reset,<br />+&nbsp; &nbsp; .status = ax8817x_status,<br /> &nbsp; &nbsp; .flags =&nbsp; FLAG_ETHER,<br /> &nbsp; &nbsp; .data = 0x001f1d1f,<br /> };<br />+<br />+static const struct driver_info ax88772_info = {<br />+&nbsp; &nbsp; .description = &quot;ASIX AX88772 USB 2.0 Ethernet&quot;,<br />+&nbsp; &nbsp; .bind = ax88772_bind,<br />+&nbsp; &nbsp; .reset = ax88772_link_reset,<br />+&nbsp; &nbsp; .link_reset = ax88772_link_reset,<br />+&nbsp; &nbsp; .status = ax8817x_status,<br />+&nbsp; &nbsp; .flags = FLAG_ETHER | FLAG_FRAMING_AX,<br />+&nbsp; &nbsp; .rx_fixup = ax88772_rx_fixup,<br />+&nbsp; &nbsp; .tx_fixup = ax88772_tx_fixup,<br />+&nbsp; &nbsp; .data = 0x0001,<br />+};<br />+<br />+static const struct driver_info linksys_usb200m_v2_info = {<br />+&nbsp; &nbsp; .description = &quot;Linksys usb200m v2 AX88772 USB 2.0 Ethernet&quot;,<br />+&nbsp; &nbsp; .bind = ax88772_bind,<br />+&nbsp; &nbsp; .reset = ax88772_link_reset,<br />+&nbsp; &nbsp; .link_reset = ax88772_link_reset,<br />+&nbsp; &nbsp; .status = ax8817x_status,<br />+&nbsp; &nbsp; .flags = FLAG_ETHER | FLAG_FRAMING_AX,<br />+&nbsp; &nbsp; .rx_fixup = ax88772_rx_fixup,<br />+&nbsp; &nbsp; .tx_fixup = ax88772_tx_fixup,<br />+&nbsp; &nbsp; .data = 0x0001,<br />+};<br />+<br />+static const struct driver_info dlink_dub_e100_B1_info = {<br />+&nbsp; &nbsp; .description = &quot;DLink DUB-E100 rev B1 USB Ethernet&quot;,<br />+&nbsp; &nbsp; .bind = ax88772_bind,<br />+&nbsp; &nbsp; .reset = ax88772_link_reset,<br />+&nbsp; &nbsp; .link_reset = ax88772_link_reset,<br />+&nbsp; &nbsp; .status = ax8817x_status,<br />+&nbsp; &nbsp; .flags = FLAG_ETHER | FLAG_FRAMING_AX,<br />+&nbsp; &nbsp; .rx_fixup = ax88772_rx_fixup,<br />+&nbsp; &nbsp; .tx_fixup = ax88772_tx_fixup,<br />+&nbsp; &nbsp; .data = 0x0000,<br />+};<br />+<br />+static const struct driver_info ax88178_info = {<br />+&nbsp; &nbsp; .description = &quot;ASIX AX88178 USB 2.0 GIGE Ethernet&quot;,<br />+&nbsp; &nbsp; .bind = ax88178_bind,<br />+&nbsp; &nbsp; .reset = ax88178_link_reset,<br />+&nbsp; &nbsp; .link_reset = ax88178_link_reset,<br />+&nbsp; &nbsp; .status = ax8817x_status,<br />+&nbsp; &nbsp; .flags = FLAG_ETHER | FLAG_FRAMING_JUMBO_AX,<br />+&nbsp; &nbsp; .rx_fixup = ax88772_rx_fixup,<br />+&nbsp; &nbsp; .tx_fixup = ax88772_tx_fixup,<br />+&nbsp; &nbsp; .data = 0x00Bf9dBf,<br />+};<br />+<br />+static const struct driver_info usb1000_info = {<br />+&nbsp; &nbsp; .description = &quot;Linksys usb1000 AX88178 USB 2.0 GIGE Ethernet&quot;,<br />+&nbsp; &nbsp; .bind = ax88178_bind,<br />+&nbsp; &nbsp; .reset = ax88178_link_reset,<br />+&nbsp; &nbsp; .link_reset = ax88178_link_reset,<br />+&nbsp; &nbsp; .status = ax8817x_status,<br />+&nbsp; &nbsp; .flags = FLAG_ETHER | FLAG_FRAMING_JUMBO_AX,<br />+&nbsp; &nbsp; .rx_fixup = ax88772_rx_fixup,<br />+&nbsp; &nbsp; .tx_fixup = ax88772_tx_fixup,<br />+&nbsp; &nbsp; .data = 0x00Bf9dBf,<br />+};<br />+<br /> #endif /* CONFIG_USB_AX8817X */</p> <br /><p>@@ -1595,8 +2635,12 @@</p><p> static int pl_reset (struct usbnet *dev)<br /> {<br />-&nbsp; &nbsp; return pl_set_QuickLink_features (dev,<br />+&nbsp; &nbsp; /* some units seem to need this reset, others reject it utterly.<br />+&nbsp; &nbsp;&nbsp; * FIXME be more like &quot;naplink&quot; or windows drivers.<br />+&nbsp; &nbsp;&nbsp; */<br />+&nbsp; &nbsp; (void) pl_set_QuickLink_features (dev,<br /> &nbsp; &nbsp; &nbsp; &nbsp; PL_S_EN|PL_RESET_OUT|PL_RESET_IN|PL_PEER_E);<br />+&nbsp; &nbsp; return 0;<br /> }</p><p> static const struct driver_info&nbsp; &nbsp; prolific_info = {<br />@@ -1647,7 +2691,6 @@</p><p> #ifdef CONFIG_USB_ZAURUS</p><p>-#include &lt;linux/crc32.h&gt;</p><p> /*-------------------------------------------------------------------------<br />&nbsp; *<br />@@ -1717,6 +2760,50 @@</p><p> /*-------------------------------------------------------------------------<br />&nbsp; *<br />+ * Set queue lengths based on MTU and USB speed.&nbsp; Assumes dev mutex is held.<br />+ *<br />+ *-------------------------------------------------------------------------*/<br />+<br />+static void usbnet_set_qlen(struct usbnet *dev) {<br />+&nbsp; &nbsp; size_t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size;<br />+<br />+#ifdef CONFIG_USB_NET1080<br />+&nbsp; &nbsp; if (dev-&gt;driver_info-&gt;flags &amp; FLAG_FRAMING_NC)<br />+&nbsp; &nbsp; &nbsp; &nbsp; size = FRAMED_SIZE (dev-&gt;net.mtu);<br />+&nbsp; &nbsp; else<br />+#endif<br />+#ifdef CONFIG_USB_GENESYS<br />+&nbsp; &nbsp; if (dev-&gt;driver_info-&gt;flags &amp; FLAG_FRAMING_GL)<br />+&nbsp; &nbsp; &nbsp; &nbsp; size = GL_RCV_BUF_SIZE;<br />+&nbsp; &nbsp; else<br />+#endif<br />+#ifdef CONFIG_USB_ZAURUS<br />+&nbsp; &nbsp; if (dev-&gt;driver_info-&gt;flags &amp; FLAG_FRAMING_Z)<br />+&nbsp; &nbsp; &nbsp; &nbsp; size = 6 + (sizeof (struct ethhdr) + dev-&gt;net.mtu);<br />+&nbsp; &nbsp; else<br />+#endif<br />+#ifdef CONFIG_USB_AX8817X<br />+&nbsp; &nbsp; if (dev-&gt;driver_info-&gt;flags &amp; FLAG_FRAMING_AX)<br />+&nbsp; &nbsp; &nbsp; &nbsp; size = 2048;<br />+&nbsp; &nbsp; else if (dev-&gt;driver_info-&gt;flags &amp; FLAG_FRAMING_JUMBO_AX)<br />+&nbsp; &nbsp; &nbsp; &nbsp; if (dev-&gt;net.mtu &gt; 1500)<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size = 16386;<br />+&nbsp; &nbsp; &nbsp; &nbsp; else<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size = 2050;<br />+&nbsp; &nbsp; else<br />+#endif<br />+&nbsp; &nbsp; &nbsp; &nbsp; size = 2 + (sizeof (struct ethhdr) + dev-&gt;net.mtu);<br />+<br />+&nbsp; &nbsp; unsigned short rxqlen = (dev-&gt;udev-&gt;speed == USB_SPEED_HIGH) ? (max_rxq_mem/size) : 4;<br />+&nbsp; &nbsp; unsigned short txqlen = (dev-&gt;udev-&gt;speed == USB_SPEED_HIGH) ? (max_txq_mem/size) : 4;<br />+&nbsp; &nbsp; rxqlen = (rxqlen==0) ? 1 : rxqlen;<br />+&nbsp; &nbsp; txqlen = (txqlen==0) ? 1 : txqlen;<br />+&nbsp; &nbsp; dev-&gt;rx_qlen = rxqlen;<br />+&nbsp; &nbsp; dev-&gt;tx_qlen = txqlen;<br />+}<br />+<br />+/*-------------------------------------------------------------------------<br />+ *<br />&nbsp; * Network Device Driver (peer link to &quot;Host Device&quot;, from USB host)<br />&nbsp; *<br />&nbsp; *-------------------------------------------------------------------------*/<br />@@ -1724,6 +2811,8 @@<br /> static int usbnet_change_mtu (struct net_device *net, int new_mtu)<br /> {<br /> &nbsp; &nbsp; struct usbnet&nbsp; &nbsp; *dev = (struct usbnet *) net-&gt;priv;<br />+&nbsp; &nbsp; u16 *buf;<br />+&nbsp; &nbsp; u16&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mode, rx_ctl;</p><p> &nbsp; &nbsp; if (new_mtu &lt;= MIN_PACKET || new_mtu &gt; MAX_PACKET)<br /> &nbsp; &nbsp; &nbsp; &nbsp; return -EINVAL;<br />@@ -1738,10 +2827,46 @@<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; new_mtu &gt; GL_MAX_PACKET_LEN)<br /> &nbsp; &nbsp; &nbsp; &nbsp; return -EINVAL;<br /> #endif<br />+<br />+#ifdef&nbsp; CONFIG_USB_AX8817X<br />+&nbsp; &nbsp; buf = kmalloc(sizeof(*buf), GFP_KERNEL);<br />+&nbsp; &nbsp; if(!buf) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; return -ENOMEM;<br />+&nbsp; &nbsp; }<br />+&nbsp; &nbsp; ax8817x_read_cmd(dev, AX_CMD_READ_MEDIUM_STATUS, 0, 0, 2, buf);<br />+&nbsp; &nbsp; mode = *buf;<br />+&nbsp; &nbsp; if (new_mtu &gt; 1500)<br />+&nbsp; &nbsp; &nbsp; &nbsp; mode |= AX88178_MEDIUM_JUMBO;<br />+&nbsp; &nbsp; else<br />+&nbsp; &nbsp; &nbsp; &nbsp; mode &amp;= ~AX88178_MEDIUM_JUMBO;<br />+&nbsp; &nbsp; if (mode != *buf) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE, mode, 0, 0, NULL);<br />+&nbsp; &nbsp; &nbsp; &nbsp; devdbg( dev, &quot;new MEDIUM_MODE: 0x%04x&quot;, mode );<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; if ( ax8817x_read_cmd(dev, AX_CMD_READ_RX_CTL, 0, 0, 2, buf) == 2) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; rx_ctl = le16_to_cpu(*buf);<br />+<br />+&nbsp; &nbsp; &nbsp; &nbsp; if (dev-&gt;driver_info-&gt;flags &amp; FLAG_FRAMING_JUMBO_AX &amp;&amp;<br />+&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;new_mtu &gt; 1500 )<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rx_ctl |= AX_RX_CTL_MFB; /* largest framing */<br />+&nbsp; &nbsp; &nbsp; &nbsp; else<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rx_ctl &amp;= ~AX_RX_CTL_MFB; /* smallest framing */<br />+&nbsp; &nbsp; &nbsp; &nbsp; devdbg( dev, &quot;usb_change_mtu: writing rx_ctl: 0x%08x&quot;, rx_ctl );<br />+&nbsp; &nbsp; &nbsp; &nbsp; ax8817x_write_cmd_async(dev, AX_CMD_WRITE_RX_CTL, rx_ctl, 0, 0, NULL);<br />+&nbsp; &nbsp; }<br />+&nbsp; &nbsp; <br />+&nbsp; &nbsp; kfree(buf);<br />+<br />+#endif<br />+<br /> &nbsp; &nbsp; // no second zero-length packet read wanted after mtu-sized packets<br /> &nbsp; &nbsp; if (((new_mtu + sizeof (struct ethhdr)) % dev-&gt;maxpacket) == 0)<br /> &nbsp; &nbsp; &nbsp; &nbsp; return -EDOM;<br /> &nbsp; &nbsp; net-&gt;mtu = new_mtu;<br />+&nbsp; &nbsp; mutex_lock (&amp;dev-&gt;mutex);<br />+&nbsp; &nbsp; usbnet_set_qlen(dev);<br />+&nbsp; &nbsp; mutex_unlock (&amp;dev-&gt;mutex);<br /> &nbsp; &nbsp; return 0;<br /> }</p><p>@@ -1771,21 +2896,6 @@<br /> &nbsp; &nbsp; spin_unlock_irqrestore (&amp;dev-&gt;done.lock, flags);<br /> }</p><p>-/* some work can&#039;t be done in tasklets, so we use keventd<br />- *<br />- * NOTE:&nbsp; annoying asymmetry:&nbsp; if it&#039;s active, schedule_task() fails,<br />- * but tasklet_schedule() doesn&#039;t.&nbsp; hope the failure is rare.<br />- */<br />-static void defer_kevent (struct usbnet *dev, int work)<br />-{<br />-&nbsp; &nbsp; set_bit (work, &amp;dev-&gt;flags);<br />-&nbsp; &nbsp; if (!schedule_task (&amp;dev-&gt;kevent))<br />-&nbsp; &nbsp; &nbsp; &nbsp; err (&quot;%s: kevent %d may have been dropped&quot;,<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dev-&gt;net.name, work);<br />-&nbsp; &nbsp; else<br />-&nbsp; &nbsp; &nbsp; &nbsp; dbg (&quot;%s: kevent %d scheduled&quot;, dev-&gt;net.name, work);<br />-}<br />-<br /> /*-------------------------------------------------------------------------*/</p><p> static void rx_complete (struct urb *urb);<br />@@ -1813,7 +2923,17 @@<br /> &nbsp; &nbsp; &nbsp; &nbsp; size = 6 + (sizeof (struct ethhdr) + dev-&gt;net.mtu);<br /> &nbsp; &nbsp; else<br /> #endif<br />-&nbsp; &nbsp; &nbsp; &nbsp; size = (sizeof (struct ethhdr) + dev-&gt;net.mtu);<br />+#ifdef CONFIG_USB_AX8817X<br />+&nbsp; &nbsp; if (dev-&gt;driver_info-&gt;flags &amp; FLAG_FRAMING_AX)<br />+&nbsp; &nbsp; &nbsp; &nbsp; size = 2048;<br />+&nbsp; &nbsp; else if (dev-&gt;driver_info-&gt;flags &amp; FLAG_FRAMING_JUMBO_AX) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; if (dev-&gt;net.mtu &gt; 1500)<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size = 16386;<br />+&nbsp; &nbsp; &nbsp; &nbsp; else<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size = 2050;<br />+&nbsp; &nbsp; } else<br />+#endif<br />+&nbsp; &nbsp; &nbsp; &nbsp; size = 2 + (sizeof (struct ethhdr) + dev-&gt;net.mtu);</p><p> &nbsp; &nbsp; if ((skb = alloc_skb (size, flags)) == 0) {<br /> &nbsp; &nbsp; &nbsp; &nbsp; dbg (&quot;no rx skb&quot;);<br />@@ -1821,6 +2941,7 @@<br /> &nbsp; &nbsp; &nbsp; &nbsp; usb_free_urb (urb);<br /> &nbsp; &nbsp; &nbsp; &nbsp; return;<br /> &nbsp; &nbsp; }<br />+&nbsp; &nbsp; &nbsp; &nbsp; skb_reserve( skb, 2 );&nbsp; // for IP header alignment</p><p> &nbsp; &nbsp; entry = (struct skb_data *) skb-&gt;cb;<br /> &nbsp; &nbsp; entry-&gt;urb = urb;<br />@@ -1841,6 +2962,7 @@<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defer_kevent (dev, EVENT_RX_HALT);<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br /> &nbsp; &nbsp; &nbsp; &nbsp; case -ENOMEM:<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dbg( &quot;SUBMIT_URB:&nbsp; ENOMEM&quot; );<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defer_kevent (dev, EVENT_RX_MEMORY);<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br /> &nbsp; &nbsp; &nbsp; &nbsp; default:<br />@@ -1868,25 +2990,14 @@<br /> {<br /> &nbsp; &nbsp; if (dev-&gt;driver_info-&gt;rx_fixup<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; !dev-&gt;driver_info-&gt;rx_fixup (dev, skb))<br />+&nbsp; &nbsp; {<br />+&nbsp; &nbsp; &nbsp; &nbsp; dbg (&quot;rx_fixup error&quot;);<br /> &nbsp; &nbsp; &nbsp; &nbsp; goto error;<br />+&nbsp; &nbsp; }<br /> &nbsp; &nbsp; // else network stack removes extra byte if we forced a short packet</p><p> &nbsp; &nbsp; if (skb-&gt;len) {<br />-&nbsp; &nbsp; &nbsp; &nbsp; int&nbsp; &nbsp; status;<br />-<br />-&nbsp; &nbsp; &nbsp; &nbsp; skb-&gt;dev = &amp;dev-&gt;net;<br />-&nbsp; &nbsp; &nbsp; &nbsp; skb-&gt;protocol = eth_type_trans (skb, &amp;dev-&gt;net);<br />-&nbsp; &nbsp; &nbsp; &nbsp; dev-&gt;stats.rx_packets++;<br />-&nbsp; &nbsp; &nbsp; &nbsp; dev-&gt;stats.rx_bytes += skb-&gt;len;<br />-<br />-#ifdef&nbsp; &nbsp; VERBOSE<br />-&nbsp; &nbsp; &nbsp; &nbsp; devdbg (dev, &quot;&lt; rx, len %d, type 0x%x&quot;,<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skb-&gt;len + sizeof (struct ethhdr), skb-&gt;protocol);<br />-#endif<br />-&nbsp; &nbsp; &nbsp; &nbsp; memset (skb-&gt;cb, 0, sizeof (struct skb_data));<br />-&nbsp; &nbsp; &nbsp; &nbsp; status = netif_rx (skb);<br />-&nbsp; &nbsp; &nbsp; &nbsp; if (status != NET_RX_SUCCESS)<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; devdbg (dev, &quot;netif_rx status %d&quot;, status);<br />+&nbsp; &nbsp; &nbsp; &nbsp; skb_return( dev, skb );<br /> &nbsp; &nbsp; } else {<br /> &nbsp; &nbsp; &nbsp; &nbsp; dbg (&quot;drop&quot;);<br /> error:<br />@@ -1908,6 +3019,9 @@<br /> &nbsp; &nbsp; entry-&gt;state = rx_done;<br /> &nbsp; &nbsp; entry-&gt;urb = 0;</p><p>+<br />+&nbsp; &nbsp; if (msg_level &gt;= 3)<br />+&nbsp; &nbsp; &nbsp; &nbsp; devdbg( dev, &quot;rx_complete skb: %p&nbsp; status: %d&nbsp; len: %d alen: %d&quot;, skb, urb_status, urb-&gt;transfer_buffer_length, urb-&gt;actual_length );<br /> &nbsp; &nbsp; switch (urb_status) {<br /> &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;// success<br /> &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;case 0:<br />@@ -2008,6 +3122,9 @@<br /> {<br /> &nbsp; &nbsp; struct usbnet&nbsp; &nbsp; &nbsp; &nbsp; *dev = (struct usbnet *) net-&gt;priv;<br /> &nbsp; &nbsp; int&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp;<br />+<br />+&nbsp; &nbsp; devdbg (dev, &quot;in usbnet_stop&quot; );<br />+<br /> &nbsp; &nbsp; DECLARE_WAIT_QUEUE_HEAD (unlink_wakeup); <br /> &nbsp; &nbsp; DECLARE_WAITQUEUE (wait, current);</p><p>@@ -2036,7 +3153,22 @@<br /> &nbsp; &nbsp; dev-&gt;wait = 0;<br /> &nbsp; &nbsp; remove_wait_queue (&amp;unlink_wakeup, &amp;wait); </p><p>+&nbsp; &nbsp; if (dev-&gt;interrupt) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; printk (&quot;unlinking :%p\n&quot;, dev-&gt;interrupt);<br />+&nbsp; &nbsp; &nbsp; &nbsp; usb_unlink_urb(dev-&gt;interrupt);<br />+#ifdef DEBUG<br />+&nbsp; &nbsp; &nbsp; &nbsp; usb_dump_urb(dev-&gt;interrupt);<br />+#endif<br />+&nbsp; &nbsp; }<br />+<br />+&nbsp; &nbsp; /* deferred work (task, timer, softirq) must also stop.<br />+&nbsp; &nbsp;&nbsp; * can&#039;t flush_scheduled_work() until we drop rtnl (later),<br />+&nbsp; &nbsp;&nbsp; * else workers could deadlock; so make workers a NOP.<br />+&nbsp; &nbsp;&nbsp; */<br />+&nbsp; &nbsp; dev-&gt;flags = 0;<br />+<br /> &nbsp; &nbsp; mutex_unlock (&amp;dev-&gt;mutex);<br />+&nbsp; &nbsp; devdbg (dev, &quot;leaving usbnet_stop&quot; );<br /> &nbsp; &nbsp; return 0;<br /> }</p><p>@@ -2051,8 +3183,12 @@<br /> &nbsp; &nbsp; struct usbnet&nbsp; &nbsp; &nbsp; &nbsp; *dev = (struct usbnet *) net-&gt;priv;<br /> &nbsp; &nbsp; int&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = 0;<br /> &nbsp; &nbsp; struct driver_info&nbsp; &nbsp; *info = dev-&gt;driver_info;<br />+&nbsp; &nbsp; char *framing;<br />+<br />+&nbsp; &nbsp; devdbg (dev, &quot;in usbnet_open&quot; );</p><p> &nbsp; &nbsp; mutex_lock (&amp;dev-&gt;mutex);<br />+&nbsp; &nbsp; usbnet_set_qlen(dev);</p><p> &nbsp; &nbsp; // put into &quot;known safe&quot; state<br /> &nbsp; &nbsp; if (info-&gt;reset &amp;&amp; (retval = info-&gt;reset (dev)) &lt; 0) {<br />@@ -2069,27 +3205,51 @@<br /> &nbsp; &nbsp; &nbsp; &nbsp; goto done;<br /> &nbsp; &nbsp; }</p><p>+&nbsp; &nbsp; /* start any status interrupt transfer */<br />+&nbsp; &nbsp; if (dev-&gt;interrupt) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; retval = submit_intr_urb(dev);<br />+&nbsp; &nbsp; &nbsp; &nbsp; if (retval &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deverr (dev, &quot;intr submit %d&quot;, retval);<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto done;<br />+&nbsp; &nbsp; &nbsp; &nbsp; }<br />+&nbsp; &nbsp; }<br />+<br /> &nbsp; &nbsp; netif_start_queue (net);<br />+<br />+&nbsp; &nbsp; if (dev-&gt;driver_info-&gt;flags &amp; FLAG_FRAMING_NC)<br />+&nbsp; &nbsp; &nbsp; &nbsp; framing = &quot;NetChip&quot;;<br />+&nbsp; &nbsp; else if (dev-&gt;driver_info-&gt;flags &amp; FLAG_FRAMING_GL)<br />+&nbsp; &nbsp; &nbsp; &nbsp; framing = &quot;GeneSys&quot;;<br />+&nbsp; &nbsp; else if (dev-&gt;driver_info-&gt;flags &amp; FLAG_FRAMING_Z)<br />+&nbsp; &nbsp; &nbsp; &nbsp; framing = &quot;Zaurus&quot;;<br />+//&nbsp; &nbsp; else if (dev-&gt;driver_info-&gt;flags &amp; FLAG_FRAMING_RN)<br />+//&nbsp; &nbsp; &nbsp; &nbsp; framing = &quot;RNDIS&quot;;<br />+&nbsp; &nbsp; else if (dev-&gt;driver_info-&gt;flags &amp; FLAG_FRAMING_AX)<br />+&nbsp; &nbsp; &nbsp; &nbsp; framing = &quot;ASIX&quot;;<br />+&nbsp; &nbsp; else if (dev-&gt;driver_info-&gt;flags &amp; FLAG_FRAMING_JUMBO_AX) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; if (dev-&gt;net.mtu &gt; 1500)<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; framing = &quot;ASIX Jumbo&quot;;<br />+&nbsp; &nbsp; &nbsp; &nbsp; else<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; framing = &quot;ASIX&quot;;<br />+&nbsp; &nbsp; } else<br />+&nbsp; &nbsp; &nbsp; &nbsp; framing = &quot;simple&quot;;<br />+<br /> &nbsp; &nbsp; if (dev-&gt;msg_level &gt;= 2)<br /> &nbsp; &nbsp; &nbsp; &nbsp; devinfo (dev, &quot;open: enable queueing &quot;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;(rx %d, tx %d) mtu %d %s framing&quot;,<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RX_QLEN, TX_QLEN, dev-&gt;net.mtu,<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (info-&gt;flags &amp; (FLAG_FRAMING_NC | FLAG_FRAMING_GL))<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;? ((info-&gt;flags &amp; FLAG_FRAMING_NC)<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? &quot;NetChip&quot;<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : &quot;GeneSys&quot;)<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;: &quot;raw&quot;<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; );<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RX_QLEN(dev), TX_QLEN(dev), dev-&gt;net.mtu,<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; framing );</p><p> &nbsp; &nbsp; // delay posting reads until we&#039;re fully open<br /> &nbsp; &nbsp; tasklet_schedule (&amp;dev-&gt;bh);<br /> done:<br /> &nbsp; &nbsp; mutex_unlock (&amp;dev-&gt;mutex);<br />+&nbsp; &nbsp; devdbg (dev, &quot;leaving usbnet_open&quot; );<br /> &nbsp; &nbsp; return retval;<br /> }</p><p> /*-------------------------------------------------------------------------*/<br />-<br />+#ifdef ETHTOOL<br /> static void usbnet_get_drvinfo (struct net_device *net, struct ethtool_drvinfo *info)<br /> {<br /> &nbsp; &nbsp; struct usbnet *dev = net-&gt;priv;<br />@@ -2126,9 +3286,30 @@</p><p> &nbsp; &nbsp; dev-&gt;msg_level = level;<br /> }<br />+#endif</p><p> static int usbnet_ioctl (struct net_device *net, struct ifreq *rq, int cmd)<br /> {<br />+#if defined(SIOCTIVOGDEVINFO)<br />+&nbsp; &nbsp; &nbsp; &nbsp; switch (cmd) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case SIOCTIVOGDEVINFO: {<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct usbnet *dev = (struct usbnet *)net-&gt;priv;<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct usb_device *udev = dev-&gt;udev;<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct usb_device_descriptor *desc = &amp;udev-&gt;descriptor;<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct tivo_net_dev_info devinfo;<br />+<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; devinfo.isRemovable = 1;<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; devinfo.vendorId&nbsp; &nbsp; =&nbsp; desc-&gt;idVendor;<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; devinfo.productId&nbsp; &nbsp;=&nbsp; desc-&gt;idProduct;<br />+<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (copy_to_user(rq-&gt;ifr_data, &amp;devinfo,sizeof(devinfo))) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -EFAULT;<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />+&nbsp; &nbsp; &nbsp; &nbsp; }<br />+#endif /* CONFIG_TIVO */<br />+<br /> #ifdef NEED_MII<br /> &nbsp; &nbsp; {<br /> &nbsp; &nbsp; struct usbnet *dev = (struct usbnet *)net-&gt;priv;<br />@@ -2194,7 +3375,18 @@<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tasklet_schedule (&amp;dev-&gt;bh);<br /> &nbsp; &nbsp; &nbsp; &nbsp; }<br /> &nbsp; &nbsp; }<br />-<br />+&nbsp; &nbsp; if (test_bit (EVENT_LINK_RESET, &amp;dev-&gt;flags)) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; struct driver_info &nbsp; &nbsp; *info = dev-&gt;driver_info;<br />+&nbsp; &nbsp; &nbsp; &nbsp; int&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = 0;<br />+<br />+&nbsp; &nbsp; &nbsp; &nbsp; clear_bit (EVENT_LINK_RESET, &amp;dev-&gt;flags);<br />+&nbsp; &nbsp; &nbsp; &nbsp; if(info-&gt;link_reset &amp;&amp; (retval = info-&gt;link_reset(dev)) &lt; 0) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; devinfo(dev, &quot;link reset failed (%d) usbnet usb-%s-%s, %s&quot;,<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval,<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dev-&gt;udev-&gt;bus-&gt;bus_name, dev-&gt;udev-&gt;devpath,<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info-&gt;description);<br />+&nbsp; &nbsp; &nbsp; &nbsp; }<br />+&nbsp; &nbsp; }<br /> &nbsp; &nbsp; if (dev-&gt;flags)<br /> &nbsp; &nbsp; &nbsp; &nbsp; dbg (&quot;%s: kevent done, flags = 0x%lx&quot;,<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dev-&gt;net.name, dev-&gt;flags);<br />@@ -2313,7 +3505,7 @@<br /> &nbsp; &nbsp; case 0:<br /> &nbsp; &nbsp; &nbsp; &nbsp; net-&gt;trans_start = jiffies;<br /> &nbsp; &nbsp; &nbsp; &nbsp; __skb_queue_tail (&amp;dev-&gt;txq, skb);<br />-&nbsp; &nbsp; &nbsp; &nbsp; if (dev-&gt;txq.qlen &gt;= TX_QLEN)<br />+&nbsp; &nbsp; &nbsp; &nbsp; if (dev-&gt;txq.qlen &gt;= TX_QLEN(dev))<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; netif_stop_queue (net);<br /> &nbsp; &nbsp; }<br /> &nbsp; &nbsp; spin_unlock_irqrestore (&amp;dev-&gt;txq.lock, flags);<br />@@ -2328,8 +3520,8 @@<br /> &nbsp; &nbsp; &nbsp; &nbsp; usb_free_urb (urb);<br /> #ifdef&nbsp; &nbsp; VERBOSE<br /> &nbsp; &nbsp; } else {<br />-&nbsp; &nbsp; &nbsp; &nbsp; devdbg (dev, &quot;&gt; tx, len %d, type 0x%x&quot;,<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; length, skb-&gt;protocol);<br />+&nbsp; &nbsp;&nbsp; &nbsp;//&nbsp; &nbsp; &nbsp; &nbsp; devdbg (dev, &quot;&gt; tx, len %d, type 0x%x&quot;,<br />+&nbsp; &nbsp;&nbsp; &nbsp;//&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; length, skb-&gt;protocol);<br /> #endif<br /> &nbsp; &nbsp; }<br /> &nbsp; &nbsp; return retval;<br />@@ -2348,6 +3540,9 @@</p><p> &nbsp; &nbsp; while ((skb = skb_dequeue (&amp;dev-&gt;done))) {<br /> &nbsp; &nbsp; &nbsp; &nbsp; entry = (struct skb_data *) skb-&gt;cb;<br />+#ifdef VERBOSE<br />+&nbsp; &nbsp; &nbsp; &nbsp; //&nbsp; &nbsp; &nbsp; &nbsp; devdbg( dev, &quot;usbnet_bh: skb: %p&nbsp; state: %d&nbsp; len: %d&quot;, skb, entry-&gt;state, skb-&gt;len );<br />+#endif<br /> &nbsp; &nbsp; &nbsp; &nbsp; switch (entry-&gt;state) {<br /> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;case rx_done:<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;state = rx_cleanup;<br />@@ -2384,21 +3579,22 @@<br /> &nbsp; &nbsp; } else if (netif_running (&amp;dev-&gt;net)<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; !test_bit (EVENT_RX_HALT, &amp;dev-&gt;flags)) {<br /> &nbsp; &nbsp; &nbsp; &nbsp; int&nbsp; &nbsp; temp = dev-&gt;rxq.qlen;<br />+&nbsp; &nbsp; &nbsp; &nbsp; int&nbsp; &nbsp; qlen = RX_QLEN (dev);</p><p>-&nbsp; &nbsp; &nbsp; &nbsp; if (temp &lt; RX_QLEN) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; if (temp &lt; qlen) {<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct urb&nbsp; &nbsp; *urb;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int&nbsp; &nbsp; &nbsp; &nbsp; i;<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i = 0; i &lt; 3 &amp;&amp; dev-&gt;rxq.qlen &lt; RX_QLEN; i++) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i = 0; i &lt; 10 &amp;&amp; dev-&gt;rxq.qlen &lt; qlen; i++) {<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ((urb = ALLOC_URB (0, GFP_ATOMIC)) != 0)<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rx_submit (dev, urb, GFP_ATOMIC);<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (temp != dev-&gt;rxq.qlen)<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; devdbg (dev, &quot;rxqlen %d --&gt; %d&quot;,<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp, dev-&gt;rxq.qlen);<br />-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (dev-&gt;rxq.qlen &lt; RX_QLEN)<br />+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (dev-&gt;rxq.qlen &lt; RX_QLEN(dev))<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tasklet_schedule (&amp;dev-&gt;bh);<br /> &nbsp; &nbsp; &nbsp; &nbsp; }<br />-&nbsp; &nbsp; &nbsp; &nbsp; if (dev-&gt;txq.qlen &lt; TX_QLEN)<br />+&nbsp; &nbsp; &nbsp; &nbsp; if (dev-&gt;txq.qlen &lt; TX_QLEN(dev))<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; netif_wake_queue (&amp;dev-&gt;net);<br /> &nbsp; &nbsp; }<br /> }<br />@@ -2446,11 +3642,13 @@<br /> {<br /> &nbsp; &nbsp; struct usbnet&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *dev;<br /> &nbsp; &nbsp; struct net_device &nbsp; &nbsp; &nbsp; &nbsp; *net;<br />-&nbsp; &nbsp; struct driver_info&nbsp; &nbsp; &nbsp; &nbsp; *info;<br />+&nbsp; &nbsp; struct driver_info&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*info;<br /> &nbsp; &nbsp; int&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; altnum = 0;<br />-&nbsp; &nbsp; int&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status;<br />+&nbsp; &nbsp; int&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = 0;<br />+&nbsp; &nbsp; struct usb_interface&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *intf;</p><p> &nbsp; &nbsp; info = (struct driver_info *) prod-&gt;driver_info;<br />+&nbsp; &nbsp; intf = usb_ifnum_to_if( udev, ifnum );</p><p> #ifdef CONFIG_USB_ZAURUS<br /> &nbsp; &nbsp; if (info == &amp;zaurus_sl5x00_info) {<br />@@ -2495,12 +3693,13 @@<br /> &nbsp; &nbsp; dev-&gt;bh.func = usbnet_bh;<br /> &nbsp; &nbsp; dev-&gt;bh.data = (unsigned long) dev;<br /> &nbsp; &nbsp; INIT_TQUEUE (&amp;dev-&gt;kevent, kevent, dev);<br />-<br />+&nbsp; &nbsp; <br /> &nbsp; &nbsp; // set up network interface records<br /> &nbsp; &nbsp; net = &amp;dev-&gt;net;<br /> &nbsp; &nbsp; SET_MODULE_OWNER (net);<br /> &nbsp; &nbsp; net-&gt;priv = dev;<br />-&nbsp; &nbsp; strcpy (net-&gt;name, &quot;usb%d&quot;);<br />+&nbsp; &nbsp; /* strcpy (net-&gt;name, &quot;usb%d&quot;); */<br />+&nbsp; &nbsp; strcpy (net-&gt;name, &quot;eth%d&quot;);<br /> &nbsp; &nbsp; memcpy (net-&gt;dev_addr, node_id, sizeof node_id);</p><p> &nbsp; &nbsp; // point-to-point link ... we always use Ethernet headers <br />@@ -2515,18 +3714,28 @@<br /> &nbsp; &nbsp; net-&gt;watchdog_timeo = TX_TIMEOUT_JIFFIES;<br /> &nbsp; &nbsp; net-&gt;tx_timeout = usbnet_tx_timeout;<br /> &nbsp; &nbsp; net-&gt;do_ioctl = usbnet_ioctl;<br />+#ifdef ETHTOOL<br /> &nbsp; &nbsp; net-&gt;ethtool_ops = &amp;usbnet_ethtool_ops;<br />+#endif</p><p>+#ifdef AX_CUSTOM_HARD_HEADER<br />+&nbsp; &nbsp; // Reserve extra space for the AX framing<br />+&nbsp; &nbsp; if ( info-&gt;flags &amp; (FLAG_FRAMING_AX|FLAG_FRAMING_JUMBO_AX)) {<br />+&nbsp; &nbsp; &nbsp; &nbsp; net-&gt;hard_header_len += 4;<br />+&nbsp; &nbsp; }<br />+#endif<br /> &nbsp; &nbsp; // allow device-specific bind/init procedures<br /> &nbsp; &nbsp; // NOTE net-&gt;name still not usable ...<br /> &nbsp; &nbsp; if (info-&gt;bind) {<br />-&nbsp; &nbsp; &nbsp; &nbsp; status = info-&gt;bind (dev, udev);<br />+&nbsp; &nbsp; &nbsp; &nbsp; status = info-&gt;bind (dev, intf);<br />+#if 0<br /> &nbsp; &nbsp; &nbsp; &nbsp; // heuristic:&nbsp; &quot;usb%d&quot; for links we know are two-host,<br /> &nbsp; &nbsp; &nbsp; &nbsp; // else &quot;eth%d&quot; when there&#039;s reasonable doubt.&nbsp; userspace<br /> &nbsp; &nbsp; &nbsp; &nbsp; // can rename the link if it knows better.<br /> &nbsp; &nbsp; &nbsp; &nbsp; if ((dev-&gt;driver_info-&gt;flags &amp; FLAG_ETHER) != 0<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (net-&gt;dev_addr [0] &amp; 0x02) == 0)<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcpy (net-&gt;name, &quot;eth%d&quot;);<br />+#endif /* 0 */<br /> &nbsp; &nbsp; } else if (!info-&gt;in || info-&gt;out)<br /> &nbsp; &nbsp; &nbsp; &nbsp; status = get_endpoints (dev, udev-&gt;actconfig-&gt;interface + ifnum);<br /> &nbsp; &nbsp; else {<br />@@ -2534,6 +3743,9 @@<br /> &nbsp; &nbsp; &nbsp; &nbsp; dev-&gt;out = usb_sndbulkpipe (udev, info-&gt;out);<br /> &nbsp; &nbsp; }</p><p>+&nbsp; &nbsp; if (status == 0 &amp;&amp; dev-&gt;status)<br />+&nbsp; &nbsp; &nbsp; &nbsp; status = init_status (dev);<br />+<br /> &nbsp; &nbsp; dev-&gt;maxpacket = usb_maxpacket (dev-&gt;udev, dev-&gt;out, 1);</p><p> &nbsp; &nbsp; register_netdev (&amp;dev-&gt;net);<br />@@ -2560,9 +3772,15 @@<br />&nbsp; * chip vendor names won&#039;t normally be on the cables, and<br />&nbsp; * may not be on the device.<br />&nbsp; */<br />-<br /> static const struct usb_device_id&nbsp; &nbsp; products [] = {</p><p>+#ifdef&nbsp; &nbsp; CONFIG_USB_ALI_M5632<br />+{<br />+&nbsp; &nbsp; USB_DEVICE (0x0402, 0x5632),&nbsp; &nbsp; // ALi defaults<br />+&nbsp; &nbsp; .driver_info =&nbsp; &nbsp; (unsigned long) &amp;ali_m5632_info,<br />+},<br />+#endif<br />+<br /> #ifdef&nbsp; &nbsp; CONFIG_USB_AN2720<br /> {<br /> &nbsp; &nbsp; USB_DEVICE (0x0547, 0x2720),&nbsp; &nbsp; // AnchorChips defaults<br />@@ -2583,10 +3801,18 @@<br /> &nbsp; &nbsp; USB_DEVICE (0x0846, 0x1040),<br /> &nbsp; &nbsp; .driver_info =&nbsp; &nbsp; (unsigned long) &amp;netgear_fa120_info,<br /> }, {<br />-&nbsp; &nbsp; // DLink DUB-E100<br />+&nbsp; &nbsp; // DLink DUB-E100, revision A<br /> &nbsp; &nbsp; USB_DEVICE (0x2001, 0x1a00),<br /> &nbsp; &nbsp; .driver_info =&nbsp; &nbsp; (unsigned long) &amp;dlink_dub_e100_info,<br /> }, {<br />+&nbsp; &nbsp; // DLink DUB-E100, revision B1<br />+&nbsp; &nbsp; USB_DEVICE (0x2001, 0x3c05),<br />+&nbsp; &nbsp; .driver_info =&nbsp; &nbsp; (unsigned long) &amp;dlink_dub_e100_B1_info,<br />+}, {<br />+&nbsp; &nbsp; // DLink DUB-E100, revision B1, alternate<br />+&nbsp; &nbsp; USB_DEVICE (0x07d1, 0x3c05),<br />+&nbsp; &nbsp; .driver_info =&nbsp; &nbsp; (unsigned long) &amp;dlink_dub_e100_B1_info,<br />+}, {<br /> &nbsp; &nbsp; // Intellinet, ST Lab USB Ethernet<br /> &nbsp; &nbsp; USB_DEVICE (0x0b95, 0x1720),<br /> &nbsp; &nbsp; .driver_info =&nbsp; &nbsp; (unsigned long) &amp;ax8817x_info,<br />@@ -2594,10 +3820,50 @@<br /> &nbsp; &nbsp; // Hawking UF200, TrendNet TU2-ET100<br /> &nbsp; &nbsp; USB_DEVICE (0x07b8, 0x420a),<br /> &nbsp; &nbsp; .driver_info =&nbsp; &nbsp; (unsigned long) &amp;hawking_uf200_info,<br />-}, {<br />+},&nbsp; {<br />+&nbsp; &nbsp; &nbsp; &nbsp; // Billionton Systems, USB2AR <br />+&nbsp; &nbsp; &nbsp; &nbsp; USB_DEVICE (0x08dd, 0x90ff),<br />+&nbsp; &nbsp; &nbsp; &nbsp; .driver_info =&nbsp; (unsigned long) &amp;ax8817x_info,<br />+},&nbsp; {<br /> &nbsp; &nbsp; // ATEN UC210T<br /> &nbsp; &nbsp; USB_DEVICE (0x0557, 0x2009),<br /> &nbsp; &nbsp; .driver_info =&nbsp; (unsigned long) &amp;ax8817x_info,<br />+},&nbsp; &nbsp;{<br />+&nbsp; &nbsp; // Buffalo LUA-U2-KTX<br />+&nbsp; &nbsp; USB_DEVICE (0x0411, 0x003d),<br />+&nbsp; &nbsp; .driver_info =&nbsp; (unsigned long) &amp;ax8817x_info,<br />+}, {<br />+&nbsp; &nbsp; // Sitecom LN-029 &quot;USB 2.0 10/100 Ethernet adapter&quot;<br />+&nbsp; &nbsp; USB_DEVICE (0x6189, 0x182d),<br />+&nbsp; &nbsp; .driver_info =&nbsp; (unsigned long) &amp;ax8817x_info,<br />+}, {<br />+&nbsp; &nbsp; // corega FEther USB2-TX<br />+&nbsp; &nbsp; USB_DEVICE (0x07aa, 0x0017),<br />+&nbsp; &nbsp; .driver_info =&nbsp; (unsigned long) &amp;ax8817x_info,<br />+}, {<br />+&nbsp; &nbsp; // Surecom EP-1427X-2<br />+&nbsp; &nbsp; USB_DEVICE (0x1189, 0x0893),<br />+&nbsp; &nbsp; .driver_info = (unsigned long) &amp;ax8817x_info,<br />+}, {<br />+&nbsp; &nbsp; // goodway corp usb gwusb2e<br />+&nbsp; &nbsp; USB_DEVICE (0x1631, 0x6200),<br />+&nbsp; &nbsp; .driver_info = (unsigned long) &amp;ax8817x_info,<br />+}, {<br />+&nbsp; &nbsp; // ASIX AX88772 10/100<br />+&nbsp; &nbsp; &nbsp; &nbsp; USB_DEVICE (0x0b95, 0x7720),<br />+&nbsp; &nbsp; &nbsp; &nbsp; .driver_info = (unsigned long) &amp;ax88772_info,<br />+}, {<br />+&nbsp; &nbsp; // Linksys USB200M V2<br />+&nbsp; &nbsp; USB_DEVICE (0x13b1, 0x0018),<br />+&nbsp; &nbsp; .driver_info =&nbsp; &nbsp; (unsigned long) &amp;linksys_usb200m_v2_info,<br />+}, {<br />+&nbsp; &nbsp; // ASIX AX88178 10/100/1000<br />+&nbsp; &nbsp; &nbsp; &nbsp; USB_DEVICE (0x0b95, 0x1780),<br />+&nbsp; &nbsp; &nbsp; &nbsp; .driver_info = (unsigned long) &amp;ax88178_info,<br />+}, {<br />+&nbsp; &nbsp; // Linksys USB1000 AX88178 10/100/1000<br />+&nbsp; &nbsp; &nbsp; &nbsp; USB_DEVICE (0x1737, 0x0039),<br />+&nbsp; &nbsp; &nbsp; &nbsp; .driver_info = (unsigned long) &amp;usb1000_info,<br /> },<br /> #endif</p><p>@@ -2752,12 +4018,14 @@<br /> };</p><p> /* Default ethtool_ops assigned.&nbsp; Devices can override in their bind() routine */<br />+#ifdef ETHTOOL<br /> static struct ethtool_ops usbnet_ethtool_ops = {<br /> &nbsp; &nbsp; .get_drvinfo&nbsp; &nbsp; &nbsp; &nbsp; = usbnet_get_drvinfo,<br /> &nbsp; &nbsp; .get_link&nbsp; &nbsp; &nbsp; &nbsp; = usbnet_get_link,<br /> &nbsp; &nbsp; .get_msglevel&nbsp; &nbsp; &nbsp; &nbsp; = usbnet_get_msglevel,<br /> &nbsp; &nbsp; .set_msglevel&nbsp; &nbsp; &nbsp; &nbsp; = usbnet_set_msglevel,<br /> };<br />+#endif<br /> /*-------------------------------------------------------------------------*/</p><p> static int __init usbnet_init (void)<br />diff -ruN linux-2.4.30/include/linux/mii.h linux-2.4.30_mo/include/linux/mii.h<br />--- linux-2.4.30/include/linux/mii.h&nbsp; &nbsp; 2005-01-19 15:10:12.000000000 +0100<br />+++ linux-2.4.30_mo/include/linux/mii.h&nbsp; &nbsp; 2007-02-26 17:55:15.000000000 +0100<br />@@ -20,6 +20,8 @@<br /> #define MII_ADVERTISE&nbsp; &nbsp; &nbsp; &nbsp;0x04&nbsp; &nbsp; &nbsp; &nbsp; /* Advertisement control reg&nbsp; &nbsp;*/<br /> #define MII_LPA&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x05&nbsp; &nbsp; &nbsp; &nbsp; /* Link partner ability reg&nbsp; &nbsp; */<br /> #define MII_EXPANSION&nbsp; &nbsp; &nbsp; &nbsp;0x06&nbsp; &nbsp; &nbsp; &nbsp; /* Expansion register&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br />+#define MII_CTRL1000&nbsp; &nbsp; &nbsp; &nbsp; 0x09&nbsp; &nbsp; &nbsp; &nbsp; /* 1000BASE-T control&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br />+#define MII_STAT1000&nbsp; &nbsp; &nbsp; &nbsp; 0x0a&nbsp; &nbsp; &nbsp; &nbsp; /* 1000BASE-T status&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/<br /> #define MII_DCOUNTER&nbsp; &nbsp; &nbsp; &nbsp; 0x12&nbsp; &nbsp; &nbsp; &nbsp; /* Disconnect counter&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br /> #define MII_FCSCOUNTER&nbsp; &nbsp; &nbsp; 0x13&nbsp; &nbsp; &nbsp; &nbsp; /* False carrier counter&nbsp; &nbsp; &nbsp; &nbsp;*/<br /> #define MII_NWAYTEST&nbsp; &nbsp; &nbsp; &nbsp; 0x14&nbsp; &nbsp; &nbsp; &nbsp; /* N-way auto-neg test reg&nbsp; &nbsp; &nbsp;*/<br />@@ -105,6 +107,16 @@<br /> #define NWAYTEST_RESV2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0xfe00&nbsp; /* Unused...&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</p> <br /><p>+/* 1000BASE-T Control register */<br />+#define ADVERTISE_1000FULL&nbsp; &nbsp; &nbsp; 0x0200&nbsp; /* Advertise 1000BASE-T full duplex */<br />+#define ADVERTISE_1000HALF&nbsp; &nbsp; &nbsp; 0x0100&nbsp; /* Advertise 1000BASE-T half duplex */<br />+<br />+/* 1000BASE-T Status register */<br />+#define LPA_1000LOCALRXOK&nbsp; &nbsp; &nbsp; &nbsp;0x2000&nbsp; /* Link partner local receiver status */<br />+#define LPA_1000REMRXOK&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x1000&nbsp; /* Link partner remote receiver status */<br />+#define LPA_1000FULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0800&nbsp; /* Link partner 1000BASE-T full duplex */<br />+#define LPA_1000HALF&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0400&nbsp; /* Link partner 1000BASE-T half duplex */<br />+<br /> struct mii_if_info {<br /> &nbsp; &nbsp; int phy_id;<br /> &nbsp; &nbsp; int advertising;</p>									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p63664">
				<div class="post-metadata">
					<div class="post-num">Post #4</div>
					<div class="post-author">new</div>
					<div class="post-datetime">
						19 Feb 2008, 02:18					</div>
				</div>
				<div class="post-content content">
					<p>I have been looking at the usbnet for kernel 2.4.30 which you described, trying to&nbsp; bring it along to 2.4.34</p><p>there is a discussion thread over at the packet protector version of openwrt (starts down a ways)<br /><a href="http://packetprotector.org/forum/viewtopic.php?id=3530">http://packetprotector.org/forum/viewtopic.php?id=3530</a></p><p>as you can see I got objects from a 2.4.30 build to work with an older 2.4.30 version of their setup.<br />(found at <a href="http://wiki.openwrt.org/OpenWrtDocs/Hardware/Asus/WL-HDD)">http://wiki.openwrt.org/OpenWrtDocs/Har … us/WL-HDD)</a></p><br /><p>while trying to compile/install the patched code(I&#039;m just getting started with openwrt) I seem to have the objects accessible<br />on a 2.4.34 kernel, but the device is not being discovered.</p><p>dmesg excerpt:<br /></p><div class="quotebox"><blockquote><p>hub.c: new USB device 01:02.2-1.2, assigned address 4<br />usb.c: USB device 4 (vend/prod 0x13b1/0x18) is not claimed by any active driver.<br />kjournald starting.&nbsp; Commit interval 5 seconds<br />EXT3 FS 2.4-0.9.19, 19 August 2002 on sd(8,1), internal journal<br />EXT3-fs: recovery complete.<br />EXT3-fs: mounted filesystem with ordered data mode.<br />Adding Swap: 65524k swap-space (priority -1)<br />device br-lan entered promiscuous mode<br />device br-lan left promiscuous mode<br />device br-lan entered promiscuous mode<br />usb.c: registered new driver usbnet</p></blockquote></div><p>I wonder if you have tried a kamakaze 7.09 build of usbnet or if you have any suggestions for compiling under<br />2.4.34</p>									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p63668">
				<div class="post-metadata">
					<div class="post-num">Post #5</div>
					<div class="post-author">new</div>
					<div class="post-datetime">
						19 Feb 2008, 04:18					</div>
				</div>
				<div class="post-content content">
					<p>got help from masc.</p><p>he said<br /></p><div class="quotebox"><blockquote><p>the asix-driver should be in trunk since<br />r6812 (<a href="https://dev.openwrt.org/ticket/1481">https://dev.openwrt.org/ticket/1481</a>)</p></blockquote></div><p>thank you very much for the help</p>											<p class="post-edited">(Last edited by <strong>new</strong> on 19 Feb 2008, 04:22)</p>
									</div>
			</article>

			
		
	
			<div class="notice minor">
			<p>The discussion might have continued from here.</p>
		</div>
	
	<div class="pagination"><div class="pagination-number">Page 1 of 1</div><nav><ul><li class="pagination-current"><span>1</span></li></ul></nav></div>
</main>

</div>


<!-- Created in a hurry and not indicative of usual code quality. Here's a number: 0 -->

</body>
</html>