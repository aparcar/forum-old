<!DOCTYPE html>
<html lang="en-US">
<head>

	<title>OpenWrt Forum Archive</title>

	<meta charset="UTF-8">

	<meta http-equiv="X-UA-Compatible" content="IE=edge">

	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="assets/css/common.css">

</head>
<body>

<div class="container">

<header class="main-header">
	<h1 class="logo"><a href="index.html"><img src="assets/img/logo.png" width="376" height="88" alt="OpenWrt Forum Archive"></a></h1>
</header>

<aside>
	<p>This is a read-only archive of the old OpenWrt forum. The current OpenWrt forum resides at <a href="https://forum.openwrt.org/">https://forum.openwrt.org/</a>.</p>
	<p class="minor">In May 2018, the OpenWrt forum suffered a total data loss. This archive is an effort to restore and make available as much content as possible. Content may be missing or not representing the latest edited version.</p>
</aside>

<main>
	<header>
		<h1><span class="minor">Topic:</span> Debrick Routers with AR724x processors Using JTAG</h1>
	</header>
	<div class="notice minor">
		<p>
			The content of this topic has been archived
							on 9 Apr 2018.
										There are no obvious gaps in this topic, but there may still be some posts missing at the end.
					</p>
	</div>

	<div class="pagination"><div class="pagination-number">Page 1 of 1</div><nav><ul><li class="pagination-current"><span>1</span></li></ul></nav></div>
			
		
		
			<article class="post" id="p158626">
				<div class="post-metadata">
					<div class="post-num">Post #1</div>
					<div class="post-author">Dioptimizer</div>
					<div class="post-datetime">
						25 Feb 2012, 05:44					</div>
				</div>
				<div class="post-content content">
					<p>Hello.</p><p>After analyzing a lot of routers (with including the EJTAG port) with processor AR724x&nbsp; I can confirm of some of the pins used for de-bricking.<br />Very often meet routers that do not have labels with marking the start numbering pins of the processor.<br />To help You find the right pins, I wrote this illustration:</p><div class="codebox"><pre><code>         128                97
           |                 |
      Lock-+-----------------+-96
           |                 |
           |       /\        |
DDR Chip - |     /----\      | - SPI (or NAND) Flash Chip
           |   /        \    |
           |     AR724x      |
           |                 |
        32-+-----------------+-65
           |                 |
          33                64 
                    |
                 Ethernet</code></pre></div><p><strong>AR724x</strong> CPUs:<br />EJTAG v3.1 pinout:<br /></p><div class="quotebox"><blockquote><p>80pin&nbsp; | 81pin&nbsp; | 82pin | 84pin&nbsp; | 85pin | 93pin<br /> nTRST |&nbsp; TDI&nbsp; |&nbsp; TDO&nbsp; |&nbsp; TMS&nbsp; |&nbsp; TCK&nbsp; | RST ([s]nSRST[/s])</p></blockquote></div><p>UART pinout:<br /></p><div class="codebox"><pre><code> 86pin | 87pin 
   Rx  |  Tx</code></pre></div><p>If on PCB board of the router no place to EJTAG, then it is usually nTRST, TDI, TDO, TMS, TCK pins is used as a GPIOs pins.<br />But RST ([s]nSRST[/s]) pin is always connected to the VCC line (usually via a resistor) and is also a GPIO-pin.<br /><em>Unlike nSRST which resets the CPU but JTAG is still active.<br />RST - also disables the JTAG, ie full chip reset (same as off/on the router).</em></p><p>On processors AR7241 and AR7242 (Critical for the routers with SPI Flash Memory) was changed the location of the CS# for Flash Chip (compared with an AR7240, where CS#-pin = 75-pin) and designated as a 80-pin = CS# - i.e. on one pin is located nTRST, CS# and GPIO.</p><p>When using the EJTAG on the router, usually nTRST (negative TAP Reset) is connected to VCC line – this way enabled TAP controller. Simply <a href="http://wiki.openwrt.org/doc/hardware/port.jtag.cable.buffered?wiggler">Wiggler JTAG cable</a> used nTRST always pulled to the VCC for logical &quot;1&quot; (after the initialization of the cable) - it is usually necessary to confirm the MIPS EJTAG specification. As You can understand it is critical for SPI flash-chip that needs CS#.<br />More information about the EJTAG specification can be found at <a href="http://www.linux-mips.org/wiki/JTAG<br />">this link</a>.</p><p>In practical use was discovered that the router <a href="http://wiki.openwrt.org/ru/toh/tp-link/tl-mr3420">MR3220v1.2 (AR7241)</a> is still possible to use and JTAG interface and the SPI Flash Chip via JTAG interface as follows:</p><p>After pre-connecting to the router Simply <a href="http://wiki.openwrt.org/doc/hardware/port.jtag.cable.unbuffered?dlc5">DLC5 JTAG cable</a> (this cable is only used: TDI, TDO, TMS, TCK pins) I made a manual nTRST switch, by soldering the Button between the CS# and VCC line (between this lines need to use resistor 10…50 ohms).</p><p>1. Turn-off the router<br />2. Connect the JTAG cable to Router and PC<br />3. Press and hold the button (manual nTRST)<br />4. Turn-on the router (wait until 2 .... 3 sec)<br />5. Depress the button (manual nTRST) - in this case the router or the AR7241 processor will be in TAP mode<br />6. After that we need use the program for JTAG and we have access to the flash chip.</p><p>Links:<br /><a href="http://www.linux-mips.org/wiki/JTAG">http://www.linux-mips.org/wiki/JTAG</a><br /><a href="http://infodepot.wikia.com/wiki/TJTAG">http://infodepot.wikia.com/wiki/TJTAG</a><br /><a href="http://www.wehavemorefun.de/fritzbox/index.php/EJTAG">http://www.wehavemorefun.de/fritzbox/index.php/EJTAG</a></p>											<p class="post-edited">(Last edited by <strong>Dioptimizer</strong> on 20 Apr 2012, 15:51)</p>
									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p160117">
				<div class="post-metadata">
					<div class="post-num">Post #2</div>
					<div class="post-author">Orca</div>
					<div class="post-datetime">
						8 Mar 2012, 14:36					</div>
				</div>
				<div class="post-content content">
					<p>Why o0n earth don&#039;t you use the <a href="http://wiki.openwrt.org/doc/hardware/port.jtag">wiki</a> to document stuff?</p>									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p164324">
				<div class="post-metadata">
					<div class="post-num">Post #3</div>
					<div class="post-author">Dioptimizer</div>
					<div class="post-datetime">
						13 Apr 2012, 01:30					</div>
				</div>
				<div class="post-content content">
					<p>Configuration (taget) file <strong>ar724x.cfg</strong> for OpenOCD:<br /></p><div class="codebox"><pre><code># Atheros AR724x MIPS 24Kc SoC.
# tested on AP99 refererence board
#
# this settings are taken from source of u-boot for this board
# (for PLL) file:    u-boot/board/ar7240/common/lowlevel_init.S
# (for DDR) file:    u-boot/cpu/mips/ar7240/meminit.c
#      with file:    u-boot/include/configs/ap99.h

adapter_nsrst_delay 100
jtag_ntrst_delay 100

reset_config trst_only separate            ;# or use only &quot;reset_config none&quot;

set CHIPNAME ar724x

jtag newtap $CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id 1

set TARGETNAME $CHIPNAME.cpu
target create $TARGETNAME mips_m4k -endian big -chain-position $TARGETNAME

$TARGETNAME configure -event reset-init {
    #reset Watchdog Timer
    mww 0xb8060008 3            ;# rst watchdog timer control        &lt;
    mww 0xb806000c 0x12c        ;# rst watchdog timer (resets SoC)    &gt;
    sleep 10
    halt
    wait_halt

    #setup PLL to lowest(default) common denominator 400/400/200 setting
    mww 0xb8050000 0x00090828        ;# clr pll mask (rst: 02090828)
    mww 0xb8050000 0x00050828        ;# CPU:400 DDR:400 AHB:200
    mww 0xb8050000 0x00040828        ;# clr pll bypass

    #next command will reset for PLL changes to take effect 
    mww 0xb8050008 2            ;# set reset_switch
    mww 0xb8050008 3            ;# set clock_switch (resets SoC)
    sleep 10
    halt
    wait_halt

    #complete pll initialization
    mww 0xb8050008 0            ;# set reset_switch bit &amp; clock_switch bit
    
    # Setup DDR config and flash mapping
    mww 0xb8000000 0xc7bc8cd0        ;# DDR cfg cdl val (rst: 77be8cd0)
    mww 0xb8000004 0x9dd0e6a8        ;# DDR cfg2 cdl val (rst: 99d10628)

    mww 0xb8000010 8            ;# force precharge all banks
    mww 0xb8000008 0x133            ;# DDR mode value init
    mww 0xb8000010 1            ;# force EMRS update cycle
    mww 0xb800000c 0            ;# clr ext. mode register

    mww 0xb8000010 2            ;# force auto refresh all banks
    mww 0xb8000010 8            ;# force precharge all banks
    mww 0xb8000008 0x33            ;# set DDR mode value CAS=3
    mww 0xb8000010 1            ;# force EMRS update cycle
    mww 0xb8000014 0x4f10        ;# DDR refresh value
    mww 0xb8000018 0xff            ;# DDR Read Data This Cycle value (16bit: 0xffff)
    mww 0xb800001c 2            ;# delay added to the DQS0 line (normal = 8)
    mww 0xb8000020 2            ;# delay added to the DQS1 line (normal = 9)
    mww 0xb8000024 0
    mww 0xb8000028 0
}

# setup working area somewhere in RAM
$TARGETNAME configure -work-area-phys 0xa0600000 -work-area-size 0x20000

# serial SPI capable flash
# flash bank &lt;driver&gt; &lt;base&gt; &lt;size&gt; &lt;chip_width&gt; &lt;bus_width&gt;</code></pre></div><p>OpenOCD log when connected board:<br /></p><div class="codebox"><pre><code>D:\Free\OpenOCD\0.5.0&gt;openocd-0.5.0.exe -f interface\parport.cfg -f target\ar724x.cfg
Open On-Chip Debugger 0.5.0 (2012-04-06-14:30)
Licensed under GNU GPL v2
For bug reports, read
        http://openocd.berlios.de/doc/doxygen/bugs.html
Warn : Adapter driver &#039;parport&#039; did not declare which transports it allows; assu
ming legacy JTAG-only
Info : only one transport option; autoselect &#039;jtag&#039;
parport port = 0x378
6000 kHz
adapter_nsrst_delay: 100
jtag_ntrst_delay: 100
none separate
131072
Info : clock speed 500 kHz
Info : JTAG tap: ar724x.cpu tap/device found: 0x00000001 (mfg: 0x000, part: 0x0
000, ver: 0x0)
Info : accepting &#039;telnet&#039; connection from 4444</code></pre></div><p><strong>My</strong> telnet log:<br /></p><div class="codebox"><pre><code>Open On-Chip Debugger
&gt; reset
JTAG tap: ar724x.cpu tap/device found: 0x00000001 (mfg: 0x000, part: 0x0000, ver: 0x0)
&gt; halt
target state: halted
target halted in MIPS32 mode due to debug-request, pc: 0xbfc03860
&gt; reset
JTAG tap: ar724x.cpu tap/device found: 0x00000001 (mfg: 0x000, part: 0x0000, ver: 0x0)
target state: halted
target halted in MIPS32 mode due to debug-request, pc: 0xbfc03860
&gt; mww 0xb8060008 3
&gt; mww 0xb806000c 0x12c
in procedure &#039;mww&#039;
&gt; halt
target state: halted
target halted in MIPS32 mode due to debug-request, pc: 0xbfc03860
&gt; mww 0xb8050000 0x00090828
&gt; mww 0xb8050000 0x00050828
&gt; mww 0xb8050000 0x00040828
&gt; mww 0xb8050008 2
&gt; mww 0xb8050008 3
in procedure &#039;mww&#039;
&gt; halt
target state: halted
target halted in MIPS32 mode due to debug-request, pc: 0xbfc03860
&gt; reset init
JTAG tap: ar724x.cpu tap/device found: 0x00000001 (mfg: 0x000, part: 0x0000, ver: 0x0)
target state: halted
target halted in MIPS32 mode due to debug-request, pc: 0xbfc03860
&gt; load_image backup_fullflash.bin 0x81000000
4194304 bytes written at address 0x81000000
downloaded 4194304 bytes in 434.899994s (9.418 KiB/s)
&gt; load_image 8Muboot_RAM_version.bin 0x80000000
262144 bytes written at address 0x80000000
downloaded 262144 bytes in 21.150000s (12.104 KiB/s)
&gt; resume 0x80000000</code></pre></div><p>If you see error &quot;<strong>in procedure &#039;mww&#039;</strong>&quot; - its bug OpenOCD.<br /><strong>reset init</strong> - for my build of OpenOCD (with bugs), I changed init script so that it begins with &quot;# complete pll initialization&quot;.</p><br /><p>Parallel you should use UART and you will see:<br /></p><div class="codebox"><pre><code>U-Boot 1.3.0-TT-0.1.0 (Nov 29 2011 - 19:25:10)@TTHR

              IN DEBUG MODE

AP99 (ar7241 - Virian) U-boot
#### TAP VALUE 1 = 0x2, 2 = 0x2 [0x0: 0x0]
CPU_FREQ=400##DDR_FREQ=400##AHB_FREQ=200
DRAM:  32 MB
uboot_end=[0x80030320]###len=[0x30320]Top of RAM usable for U-Boot at: 82000000
Reserving 192k for U-Boot at: 81fcc000
Reserving 192k for malloc() at: 81f9c000
Reserving 44 Bytes for Board Info at: 81f9bfd4
Reserving 36 Bytes for Global Data at: 81f9bfb0
Reserving 128k for boot params() at: 81f7bfb0
Stack Pointer at: 81f7bf98
Now running in RAM - U-Boot at: 81fcc000
Flash:  8 MB
Using default environment


Warnning Board Uncolabrated!!
In:    serial
Out:   serial
Err:   serial
Net:   ag7240_enet_initialize...
No valid address in Flash. Using fixed address
No valid address in Flash. Using fixed address
Virian MDC CFG Value ==&gt; 4
: cfg1 0xf cfg2 0x7014
eth0: 40:16:9f:ab:e0:82
eth0 up
Virian MDC CFG Value ==&gt; 4
: cfg1 0xf cfg2 0x7214
eth1: 40:16:9f:ab:e0:82
ATHRS26: resetting s26
ATHRS26: s26 reset done
eth1 up
eth0, eth1
### main_loop entered: bootdelay=1

### main_loop: bootcmd=&quot;bootm 0x9f020000&quot;
Autobooting in 1 seconds press tt to abort
AR7241#</code></pre></div><p>And last commands in OpenOCD telnet:<br /></p><div class="codebox"><pre><code>&gt; jtag_reset 1 0
&gt; shutdown</code></pre></div><p><strong>jtag_reset 1 0</strong>&nbsp; &nbsp; &nbsp; &lt;= use this command, if you also use nTRST pin on JTAG cable. This command will disable nTRST line on JTAG adaptor.</p><p>Uboot for AP99 from <strong>tthrx</strong>&nbsp; &nbsp; &nbsp; &lt;= thx bro<br /><a href="https://forum.openwrt.org/viewtopic.php?id=33205">https://forum.openwrt.org/viewtopic.php?id=33205</a></p><br /><p>P.S.<br />Bootloader for the other boards need change so that it was loaded from SDRAM.</p><p>Or if someone wants to: you can make a universal u-boot - before applying specific configuration (while uboot is loading) of ap99, pb90, pb93, etc. theoretically, we could choose its configuration via the console by typing command. This is possible because UART (GPIO 9 and 10) - common for this CPUs.</p>											<p class="post-edited">(Last edited by <strong>Dioptimizer</strong> on 20 Apr 2012, 16:53)</p>
									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p171206">
				<div class="post-metadata">
					<div class="post-num">Post #4</div>
					<div class="post-author">Dioptimizer</div>
					<div class="post-datetime">
						29 Jun 2012, 03:04					</div>
				</div>
				<div class="post-content content">
					<p><a href="http://www.google.com/translate_c?langpair=ru|en&amp;u=http://wiki.openwrt.org/ru/toh/tp-link/tl-mr3420/debrick%2525using%2525jtag">Last wiki version</a></p>											<p class="post-edited">(Last edited by <strong>Dioptimizer</strong> on 29 Jun 2012, 03:06)</p>
									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p185373">
				<div class="post-metadata">
					<div class="post-num">Post #5</div>
					<div class="post-author">Dioptimizer</div>
					<div class="post-datetime">
						6 Dec 2012, 13:23					</div>
				</div>
				<div class="post-content content">
					<p>Alternative universal bootloader over JTAG (with flash size detection) - <a href="http://wiki.openwrt.org/doc/techref/bootloader/myloader#myloram">myloram</a>.<br />Also there is another varian for AR71xx CPU&#039;s.</p>									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p187447">
				<div class="post-metadata">
					<div class="post-num">Post #6</div>
					<div class="post-author">jenom</div>
					<div class="post-datetime">
						31 Dec 2012, 01:34					</div>
				</div>
				<div class="post-content content">
					<p>I have a totally bricked D-link DIR-615 H/W E3 with AR7240 CPU and MX25L3206&nbsp; flash.</p><p>Already soldered a serial and jtag connector to the board, and I have also made a parallel Xilinx DLC5 cable.<br />Followed DIOPTIMIZER instructions, traced nTRST-TDI-TDO-TTMS-TCK lines from JTAG connector to CPU and discovered that some of them were interrupted by a missing resistors on board.....soldered jumpers instead of them.<br />Also created a manual reset button between +VCC (pin 14 on JTAG) and nTRST (used a 100 ohm resistor)<br />Connected a TTL to RS232 converter to serial (TX,RX,GND)....used Windows Hyperterminal , but getting nothing.</p><p>Should I be able to received something from serial port even if router&#039;s bootloader is probably dead ?? </p><p>So far have not found any JTAG program , which would support AR7240 CPU and MX25L3206 flash !! <br />Does&nbsp; the mentioned MYLORAM or MYLOADER or OPENOCD has support for these chips ?<br />Thanks</p>									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p207027">
				<div class="post-metadata">
					<div class="post-num">Post #7</div>
					<div class="post-author">LightworkerNaven</div>
					<div class="post-datetime">
						12 Jul 2013, 21:58					</div>
				</div>
				<div class="post-content content">
					<p>Sorry, but I&#039;m going to have to resurrect the dead on this one.&nbsp; I tried the above process on a WZR-HP-G300NH2 router running the AR7242 proc, but I haven&#039;t had much luck.&nbsp; I tried variations of this as well.&nbsp; Here&#039;s what I&#039;ve tried in hopes that someone can help me figure out why this isn&#039;t working right.</p><p>Router: WZR-HP-G300NH2<br />Proc: AR7242-AH1A<br />JTAG Unit: USB JTAG NT<br />Originally sought help at: <a href="http://www.usbjtag.com/vbforum/showthread.php?s=eb39556ec2322b5b17be10b38b0fc29a&amp;p=55639">http://www.usbjtag.com/vbforum/showthre … mp;p=55639</a></p><p>try{<br />//On the back of the board, there&#039;s a blank space for a resistor (R309) which has one pad directly connected to pin 80 and the other pad is connected to ground.&nbsp; I soldered a wire to the pad attached to pin 80.&nbsp; I soldered the other end of the wire to a 35.7 Ohm resistor and the other end of the 35 Ohm resistor to a PBNO switch and the other end of the switch to the VCC on the serial port.&nbsp; (Pin 1 - 3.3v)<br />}</p><p>catch:{<br />//USB JTAG NT reported &quot;Debug Off&quot; after following the steps to keep pin 80 hot while booting the unit and then releasing the switch after 2 seconds.<br />}</p><br /><br /><p>try{<br />//I removed the resistor and tried again to see if putting the full 3.3V through would fix the issue.&nbsp; (I was reading 2.59V on my voltmeter with the resistor in.)<br />}</p><p>catch{<br />//That didn&#039;t work. It still said &quot;Debug Off&quot; on USB JTAG NT.&nbsp; (Keep in mind that I know my USB JTAG NT is working properly and I did use it on other units successfully.&nbsp; USBBDM (The guy who created USB JTAG NT) told me to use the settings for WRT160NL and that&#039;s what I&#039;ve been using for this unit.&nbsp; He referred me to this thread to try it out as well.<br />}</p><br /><br /><p>try{<br />//I tried hooking pin 80 directly to VCC and not releasing it.<br />}</p><p>catch{<br />//It still said &quot;Debug Off.&quot;<br />}</p><br /><br /><p>try{<br />//I tried connecting pin 80 to the JTAG header&#039;s pin 1 (nTRST pin that&#039;s disconnected from the board - no circuitry connects to it) as USB JTAG NT keeps that line hot.<br />}</p><p>catch{<br />//USB JTAG NT&#039;s software reports &quot;Debug Off.&quot;<br />}</p><br /><br /><p>I have yet to try out using pin 93 as the VCC source, but the only way I&#039;d see that working is if it pulls enough voltage away from pin 93 that it goes low and pin 80 goes high from powering both pins, but my best guess is that they both would go low as you&#039;d be splitting the power source at an original 3.3v.</p><p>Does anyone have any other ideas I can try with this unit?&nbsp; Has anyone ever fondled it&#039;s JTAG port before?&nbsp; lol</p>									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p207032">
				<div class="post-metadata">
					<div class="post-num">Post #8</div>
					<div class="post-author">Dioptimizer</div>
					<div class="post-datetime">
						13 Jul 2013, 02:02					</div>
				</div>
				<div class="post-content content">
					<p><strong>LightworkerNaven</strong><br />What is your target to use JTAG on the device?</p><p>If you want to restore the flash memory, can easily connect to the flash memory (no Desoldering) via SPI programmator, and the processor to translate in RST mode (so all GPIO&#039;s will not be active - low state).</p><p>All my experiments were without datasheet, even now there is no way to find the datasheet for this processor (AR724x).<br />I even say more, I&#039;m not sure that &quot;nTRST&quot; exists at all on processors ar7241/ar7242 (unlike ar7240).<br />The fact is that when we connect the power to the 80pin - it disables the flash memory on the device (if it is connected to this 80-pin=CS0-pin on flashchip) - the processor just not initialized and enabling the JTAG or may switches to Test/Debug Mode.</p><p>What does this &quot;Debug Off.&quot;?<br />Do you have an extended response from the software?<br />What is the IDentifier of the processor is waiting for your software, if it is waiting for it at all?<br />Under that link confuses me a configuration file that contains the option availability of DMA in the JTAG - this is not true.<br />All operations with a processor only PrAcc mode.<br />Also option IRLength which should be &quot;<strong>5</strong>&quot; (have you seen the <a href="http://elinux.org/Ar724x.cfg">config. file for OpenOCD</a>?)<br /></p><div class="quotebox"><blockquote><p>jtag newtap $CHIPNAME cpu -irlen <span style="color: red"><strong>5</strong></span> -ircapture 0x1 -irmask 0x1f -expected-id <span style="color: red"><strong>1</strong></span></p></blockquote></div><p>Sorry for my English is incredibly horrible.</p>											<p class="post-edited">(Last edited by <strong>Dioptimizer</strong> on 13 Jul 2013, 02:20)</p>
									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p207083">
				<div class="post-metadata">
					<div class="post-num">Post #9</div>
					<div class="post-author">LightworkerNaven</div>
					<div class="post-datetime">
						14 Jul 2013, 04:18					</div>
				</div>
				<div class="post-content content">
					<p>USB JTAG NT is a proprietary program that I bought to JTAG my stuff with since it seems to be the most comprehensive of the ones I saw while researching.&nbsp; It&#039;s easy to use and comes with a GUI.&nbsp; The &quot;Debug Off&quot; bit is part of that program and also the DMA bit is part of what it reads from it&#039;s config.&nbsp; DMA just means dynamic memory address and because it isn&#039;t starting at 0x0 usually, it&#039;s dynamic in terms of it&#039;s placement in the chip.&nbsp; That&#039;s my take on why he added that.</p><p>As for using the JTAG port on the WZR-HP-G300NH2, I figured out how to make it work properly using this tutorial for the pinout and following the traces on the board to discover that several resistors were missing to interrupt the JTAG.&nbsp; My findings can be found in this post which I&#039;ll keep updated until I&#039;m done with the JTAG process.</p><p><a href="http://www.usbjtag.com/vbforum/showthread.php?t=8570&amp;page=2#21">http://www.usbjtag.com/vbforum/showthre … ;page=2#21</a></p><p>By the way, thanks for the IR Length code.&nbsp; I&#039;ll go and check into converting the config files you posted and modifying them to work with USB JTAG NT with my unit.</p>									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p209433">
				<div class="post-metadata">
					<div class="post-num">Post #10</div>
					<div class="post-author">vglavatsky</div>
					<div class="post-datetime">
						10 Aug 2013, 17:11					</div>
				</div>
				<div class="post-content content">
					<p>Is there anybody who connected to JTAG on D-Link DIR-615-E4 (AR7240 chip) successfully?</p><p>I&#039;m soldered jumpers instead of missing resistors on the board, so all JTAG ping connected to AR7240 chip correctly (in accordance to info at first post).<br />I&#039;m connected to the board via J-Link clone using openocd-0.7, but not success:</p><p>&gt;openocd-0.7.0.exe -f interface\jlink.cfg -f target\ar71xx.cfg -c &quot;adapter_khz 10&quot;<br />Open On-Chip Debugger 0.7.0 (2013-05-05-10:41)<br />Licensed under GNU GPL v2<br />For bug reports, read<br />&nbsp; &nbsp; &nbsp; &nbsp; <a href="http://openocd.sourceforge.net/doc/doxygen/bugs.html">http://openocd.sourceforge.net/doc/doxygen/bugs.html</a><br />Info : only one transport option; autoselect &#039;jtag&#039;<br />adapter_nsrst_delay: 100<br />jtag_ntrst_delay: 100<br />trst_and_srst separate srst_gates_jtag trst_push_pull srst_open_drain connect_deassert_srst<br />131072<br />adapter speed: 10 kHz<br />Info : J-Link initialization started / target CPU reset initiated<br />Info : J-Link compiled Dec 03 2007 17:15:31 ARM Rev.5<br />Info : J-Link caps 0xdffbf<br />Info : J-Link hw version 53000<br />Info : J-Link hw type J-Link<br />Info : J-Link max mem block 9992<br />Info : J-Link configuration<br />Info : USB-Address: 0xff<br />Info : Kickstart power on JTAG-pin 19: 0xffffffff<br />Info : Vref = 2.517 TCK = 1 TDI = 0 TDO = 0 TMS = 0 SRST = 0 TRST = 0<br />Info : J-Link JTAG Interface ready<br />Info : clock speed 10 kHz<br />Error: JTAG scan chain interrogation failed: all zeroes<br />Error: Check JTAG interface, timings, target power, etc.<br />Error: Trying to use configured scan chain anyway...<br />Error: ar71xx.cpu: IR capture error; saw 0x00 not 0x01<br />Warn : Bypassing JTAG setup events due to errors</p>									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p209702">
				<div class="post-metadata">
					<div class="post-num">Post #11</div>
					<div class="post-author">sarroyo</div>
					<div class="post-datetime">
						13 Aug 2013, 19:35					</div>
				</div>
				<div class="post-content content">
					<p>I am doing some openocd tests over a wr841nd 7.2, mostly cache code related. Now this board is working fine<br />for me. The board is halted using the ntrst line from my ftdi hs adapter (self made). After deasserting the RST line there is around 15 to 20 ms time left to halt the core. Openocd at 500khz takes about 3 or 4ms to halt it. Setting adapter_khz below 50khz fails.<br />With additional hardware the core can be halted by blocking the clock at pin 94, the tap seems to work without clocking.<br />For memory dump from spi flash mips32 scan_delay must be set to 3600 or higher and the transfer speed is around 75Kbytes/s at 15000khz scan rate. For memory loads to ram scan_delay can be set to 0 and the transfer speed is over 600Kbytes/s (works with fast data transfer).<br />In case of fail in queued mode probably openocd refuses to work because pracc access don&#039;t starts at pracc text. The only option is a reset or if you want call the jtt utility ( in the config).<br />Use mips32 scan_delay 2000000 to jump back to legacy mode.<br />Use only the ftdi adapter driver. DO NOT USE ft2232!!!! if you have ftdi based adapter of course.<br />Wiggler works a bit faster in queued mode but not much, better let it in legacy mode (by default for every adapter).<br />Good luck an thanks for the code, my English is not better.</p><p>#################&nbsp; config ######################</p><p># Atheros AR724x MIPS 24Kc SoC.<br /># tested on AP99 refererence board<br />#<br /># this settings are taken from source of u-boot for this board<br /># (for PLL) file:&nbsp; &nbsp; u-boot/board/ar7240/common/lowlevel_init.S<br /># (for DDR) file:&nbsp; &nbsp; u-boot/cpu/mips/ar7240/meminit.c<br />#&nbsp; &nbsp; &nbsp; with file:&nbsp; &nbsp; u-boot/include/configs/ap99.h</p><p># preliminary config based on <a href="https://forum.openwrt.org/viewtopic.php?id=34993">https://forum.openwrt.org/viewtopic.php?id=34993</a><br /># tested on an ar7241-ah1a based board</p><p>if { [info exists CHIPNAME] } {<br />&nbsp; &nbsp;set _CHIPNAME $CHIPNAME<br />} else {<br />&nbsp; &nbsp;set _CHIPNAME AR7241<br />}</p><p>if { [info exists ENDIAN] } {<br />&nbsp; &nbsp;set _ENDIAN $ENDIAN<br />} else {<br />&nbsp; &nbsp;set _ENDIAN big<br />}</p><p>if { [info exists CPUTAPID] } {<br />&nbsp; &nbsp;set _CPUTAPID $CPUTAPID<br />} else {<br />&nbsp; &nbsp;set _CPUTAPID 0x00000001<br />}</p><p>jtag_ntrst_assert_width 200<br />jtag_ntrst_delay 1</p><p>reset_config trst_only</p><p>jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID</p><p>set _TARGETNAME $_CHIPNAME.cpu<br />target create $_TARGETNAME mips_m4k -endian $_ENDIAN -chain-position $_TARGETNAME</p><br /><p># setup working area somewhere in RAM<br />$_TARGETNAME configure -work-area-phys 0x80600000 -work-area-size 0x20000</p><br /><p>$_TARGETNAME configure -event reset-init {<br />&nbsp; &nbsp; global _TARGETNAME<br />&nbsp; &nbsp; mips32 scan_delay 2000000&nbsp; &nbsp; &nbsp; &nbsp; ;# do it in legacy mode</p><p>&nbsp; &nbsp; mww 0xb8060008 3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;# rst watchdog timer control<br />&nbsp; &nbsp; irscan $_TARGETNAME 0xc&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;# ejtagboot indication, internal reset will be triggered</p><p>&nbsp; &nbsp; # catch error, mww will fail after reset<br />&nbsp; &nbsp; catch { mww 0xb806000c 0x12c }&nbsp; &nbsp; &nbsp; &nbsp; ;# rst watchdog timer (resets SoC)</p><p>&nbsp; &nbsp; echo &quot;watchdog settings done&quot;<br />&nbsp; &nbsp; sleep 200<br />&nbsp; &nbsp; halt</p><p>&nbsp; &nbsp; mww 0xb8050000 0x00090828&nbsp; &nbsp; &nbsp; &nbsp; ;# clr pll mask (rst: 02090828)<br />&nbsp; &nbsp; mww 0xb8050000 0x00050828&nbsp; &nbsp; &nbsp; &nbsp; ;# CPU:400 DDR:400 AHB:200<br />&nbsp; &nbsp; mww 0xb8050000 0x00040828&nbsp; &nbsp; &nbsp; &nbsp; ;# clr pll bypass</p><p>&nbsp; &nbsp; #next command will reset for PLL changes to take effect</p><p>&nbsp; &nbsp; mww 0xb8050008 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;# set reset_switch<br />&nbsp; &nbsp; irscan $_TARGETNAME 0xc&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;# ejtagboot indication, internal reset will be triggered</p><p>&nbsp; &nbsp; # catch error, really not needed in this case, in legacy mode&nbsp; it reads a second pass through pracc text (like a normal exit)<br />&nbsp; &nbsp; catch { mww 0xb8050008 3 }&nbsp; &nbsp; &nbsp; &nbsp; ;# set clock_switch (resets SoC)</p><p>&nbsp; &nbsp; echo &quot;pll settings done&quot;<br />&nbsp; &nbsp; sleep 200<br />&nbsp; &nbsp; halt</p><p>&nbsp; &nbsp; mww 0xb8050008 0&nbsp; &nbsp; &nbsp; &nbsp; ;# set reset_switch bit &amp; clock_switch bit<br />&nbsp; &nbsp;<br />&nbsp; &nbsp; # Setup DDR config and flash mapping</p><p>&nbsp; &nbsp; mww 0xb8000000 0xc7bc8cd0&nbsp; &nbsp; ;# DDR cfg cdl val (rst: 77be8cd0)<br />&nbsp; &nbsp; mww 0xb8000004 0x9dd0e6a8&nbsp; &nbsp; ;# DDR cfg2 cdl val (rst: 99d10628)</p><p>&nbsp; &nbsp; mww 0xb8000010 8&nbsp; &nbsp; &nbsp; &nbsp; ;# force precharge all banks<br />&nbsp; &nbsp; mww 0xb8000008 0x133&nbsp; &nbsp; &nbsp; &nbsp; ;# DDR mode value init<br />&nbsp; &nbsp; mww 0xb8000010 1&nbsp; &nbsp; &nbsp; &nbsp; ;# force EMRS update cycle<br />&nbsp; &nbsp; mww 0xb800000c 0&nbsp; &nbsp; &nbsp; &nbsp; ;# clr ext. mode register</p><p>&nbsp; &nbsp; mww 0xb8000010 2&nbsp; &nbsp; &nbsp; &nbsp; ;# force auto refresh all banks<br />&nbsp; &nbsp; mww 0xb8000010 8&nbsp; &nbsp; &nbsp; &nbsp; ;# force precharge all banks<br />&nbsp; &nbsp; mww 0xb8000008 0x33&nbsp; &nbsp; &nbsp; &nbsp; ;# set DDR mode value CAS=3<br />&nbsp; &nbsp; mww 0xb8000010 1&nbsp; &nbsp; &nbsp; &nbsp; ;# force EMRS update cycle<br />&nbsp; &nbsp; mww 0xb8000014 0x4f10&nbsp; &nbsp; &nbsp; &nbsp; ;# DDR refresh value<br />&nbsp; &nbsp; mww 0xb8000018 0xff&nbsp; &nbsp; &nbsp; &nbsp; ;# DDR Read Data This Cycle value (16bit: 0xffff)<br />&nbsp; &nbsp; mww 0xb800001c 2&nbsp; &nbsp; &nbsp; &nbsp; ;# delay added to the DQS0 line (normal = 8)<br />&nbsp; &nbsp; mww 0xb8000020 2&nbsp; &nbsp; &nbsp; &nbsp; ;# delay added to the DQS1 line (normal = 9)<br />&nbsp; &nbsp; mww 0xb8000024 0<br />&nbsp; &nbsp; mww 0xb8000028 0</p><p>&nbsp; &nbsp; irscan $_TARGETNAME 0xd&nbsp; &nbsp; &nbsp; &nbsp; ;# normalboot</p><p>&nbsp; &nbsp; echo &quot;&quot;<br />&nbsp; &nbsp; echo &quot;Targed initialized uncached&quot;<br />}</p><br /><br /><p># serial SPI capable flash<br /># flash bank &lt;driver&gt; &lt;base&gt; &lt;size&gt; &lt;chip_width&gt; &lt;bus_width&gt;</p><p># Make a jump to text (0xff200200) utility<br />proc jtt {} {<br />&nbsp; &nbsp; poll off<br />&nbsp; &nbsp; sleep 50<br />&nbsp; &nbsp; global _TARGETNAME<br />&nbsp; &nbsp; irscan $_TARGETNAME 0x9&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;# select data register<br />&nbsp; &nbsp; drscan $_TARGETNAME 32 0xbc80080&nbsp; &nbsp; ;# Jump code<br />&nbsp; &nbsp; irscan $_TARGETNAME 0xa&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;# select control register<br />&nbsp; &nbsp; drscan $_TARGETNAME 32 0x8000c000&nbsp; &nbsp; ;# finish processor access, go to next<br />&nbsp; &nbsp; sleep 50<br />&nbsp; &nbsp; irscan $_TARGETNAME 0x9<br />&nbsp; &nbsp; drscan $_TARGETNAME 32 0&nbsp; &nbsp; &nbsp; &nbsp; ;# Nop code, in delay slot of the jump<br />&nbsp; &nbsp; irscan $_TARGETNAME 0xa<br />&nbsp; &nbsp; drscan $_TARGETNAME 32 0x8000c000<br />&nbsp; &nbsp; poll on<br />}<br />####################### end config #############################</p>									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p209795">
				<div class="post-metadata">
					<div class="post-num">Post #12</div>
					<div class="post-author">Dioptimizer</div>
					<div class="post-datetime">
						14 Aug 2013, 16:45					</div>
				</div>
				<div class="post-content content">
					<div class="quotebox"><cite>sarroyo wrote:</cite><blockquote><p>...In case of fail in queued mode probably openocd refuses to work because pracc access don&#039;t starts at pracc text. The only option is a reset or if you want call the jtt utility ( in the config)....</p></blockquote></div><p><a href="http://www.google.com/translate_c?langpair=ru|en&amp;u=http://wiki.openwrt.org/ru/toh/tp-link/tl-mr3420/debrick%2525using%2525jtag">Another my config file</a></p><p>OEM COMPEX WPE72(Atheros AR724x) config file (<strong>without</strong> resets SoC):<br /></p><div class="quotebox"><cite>init-ar7240.mac wrote:</cite><blockquote><p>; macro file for AR7200 boards (32/64 MB ram)<br />; OCD Commander settings:<br />;&nbsp; &nbsp; &nbsp;Target Processor: MIPS, EJTAG 2.5, 32 bit<br />;&nbsp; &nbsp; &nbsp;Connection&nbsp; &nbsp; &nbsp; : LPT1<br />;&nbsp; &nbsp; &nbsp;OCD Device&nbsp; &nbsp; &nbsp; : Wiggler<br />;&nbsp; &nbsp; &nbsp;OCD Speed&nbsp; &nbsp; &nbsp; &nbsp;: 380 KHz</p><p>reset<br />mipsendian big</p><br /><p>; WAR for the bug#55574: Set the CKE (bit 7 in DDR_CONFIG2 register) <br />; to low initially <br />word 0xB8000004 = 0x99D10628</p><br /><p>; set PLL<br />word 0xb8050000 = 0x00040828</p><br /><p>; update PLL<br />word 0xb8050008 = 0x1<br />delay 10</p><p>word 0xb8050008 = 0x0</p><p>; disable flash remap<br />word 0xbf000004 = 0x43</p><br /><p>; DDR</p><p>word 0xb8000000 = 0xC7BC8CD0<br />word 0xB8000004 = 0x9DD0E6A8<br />word 0xB8000010 = 0x00000008<br />word 0xB8000008 = 0x00000133<br />delay 10</p><p>word 0xB8000010 = 0x00000001<br />word 0xB800000C = 0x00000000<br />word 0xB8000010 = 0x00000002<br />word 0xB8000010 = 0x00000008<br />word 0xB8000008 = 0x00000033<br />word 0xB8000010 = 0x00000001</p><p>word 0xB8000014 = 0x00004F10<br />word 0xB8000018 = 0x000000FF</p><p>word 0xB800001C = 0x00000007<br />word 0xB8000020 = 0x00000007</p><p>;<br />; UART Test<br />;</p><p>word 0xB8040028 = 0x000480FA</p><p>word 0xB802000C = 0x00000083<br />word 0xB8020000 = 0x0000006D<br />word 0xB8020004 = 0x00000000<br />word 0xB802000C = 0x00000003<br />word 0xB8020008 = 0x00000001</p><p>word 0xB8020000 = 0x00000030<br />word 0xB8020000 = 0x00000031<br />word 0xB8020000 = 0x00000032<br />word 0xB8020000 = 0x00000033<br />word 0xB8020000 = 0x00000034<br />word 0xB8020000 = 0x00000035<br />word 0xB8020000 = 0x00000036<br />word 0xB8020000 = 0x00000037<br />word 0xB8020000 = 0x00000038<br />word 0xB8020000 = 0x00000039<br />word 0xB8020000 = 0x0000000D<br />word 0xB8020000 = 0x0000000A</p><p>; load file<br />delay 500<br />download myloram.srec</p><p>delay 100<br />go</p></blockquote></div><p><a href="http://wiki.openwrt.org/doc/techref/bootloader/myloader#myloram">http://wiki.openwrt.org/doc/techref/boo … er#myloram</a></p><p><strong>sarroyo</strong><br />If you can, please, put here your TEST with this(COMPEX) configuration file (also with a universal boot loader <strong>myloram</strong>) and place your results here.<br />Thanks anyway.</p>											<p class="post-edited">(Last edited by <strong>Dioptimizer</strong> on 14 Aug 2013, 17:17)</p>
									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p210168">
				<div class="post-metadata">
					<div class="post-num">Post #13</div>
					<div class="post-author">sarroyo</div>
					<div class="post-datetime">
						19 Aug 2013, 20:16					</div>
				</div>
				<div class="post-content content">
					<p>The new configuration for init works much better and is much simpler. Scan_delay can be set to 0 for memory dumps and&nbsp; at 15000Khz in queued mode works up to 114kb/s. Contrary for memory writes to ram i need to add now a little delay of about 100, but still works over 600Kb/s.<br />Cache modes can be changed in config register and works without any other additional configuration, fine.<br />Seems the flash is working a bit faster.<br />The bad news is that myloram does not work me. Ping does not work at all&nbsp; and i end making some stupidity and bricking my router. Here is part of the&nbsp; log from the serial console:</p><p>Main Menu</p><p>1 - Load Firmware<br />2 - Load Program<br />3 - BIOS Setup<br />4 - Fdisk Utility<br />5 - Update Flash (Binary Mode)<br />6 - Update Firmware (Image Mode)<br />7 - Reboot System<br />8 - Memory Test</p><p>Please select : 3</p><p>BIOS Setup</p><p>1 - Device ID Setup<br />2 - Flash Setup<br />3 - DRAM Setup<br />4 - Boot Mode Setup<br />5 - TFTP Server Setup<br />6 - Ethernet Address Setup<br />7 - Load Default<br />8 - Ethernet Interface Setup</p><p>Please select : 1</p><p>Device ID Setup</p><p>Vendor ID (11f6) :</p><p>evice ID (0672) :<br />Subvendor ID (11f6) : <br />Subdevice ID (0672) :<br />Revision (00000000) :<br />Update System Paramters ............. Done</p><p>BIOS Setup</p><p>1 - Device ID Setup<br />2 - Flash Setup<br />3 - DRAM Setup<br />4 - Boot Mode Setup<br />5 - TFTP Server Setup<br />6 - Ethernet Address Setup<br />7 - Load Default<br />8 - Ethernet Interface Setup</p><p>Please select : 3</p><p>DRAM Setup</p><p>DRAM Size (02000000) :<br />Update System Paramters ............. Done</p><p>BIOS Setup</p><p>1 - Device ID Setup<br />2 - Flash Setup<br />3 - DRAM Setup<br />4 - Boot Mode Setup<br />5 - TFTP Server Setup<br />6 - Ethernet Address Setup<br />7 - Load Default<br />8 - Ethernet Interface Setup</p><p>Please select : 4</p><p>Boot Mode Setup</p><p>1 - Load Firmware<br />2 - Load Program (HEX)<br />3 - Load Program (BIN)<br />4 - Load Program (ELF)<br />5 - Update Firmware<br />6 - Main Menu</p><p>Please Select 1</p><p>Update System Paramters ............. Done</p><p>BIOS Setup</p><p>1 - Device ID Setup<br />2 - Flash Setup<br />3 - DRAM Setup<br />4 - Boot Mode Setup<br />5 - TFTP Server Setup<br />6 - Ethernet Address Setup<br />7 - Load Default<br />8 - Ethernet Interface Setup</p><p>Please select : Exit</p><p>Main Menu</p><p>1 - Load Firmware<br />2 - Load Program<br />3 - BIOS Setup<br />4 - Fdisk Utility<br />5 - Update Flash (Binary Mode)<br />6 - Update Firmware (Image Mode)<br />7 - Reboot System<br />8 - Memory Test</p><p>Please select : 7</p><p>Reboot System<br />ÿ</p><p>U-Boot 1.1.4 (Sep&nbsp; 3 2010 - 12:35:51)</p><p>AP99 (ar7241 - Virian) U-boot<br />DRAM: <br />sri<br />ar7240_ddr_initial_config(133): virian ddr1 init<br />#### TAP VALUE 1 = 0xf, 2 = 0x10 [0x0: 0x1f]<br />32 MB<br />id read 0x100000ff<br />sector count = 64<br />Flash:&nbsp; 4 MB<br />Using default environment</p><p>In:&nbsp; &nbsp; serial<br />Out:&nbsp; &nbsp;serial<br />Err:&nbsp; &nbsp;serial<br />Net:&nbsp; &nbsp;ag7240_enet_initialize...<br />No valid address in Flash. Using fixed address<br />No valid address in Flash. Using fixed address<br />Virian MDC CFG Value ==&gt; 4<br />: cfg1 0xf cfg2 0x7014<br />eth0: 00:03:7f:09:0b:ad<br />eth0 up<br />Virian MDC CFG Value ==&gt; 4<br />: cfg1 0xf cfg2 0x7214<br />eth1: 00:03:7f:09:0b:ad<br />ATHRS26: resetting s26<br />ATHRS26: s26 reset done<br />eth1 up<br />eth0, eth1<br />Autobooting in 1 seconds<br />## Booting image at 9f020000 ...<br />&nbsp; &nbsp;Uncompressing Kernel Image ... OK</p><p>Starting kernel ...</p><br /><br /><p>OpenWrt kernel loader for AR7XXX/AR9XXX<br />Copyright (C) 2011 Gabor Juhos &lt;juhosg@openwrt.org&gt;<br />Decompressing kernel...<br />failed,<br />data error!</p><p>System halted!</p><p>#################################### end console log</p><p>Whit verify_image i found this diffs:<br />checksum mismatch - attempting binary compare<br />diff 0 address 0xbfc2f800. Was 0x20 instead of 0xea<br />diff 1 address 0xbfc2f801. Was 0x02 instead of 0x3b<br />diff 2 address 0xbfc2f802. Was 0x11 instead of 0x1b<br />diff 3 address 0xbfc2f803. Was 0x07 instead of 0x8c<br />diff 4 address 0xbfc2f804. Was 0x00 instead of 0x7d<br />diff 5 address 0xbfc2f805. Was 0x00 instead of 0x44<br />diff 6 address 0xbfc2f806. Was 0x00 instead of 0x8a<br />diff 7 address 0xbfc2f807. Was 0x00 instead of 0x88<br />diff 8 address 0xbfc2f808. Was 0x00 instead of 0xe6<br />diff 9 address 0xbfc2f809. Was 0x00 instead of 0x56<br />diff 10 address 0xbfc2f80a. Was 0x00 instead of 0xa2<br />diff 11 address 0xbfc2f80b. Was 0x00 instead of 0x47<br />diff 12 address 0xbfc2f80c. Was 0x00 instead of 0xf5<br />diff 13 address 0xbfc2f80d. Was 0x00 instead of 0x39<br />diff 14 address 0xbfc2f80e. Was 0x00 instead of 0x31<br />diff 15 address 0xbfc2f80f. Was 0x00 instead of 0x52<br />diff 16 address 0xbfc2f810. Was 0x11 instead of 0x35<br />diff 17 address 0xbfc2f811. Was 0xf6 instead of 0xaa<br />diff 18 address 0xbfc2f812. Was 0x06 instead of 0xe4<br />diff 19 address 0xbfc2f813. Was 0x72 instead of 0x41<br />diff 20 address 0xbfc2f814. Was 0x11 instead of 0xf6<br />diff 21 address 0xbfc2f815. Was 0xf6 instead of 0xad<br />diff 22 address 0xbfc2f816. Was 0x06 instead of 0x50<br />diff 23 address 0xbfc2f817. Was 0x72 instead of 0xf8<br />diff 24 address 0xbfc2f818. Was 0x00 instead of 0x7d<br />diff 25 address 0xbfc2f819. Was 0x00 instead of 0x08<br />diff 26 address 0xbfc2f81a. Was 0x00 instead of 0xff<br />diff 27 address 0xbfc2f81b. Was 0x00 instead of 0x1a<br />diff 28 address 0xbfc2f81c. Was 0x00 instead of 0x86<br />diff 29 address 0xbfc2f81d. Was 0x02 instead of 0xe5<br />diff 30 address 0xbfc2f81e. Was 0x00 instead of 0x71<br />diff 31 address 0xbfc2f81f. Was 0x00 instead of 0xc8<br />diff 32 address 0xbfc2f820. Was 0x00 instead of 0x3e<br />diff 33 address 0xbfc2f821. Was 0x00 instead of 0x30<br />diff 34 address 0xbfc2f822. Was 0x00 instead of 0x34<br />diff 35 address 0xbfc2f823. Was 0x02 instead of 0xbe<br />diff 36 address 0xbfc2f824. Was 0xc0 instead of 0xb5<br />diff 37 address 0xbfc2f825. Was 0xa8 instead of 0x0c<br />diff 38 address 0xbfc2f826. Was 0xa8 instead of 0x72<br />diff 39 address 0xbfc2f827. Was 0x01 instead of 0x82<br />diff 40 address 0xbfc2f828. Was 0x80 instead of 0x13<br />diff 41 address 0xbfc2f829. Was 0x00 instead of 0xa7<br />diff 42 address 0xbfc2f82a. Was 0x20 instead of 0x3a<br />diff 43 address 0xbfc2f82b. Was 0x00 instead of 0x57<br />diff 44 address 0xbfc2f82c. Was 0x00 instead of 0xe4<br />diff 45 address 0xbfc2f82d. Was 0x40 instead of 0x6a<br />diff 46 address 0xbfc2f82e. Was 0x00 instead of 0xa9<br />diff 47 address 0xbfc2f82f. Was 0x00 instead of 0x0a<br />diff 48 address 0xbfc2f830. Was 0x02 instead of 0x67<br />diff 49 address 0xbfc2f831. Was 0x00 instead of 0xf5<br />diff 50 address 0xbfc2f832. Was 0x00 instead of 0x86<br />diff 51 address 0xbfc2f833. Was 0x00 instead of 0x28<br />diff 52 address 0xbfc2f834. Was 0x01 instead of 0x16<br />diff 53 address 0xbfc2f835. Was 0x00 instead of 0x75<br />diff 54 address 0xbfc2f836. Was 0x00 instead of 0x4b<br />diff 55 address 0xbfc2f837. Was 0x00 instead of 0x3b<br />diff 56 address 0xbfc2f838. Was 0x10 instead of 0xf5<br />diff 57 address 0xbfc2f839. Was 0x43 instead of 0xa6<br />diff 58 address 0xbfc2f83a. Was 0x80 instead of 0xd2<br />diff 59 address 0xbfc2f83b. Was 0x12 instead of 0x2f<br />diff 60 address 0xbfc2f83c. Was 0x00 instead of 0x99<br />diff 61 address 0xbfc2f83d. Was 0x00 instead of 0x44<br />diff 62 address 0xbfc2f83e. Was 0x00 instead of 0x26<br />diff 63 address 0xbfc2f83f. Was 0x00 instead of 0xb5<br />diff 64 address 0xbfc2f840. Was 0x00 instead of 0xcb<br />diff 65 address 0xbfc2f841. Was 0x00 instead of 0x60<br />diff 66 address 0xbfc2f842. Was 0x00 instead of 0xc7<br />diff 67 address 0xbfc2f843. Was 0x00 instead of 0x70<br />diff 68 address 0xbfc2f844. Was 0x00 instead of 0x7b<br />diff 69 address 0xbfc2f845. Was 0x00 instead of 0xee<br />diff 70 address 0xbfc2f846. Was 0x00 instead of 0x26<br />diff 71 address 0xbfc2f847. Was 0x00 instead of 0x80<br />diff 72 address 0xbfc2f848. Was 0x00 instead of 0x09<br />diff 73 address 0xbfc2f849. Was 0x00 instead of 0xc3<br />diff 74 address 0xbfc2f84a. Was 0x00 instead of 0xba<br />diff 75 address 0xbfc2f84b. Was 0x00 instead of 0x54<br />diff 76 address 0xbfc2f84c. Was 0x00 instead of 0x03<br />diff 77 address 0xbfc2f84d. Was 0x00 instead of 0xa7<br />diff 78 address 0xbfc2f84e. Was 0x00 instead of 0xb6<br />diff 79 address 0xbfc2f84f. Was 0x00 instead of 0x59<br />diff 80 address 0xbfc2f850. Was 0x00 instead of 0x83<br />diff 81 address 0xbfc2f851. Was 0x00 instead of 0xa5<br />diff 82 address 0xbfc2f852. Was 0x00 instead of 0xed<br />diff 83 address 0xbfc2f853. Was 0x00 instead of 0x1e<br />No more differences found.</p><p>################################## end diffs</p><p>I tried to halt the bootlader to find&nbsp; out a solution but no luck. So i end putting the flash code from u-boot in a file<br />added a main function, a Makefile, a linker script to load the code at 0xa0000000, solved all the dependencies, typedefs, etc.. and run the code in ram.<br />First to erase the sector at 0xbfc20000 ( i forgot to setup the stack pointer and the entry address for main() (not a 0xa0000000) ) and next another build to flash the bricked sector. Not easy but now is working again.</p><p>Thanks for the new config is much better.</p>									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p243057">
				<div class="post-metadata">
					<div class="post-num">Post #14</div>
					<div class="post-author">phucn</div>
					<div class="post-datetime">
						7 Aug 2014, 04:49					</div>
				</div>
				<div class="post-content content">
					<p>Hi all,</p><p>i have connected Raspberry p B+ as jtag dongle to my wzr-hp-g300nh, tjtag can detect CPU/Flash chip/Debug CPU on; but i cannot read flash since tjtag frozen (still running) at &quot;resuming processor....&quot; or &quot;halting processor...&quot;</p><p>Someone can help me to read CFE or reflash CFE boot?</p><p>Thanks</p>									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p297299">
				<div class="post-metadata">
					<div class="post-num">Post #15</div>
					<div class="post-author">moroboshi</div>
					<div class="post-datetime">
						24 Oct 2015, 21:17					</div>
				</div>
				<div class="post-content content">
					<p>While hacking on my TL-WR1043ND (see also the &quot;U-Boot mod for routers with AR9331/AR9344&quot; thread <a href="https://forum.openwrt.org/viewtopic.php?pid=297298#p297298)">https://forum.openwrt.org/viewtopic.php … 8#p297298)</a> I accidentally wrote a bad version to the flash and got annoyed that you can&#039;t easily debrick over JTAG (unless you can make the RAM initialization work and upload a RAM u-boot) and my SPI-programmer didn&#039;t seem to work for in-circuit programming (tried keeping the CPU in reset, didn&#039;t help).</p><p>Since I didn&#039;t want to unsolder the SPI I looked into adding the proper necessary flash programming support to OpenOCD and now have this (@500kHz JTAG clock, doesn&#039;t get much faster with higher clocks since with the FTDI2232 the effective speed is severly limited by the USB round-trip-time):</p><div class="codebox"><pre><code>$ telnet localhost 4444
Trying 127.0.0.1...
Connected to localhost.
Escape character is &#039;^]&#039;.
Open On-Chip Debugger
&gt; flash write_image unlock /tmp/test.bin 0xbf040000 
auto unlock enabled
read_flash_id: 1840ef
Found flash device &#039;win w25q128&#039; (ID 0x001840ef)
writing 256 bytes to flash page @0x00000000
writing 256 bytes to flash page @0x00000100
writing 256 bytes to flash page @0x00000200
writing 256 bytes to flash page @0x00000300
[...]
writing 256 bytes to flash page @0x0001e800
writing 256 bytes to flash page @0x0001e900
writing 256 bytes to flash page @0x0001ea00
writing 256 bytes to flash page @0x0001eb00
wrote 131072 bytes from file /tmp/u-boot_mod.20151021.tl-wr1043nd.bin in 1678.842163s (0.076 KiB/s)</code></pre></div><p>Necessary openocd.cfg setting:<br /></p><div class="codebox"><pre><code>flash bank ath79 ath79 0xbf000000 0x01000000 0 0 $_TARGETNAME</code></pre></div><p>diffstat:<br /></p><div class="codebox"><pre><code> Makefile.am |    1 
 ath79.c     |  807 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 drivers.c   |    2 
 spi.c       |    1 
 4 files changed, 811 insertions(+)</code></pre></div><p>Patch:<br /></p><div class="codebox"><pre><code>diff -x minidriver_imp.h -x xscale_debug.inc -x startup_tcl.inc -x startup.tcl -x openocd -x Makefile.in -x Makefile -Nru openocd-0.9.0-vanilla/src/flash/nor/ath79.c openocd-0.9.0/src/flash/nor/ath79.c
--- openocd-0.9.0-vanilla/src/flash/nor/ath79.c    1970-01-01 01:00:00.000000000 +0100
+++ openocd-0.9.0/src/flash/nor/ath79.c    2015-10-24 19:08:21.814867892 +0200
@@ -0,0 +1,807 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Antonio Borneo &lt;borneo.antonio@gmail.com&gt;       *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+/* STM Serial Memory Interface (SMI) controller is a SPI bus controller
+ * specifically designed for SPI memories.
+ * Only SPI &quot;mode 3&quot; (CPOL=1 and CPHA=1) is supported.
+ * Two working modes are available:
+ * - SW mode: the SPI is controlled by SW. Any custom commands can be sent
+ *   on the bus.
+ * - HW mode: the SPI but is under SMI control. Memory content is directly
+ *   accessible in CPU memory space. CPU can read, write and execute memory
+ *   content. */
+
+/* ATTENTION:
+ * To have flash memory mapped in CPU memory space, the SMI controller
+ * have to be in &quot;HW mode&quot;. This requires following constraints:
+ * 1) The command &quot;reset init&quot; have to initialize SMI controller and put
+ *    it in HW mode;
+ * 2) every command in this file have to return to prompt in HW mode. */
+
+#ifdef HAVE_CONFIG_H
+#include &quot;config.h&quot;
+#endif
+
+#include &quot;imp.h&quot;
+#include &quot;spi.h&quot;
+#include &lt;jtag/jtag.h&gt;
+#include &lt;helper/time_support.h&gt;
+#include &lt;target/mips32.h&gt;
+#include &lt;target/mips32_pracc.h&gt;
+
+#define ATH79_REG_FS     0
+#define ATH79_REG_CLOCK  4
+#define ATH79_REG_WRITE  8
+#define ATH79_REG_DATA  12
+
+#define AR7240_SPI_CS_DIS  0xf0000
+#define AR7240_SPI_CE_LOW  0x60000
+#define AR7240_SPI_CE_HIGH 0x60100
+
+#define SMI_READ_REG(a) (0)
+#define SMI_WRITE_REG(a, v) (0)
+
+#define READ_REG(a) (_READ_REG(a))
+#define _READ_REG(a)            \
+{                                    \
+    int __a;                        \
+    uint32_t __v;                    \
+                                    \
+    __a = target_read_u32(target, io_base + (a), &amp;__v); \
+    if (__a != ERROR_OK)            \
+        return __a;                    \
+    return __v;                            \
+}
+
+#define WRITE_REG(a, v)            \
+{                                    \
+    int __r;                        \
+                                    \
+    __r = target_write_u32(target, io_base + (a), (v)); \
+    if (__r != ERROR_OK)            \
+        return __r;                    \
+}
+
+#if 0
+static uint32_t ath79_read_reg(struct target *target, uint32_t reg) {
+    uint32_t v = 0;
+    int err = target_read_u32(target, 0xbf000000 + reg, &amp;v);
+    if (err != ERROR_OK) {
+        LOG_ERROR(&quot;target_read_u32 failed&quot;);
+    }
+    return v;
+}
+
+static void ath79_write_reg(struct target *target, uint32_t reg, uint32_t value) {
+    int err = target_write_u32(target, 0xbf000000 + reg, value);
+    if (err != ERROR_OK) {
+        LOG_ERROR(&quot;target_read_u32 failed&quot;);
+    }
+}
+#endif
+
+static int ath79_spi_bitbang_bytes(struct target *target, uint32_t io_base,
+                   int pre_deselect, int post_deselect,
+                   uint8_t *data, int len) {
+    LOG_DEBUG(&quot;ath79_spi_bitbang_bytes(%p, %08x, %d, %d, %p, %d)&quot;,
+        target, io_base, pre_deselect, post_deselect, data, len);
+    struct mips32_common *mips32 = target_to_mips32(target);
+    struct mips_ejtag *ejtag_info = &amp;mips32-&gt;ejtag_info;
+
+    uint32_t pracc_out = 0;
+
+    const int pracc_pre_post = 26;
+    const int pracc_loop_byte = 8 * 2 + 2;
+
+    struct pracc_queue_info ctx = {.max_code = pracc_pre_post + len * pracc_loop_byte};
+    uint32_t *out = malloc(len + 3);
+    memset(out, 0xa5, len + 3);
+
+    pracc_queue_init(&amp;ctx);
+    if (ctx.retval != ERROR_OK)
+        goto exit;
+
+    /* Calculate largest len given the available instruction budget. */
+    const int max_len = (PRACC_OUT_OFFSET / 4 - pracc_pre_post) / pracc_loop_byte;
+    if (len &gt; max_len) {
+        LOG_INFO(&quot;len too big: %d &gt; %d&quot;, len, max_len);
+        ctx.retval = ERROR_BUF_TOO_SMALL;
+        goto exit;
+    } else {
+        LOG_DEBUG(&quot;max len %d. len %d =&gt; max code %d&quot;, max_len, len, ctx.max_code);
+    }
+
+    pracc_add(&amp;ctx, 0, MIPS32_LUI(15, PRACC_UPPER_BASE_ADDR));  /* $15 = MIPS32_PRACC_BASE_ADDR */
+    pracc_add(&amp;ctx, 0, MIPS32_LUI(1, UPPER16(io_base)));   /* $1 = io_base */
+    if (pre_deselect) {
+        /* [$1 + FS] = 1  (enable flash io register access) */
+        pracc_add(&amp;ctx, 0, MIPS32_LUI(2, UPPER16(1)));
+        pracc_add(&amp;ctx, 0, MIPS32_ORI(2, 2, LOWER16(1)));
+        pracc_add(&amp;ctx, 0, MIPS32_SW(2, ATH79_REG_FS, 1));
+        /* deselect flash just in case */
+        pracc_add(&amp;ctx, 0, MIPS32_LUI(2, UPPER16(AR7240_SPI_CS_DIS))); /* $2 = SPI_CS_DIS */
+        pracc_add(&amp;ctx, 0, MIPS32_ORI(2, 2, LOWER16(AR7240_SPI_CS_DIS))); /* $2 = SPI_CS_DIS */
+        pracc_add(&amp;ctx, 0, MIPS32_SW(2, ATH79_REG_WRITE, 1));  /* [$1 + WRITE] = $2 */
+    }
+    /* t0 = CLOCK_LOW + 0-bit */
+    pracc_add(&amp;ctx, 0, MIPS32_LUI(8, UPPER16((AR7240_SPI_CE_LOW + 0))));
+    pracc_add(&amp;ctx, 0, MIPS32_ORI(8, 8, LOWER16((AR7240_SPI_CE_LOW + 0))));
+    /* t1 = CLOCK_LOW + 1-bit */
+    pracc_add(&amp;ctx, 0, MIPS32_LUI(9, UPPER16((AR7240_SPI_CE_LOW + 1))));
+    pracc_add(&amp;ctx, 0, MIPS32_ORI(9, 9, LOWER16((AR7240_SPI_CE_LOW + 1))));
+    /* t2 = CLOCK_HIGH + 0-bit */
+    pracc_add(&amp;ctx, 0, MIPS32_LUI(10, UPPER16((AR7240_SPI_CE_HIGH + 0))));
+    pracc_add(&amp;ctx, 0, MIPS32_ORI(10, 10, LOWER16((AR7240_SPI_CE_HIGH + 0))));
+    /* t2 = CLOCK_HIGH + 1-bit */
+    pracc_add(&amp;ctx, 0, MIPS32_LUI(11, UPPER16((AR7240_SPI_CE_HIGH + 1))));
+    pracc_add(&amp;ctx, 0, MIPS32_ORI(11, 11, LOWER16((AR7240_SPI_CE_HIGH + 1))));
+
+    for (int i = 0; i &lt; len; i++) {
+        uint8_t x = data[i];
+        LOG_DEBUG(&quot;%d: generating code for %02x&quot;, i, x);
+        for (int j=0; j&lt;8; j++) {
+            int bit = ((x &lt;&lt; j) &amp; 0x80) == 0x80;
+
+            LOG_DEBUG(&quot;  %d: generating code for bit %d&quot;, j, bit);
+            if (bit) {
+                /* [$1 + WRITE] = t1 */
+                pracc_add(&amp;ctx, 0, MIPS32_SW(9, ATH79_REG_WRITE, 1));
+                /* [$1 + WRITE] = t3 */
+                pracc_add(&amp;ctx, 0, MIPS32_SW(11, ATH79_REG_WRITE, 1));
+            } else {
+                /* [$1 + WRITE] = t0 */
+                pracc_add(&amp;ctx, 0, MIPS32_SW(8, ATH79_REG_WRITE, 1));
+                /* [$1 + WRITE] = t2 */
+                pracc_add(&amp;ctx, 0, MIPS32_SW(10, ATH79_REG_WRITE, 1));
+            }
+        }
+        if (i % 4 == 3) {
+            /* $3 = [$1 + DATA] */
+            pracc_add(&amp;ctx, 0, MIPS32_LW(3, ATH79_REG_DATA, 1)); /* $3 = [$1 + DATA] */
+            /* [OUTi] = $3 */
+            pracc_add(&amp;ctx, MIPS32_PRACC_PARAM_OUT + pracc_out,
+                    MIPS32_SW(3, PRACC_OUT_OFFSET + pracc_out, 15));
+            pracc_out += 4;
+        }
+    }
+    if (len &amp; 3) { /* not a multiple of 4 bytes */
+        /* $3 = [$1 + DATA] */
+        pracc_add(&amp;ctx, 0, MIPS32_LW(3, ATH79_REG_DATA, 1)); /* $3 = [$1 + DATA] */
+        /* [OUTi] = $3 */
+        pracc_add(&amp;ctx, MIPS32_PRACC_PARAM_OUT + pracc_out,
+                MIPS32_SW(3, PRACC_OUT_OFFSET + pracc_out, 15));
+        pracc_out += 4;
+    }
+
+    if (post_deselect) {
+        pracc_add(&amp;ctx, 0, MIPS32_LUI(2, UPPER16(AR7240_SPI_CS_DIS))); /* $2 = SPI_CS_DIS */
+        pracc_add(&amp;ctx, 0, MIPS32_ORI(2, 2, LOWER16(AR7240_SPI_CS_DIS))); /* $2 = SPI_CS_DIS */
+        pracc_add(&amp;ctx, 0, MIPS32_SW(2, ATH79_REG_WRITE, 1));  /* [$1 + WRITE] = $2 */
+
+        /* [$1 + FS] = 0  (disable flash io register access) */
+        pracc_add(&amp;ctx, 0, MIPS32_XORI(2, 2, 0));
+        pracc_add(&amp;ctx, 0, MIPS32_SW(2, ATH79_REG_FS, 1));
+    }
+
+    /* common pracc epilogue */
+    pracc_add(&amp;ctx, 0, MIPS32_B(NEG16(ctx.code_count + 1)));            /* jump to start */
+    pracc_add(&amp;ctx, 0, MIPS32_MFC0(15, 31, 0));                    /* restore $15 from DeSave */
+
+    LOG_DEBUG(&quot;Assembled %d instructions, %d stores:&quot;, ctx.code_count, ctx.store_count);
+    for (int i = 0; i &lt; ctx.code_count; i++) {
+        LOG_DEBUG(&quot;%08x&quot;, ctx.pracc_list[i]);
+    }
+
+    ctx.retval = mips32_pracc_queue_exec(ejtag_info, &amp;ctx, out);
+    if (ctx.retval != ERROR_OK)
+        goto exit;
+
+    int pracc_words = pracc_out / 4;
+    if (len &amp; 3) { /* not a multiple of 4 bytes */
+        /* Need to realign last word. */
+        out[pracc_words - 1] &lt;&lt;= 8 * (4 - len);
+    }
+    if (1234 != ntohl(1234)) {
+        /* byteswap buffer */
+        for (int i = 0; i &lt; pracc_words; i++) {
+            out[i] = ntohl(out[i]);
+        }
+    }
+    for (int i = 0; i &lt; len; i++) {
+        LOG_DEBUG(&quot;bitbang %02x =&gt; %02x&quot;,
+            data[i], ((uint8_t*)out)[i]);
+    }
+    memcpy(data, out, len);
+
+exit:
+    if (ctx.retval != ERROR_OK) {
+        memset(data, 0x5a, len);
+    }
+    if (out != NULL)
+        free(out);
+    pracc_queue_free(&amp;ctx);
+    return ctx.retval;
+}
+
+#define SMI_POLL_TFF(timeout)
+#define SMI_SET_SW_MODE()
+#define SMI_SET_HWWB_MODE()
+#define SMI_SET_HW_MODE()
+#define SMI_CLEAR_TFF()
+
+#define SMI_BANK_SIZE      (0x01000000)
+
+#define SMI_CR1 (0x00) /* Control register 1 */
+#define SMI_CR2 (0x04) /* Control register 2 */
+#define SMI_SR  (0x08) /* Status register */
+#define SMI_TR  (0x0c) /* TX */
+#define SMI_RR  (0x10) /* RX */
+
+/* fields in SMI_CR1 */
+#define SMI_SW_MODE       0x10000000 /* set to enable SW Mode */
+#define SMI_WB_MODE       0x20000000 /* Write Burst Mode */
+
+/* fields in SMI_CR2 */
+#define SMI_TX_LEN_1      0x00000001 /* data length = 1 byte */
+#define SMI_TX_LEN_4      0x00000004 /* data length = 4 byte */
+#define SMI_RX_LEN_3      0x00000030 /* data length = 3 byte */
+#define SMI_SEND          0x00000080 /* Send data */
+#define SMI_RSR           0x00000400 /* reads status reg */
+#define SMI_WE            0x00000800 /* Write Enable */
+#define SMI_SEL_BANK0     0x00000000 /* Select Bank0 */
+#define SMI_SEL_BANK1     0x00001000 /* Select Bank1 */
+#define SMI_SEL_BANK2     0x00002000 /* Select Bank2 */
+#define SMI_SEL_BANK3     0x00003000 /* Select Bank3 */
+
+/* fields in SMI_SR */
+#define SMI_TFF           0x00000100 /* Transfer Finished Flag */
+
+/* Commands */
+#define SMI_READ_ID       0x0000009F /* Read Flash Identification */
+
+/* Timeout in ms */
+#define SMI_CMD_TIMEOUT   (100)
+#define SMI_PROBE_TIMEOUT (100)
+#define SMI_MAX_TIMEOUT  (3000)
+
+struct ath79_flash_bank {
+    int probed;
+    uint32_t io_base;
+    uint32_t bank_num;
+    const struct flash_device *dev;
+};
+
+struct ath79_target {
+    char *name;
+    uint32_t tap_idcode;
+    uint32_t smi_base;
+    uint32_t io_base;
+};
+
+static const struct ath79_target target_devices[] = {
+    /* name,          tap_idcode, smi_base,   io_base */
+    { &quot;ATH79&quot;,        0x00000001, 0xbf000000, 0xbf000000 },
+    { NULL,           0,          0,          0 }
+};
+
+FLASH_BANK_COMMAND_HANDLER(ath79_flash_bank_command)
+{
+    struct ath79_flash_bank *ath79_info;
+
+    LOG_DEBUG(&quot;%s&quot;, __func__);
+
+    if (CMD_ARGC &lt; 6)
+        return ERROR_COMMAND_SYNTAX_ERROR;
+
+    ath79_info = malloc(sizeof(struct ath79_flash_bank));
+    if (ath79_info == NULL) {
+        LOG_ERROR(&quot;not enough memory&quot;);
+        return ERROR_FAIL;
+    }
+
+    bank-&gt;driver_priv = ath79_info;
+    ath79_info-&gt;probed = 0;
+
+    return ERROR_OK;
+}
+
+/* Read the status register of the external SPI flash chip.
+ * The operation is triggered by setting SMI_RSR bit.
+ * SMI sends the proper SPI command (0x05) and returns value in SMI_SR */
+static int read_status_reg(struct flash_bank *bank, uint32_t *status)
+{
+    struct target *target = bank-&gt;target;
+    struct ath79_flash_bank *ath79_info = bank-&gt;driver_priv;
+    uint32_t io_base = ath79_info-&gt;io_base;
+
+    uint8_t spi_bytes[] = {SPIFLASH_READ_STATUS, 0};
+
+    /* Send SPI command &quot;read STATUS&quot; */
+    int retval = ath79_spi_bitbang_bytes(
+        target, io_base, 1, 1, spi_bytes, sizeof(spi_bytes));
+
+    *status = spi_bytes[1];
+
+    return retval;
+}
+
+/* check for WIP (write in progress) bit in status register */
+/* timeout in ms */
+static int wait_till_ready(struct flash_bank *bank, int timeout)
+{
+    uint32_t status;
+    int retval;
+    long long endtime;
+
+    endtime = timeval_ms() + timeout;
+    do {
+        /* read flash status register */
+        retval = read_status_reg(bank, &amp;status);
+        if (retval != ERROR_OK)
+            return retval;
+
+        if ((status &amp; SPIFLASH_BSY_BIT) == 0)
+            return ERROR_OK;
+        alive_sleep(1);
+    } while (timeval_ms() &lt; endtime);
+
+    LOG_ERROR(&quot;timeout&quot;);
+    return ERROR_FAIL;
+}
+
+/* Send &quot;write enable&quot; command to SPI flash chip.
+ * The operation is triggered by setting SMI_WE bit, and SMI sends
+ * the proper SPI command (0x06) */
+static int smi_write_enable(struct flash_bank *bank)
+{
+    struct target *target = bank-&gt;target;
+    struct ath79_flash_bank *ath79_info = bank-&gt;driver_priv;
+    uint32_t io_base = ath79_info-&gt;io_base;
+    uint32_t status;
+    int retval;
+
+    uint8_t spi_bytes[] = {SPIFLASH_WRITE_ENABLE};
+
+    /* Send SPI command &quot;write enable&quot; */
+    retval = ath79_spi_bitbang_bytes(
+        target, io_base, 1, 1, spi_bytes, sizeof(spi_bytes));
+    if (retval != ERROR_OK)
+        return retval;
+
+    /* read flash status register */
+    retval = read_status_reg(bank, &amp;status);
+    if (retval != ERROR_OK)
+        return retval;
+
+    /* Check write enabled */
+    if ((status &amp; SPIFLASH_WE_BIT) == 0) {
+        LOG_ERROR(&quot;Cannot enable write to flash. Status=0x%08&quot; PRIx32, status);
+        return ERROR_FAIL;
+    }
+
+    return ERROR_OK;
+}
+
+static int erase_command(struct flash_bank *bank, int sector)
+{
+    struct ath79_flash_bank *ath79_info = bank-&gt;driver_priv;
+    struct target *target = bank-&gt;target;
+    uint32_t io_base = ath79_info-&gt;io_base;
+    uint32_t offset = bank-&gt;sectors[sector].offset;
+
+    uint8_t spi_bytes[] = {
+        ath79_info-&gt;dev-&gt;erase_cmd,
+        offset &gt;&gt; 16,
+        offset &gt;&gt; 8,
+        offset
+    };
+
+    /* bitbang command */
+    return ath79_spi_bitbang_bytes(
+        target, io_base, 1, 1, spi_bytes, sizeof(spi_bytes));
+}
+
+static int smi_erase_sector(struct flash_bank *bank, int sector)
+{
+    int retval;
+
+    retval = smi_write_enable(bank);
+    if (retval != ERROR_OK)
+        return retval;
+
+    /* send SPI command &quot;block erase&quot; */
+    retval = erase_command(bank, sector);
+    if (retval != ERROR_OK)
+        return retval;
+
+    /* poll WIP for end of self timed Sector Erase cycle */
+    retval = wait_till_ready(bank, SMI_MAX_TIMEOUT);
+    if (retval != ERROR_OK)
+        return retval;
+
+    return ERROR_OK;
+}
+
+static int ath79_erase(struct flash_bank *bank, int first, int last)
+{
+    struct target *target = bank-&gt;target;
+    struct ath79_flash_bank *ath79_info = bank-&gt;driver_priv;
+    int retval = ERROR_OK;
+    int sector;
+
+    LOG_DEBUG(&quot;%s: from sector %d to sector %d&quot;, __func__, first, last);
+
+    if (target-&gt;state != TARGET_HALTED) {
+        LOG_ERROR(&quot;Target not halted&quot;);
+        return ERROR_TARGET_NOT_HALTED;
+    }
+
+    if ((first &lt; 0) || (last &lt; first) || (last &gt;= bank-&gt;num_sectors)) {
+        LOG_ERROR(&quot;Flash sector invalid&quot;);
+        return ERROR_FLASH_SECTOR_INVALID;
+    }
+
+    if (!(ath79_info-&gt;probed)) {
+        LOG_ERROR(&quot;Flash bank not probed&quot;);
+        return ERROR_FLASH_BANK_NOT_PROBED;
+    }
+
+    for (sector = first; sector &lt;= last; sector++) {
+        if (bank-&gt;sectors[sector].is_protected) {
+            LOG_ERROR(&quot;Flash sector %d protected&quot;, sector);
+            return ERROR_FAIL;
+        }
+    }
+
+    for (sector = first; sector &lt;= last; sector++) {
+        retval = smi_erase_sector(bank, sector);
+        if (retval != ERROR_OK)
+            break;
+        keep_alive();
+    }
+
+    /* Switch to HW mode before return to prompt */
+    SMI_SET_HW_MODE();
+    return retval;
+}
+
+static int ath79_protect(struct flash_bank *bank, int set,
+    int first, int last)
+{
+    int sector;
+
+    for (sector = first; sector &lt;= last; sector++)
+        bank-&gt;sectors[sector].is_protected = set;
+    return ERROR_OK;
+}
+
+static int ath79_write_page(struct flash_bank *bank, const uint8_t *buffer,
+    uint32_t address, uint32_t len)
+{
+    uint8_t spi_page_buf[0x100];
+    struct ath79_flash_bank *ath79_info = bank-&gt;driver_priv;
+    struct target *target = bank-&gt;target;
+    uint32_t io_base = ath79_info-&gt;io_base;
+    uint32_t written = 0;
+    uint8_t spi_cmd[] = {
+        SPIFLASH_PAGE_PROGRAM,
+        address &gt;&gt; 16,
+        address &gt;&gt; 8,
+        address,
+    };
+    int retval;
+
+    if (address &amp; 0xff) {
+        LOG_ERROR(&quot;ath79_write_page: unaligned write address: %08x\n&quot;, address);
+        return ERROR_FAIL;
+    }
+
+    if (len &gt; sizeof(spi_page_buf)) {
+        LOG_ERROR(&quot;ath79_write_page: length bigger than page size %ld: %d\n&quot;,
+            sizeof(spi_page_buf), len);
+        return ERROR_FAIL;
+    }
+
+    uint32_t i;
+    for (i = 0; i &lt; len; i++) {
+        if (buffer[i] != 0xff)
+            break;
+    }
+    if (i == len)  /* all 0xff, no need to program. */
+        return ERROR_OK;
+
+    address -= ath79_info-&gt;io_base;
+
+    LOG_INFO(&quot;writing %d bytes to flash page @0x%08x&quot;, len, address);
+
+    memcpy(spi_page_buf, buffer, len);
+
+    /* unlock writes */
+    retval = smi_write_enable(bank);
+    if (retval != ERROR_OK)
+        return retval;
+
+    /* bitbang command */
+    retval = ath79_spi_bitbang_bytes(
+        target, io_base, 1, 0, spi_cmd, sizeof(spi_cmd));
+    if (retval != ERROR_OK)
+        return retval;
+
+    /* Length limit derived from pracc code size limit */
+    const uint32_t spi_max_len = 112;
+
+    while (len &gt; spi_max_len) {
+        /* write blocks with len limited by pracc code size */
+        retval = ath79_spi_bitbang_bytes(
+            target, io_base, 0, 0, &amp;spi_page_buf[written], spi_max_len);
+        if (retval != ERROR_OK)
+            return retval;
+
+        written += spi_max_len;
+        len -= spi_max_len;
+    }
+
+    /* write final block of data */
+    return ath79_spi_bitbang_bytes(
+        target, io_base, 0, 1, &amp;spi_page_buf[written], len);
+}
+
+static int smi_write_buffer(struct flash_bank *bank, const uint8_t *buffer,
+    uint32_t address, uint32_t len)
+{
+    int retval;
+
+    LOG_DEBUG(&quot;%s: address=0x%08&quot; PRIx32 &quot; len=0x%08&quot; PRIx32,
+            __func__, address, len);
+
+    while (len &gt; 0) {
+        const uint32_t page_size = 0x100;
+
+        /* Page size is 256 bytes */
+        int page_len = len &gt; 0x100 ? 0x100 : len;
+        retval = ath79_write_page(
+            bank, buffer, address, page_len);
+        if (retval != ERROR_OK)
+            return retval;
+
+        buffer += page_size;
+        address += page_size;
+        len -= page_len;
+    }
+
+    return ERROR_OK;
+}
+
+static int ath79_write(struct flash_bank *bank, const uint8_t *buffer,
+    uint32_t offset, uint32_t count)
+{
+    struct target *target = bank-&gt;target;
+    struct ath79_flash_bank *ath79_info = bank-&gt;driver_priv;
+    int sector;
+
+    LOG_DEBUG(&quot;%s: offset=0x%08&quot; PRIx32 &quot; count=0x%08&quot; PRIx32,
+        __func__, offset, count);
+
+    if (target-&gt;state != TARGET_HALTED) {
+        LOG_ERROR(&quot;Target not halted&quot;);
+        return ERROR_TARGET_NOT_HALTED;
+    }
+
+    if (offset + count &gt; ath79_info-&gt;dev-&gt;size_in_bytes) {
+        LOG_WARNING(&quot;Write pasts end of flash. Extra data discarded.&quot;);
+        count = ath79_info-&gt;dev-&gt;size_in_bytes - offset;
+    }
+
+    /* Check sector protection */
+    for (sector = 0; sector &lt; bank-&gt;num_sectors; sector++) {
+        /* Start offset in or before this sector? */
+        /* End offset in or behind this sector? */
+        if ((offset &lt;
+                (bank-&gt;sectors[sector].offset + bank-&gt;sectors[sector].size))
+            &amp;&amp; ((offset + count - 1) &gt;= bank-&gt;sectors[sector].offset)
+            &amp;&amp; bank-&gt;sectors[sector].is_protected) {
+            LOG_ERROR(&quot;Flash sector %d protected&quot;, sector);
+            return ERROR_FAIL;
+        }
+    }
+
+    return smi_write_buffer(bank, buffer, bank-&gt;base + offset, count);
+}
+
+/* Return ID of flash device */
+/* On exit, SW mode is kept */
+static int read_flash_id(struct flash_bank *bank, uint32_t *id)
+{
+    struct target *target = bank-&gt;target;
+    struct ath79_flash_bank *ath79_info = bank-&gt;driver_priv;
+    uint32_t io_base = ath79_info-&gt;io_base;
+    int retval;
+    uint8_t spi_bytes[] = {SPIFLASH_READ_ID, 0, 0, 0, 0, 0, 0, 0};
+    /* Read 8 bytes @0xbf060000 */
+    uint8_t spi_test[] = {3, 6, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0};
+    uint8_t spi_buf[12];
+
+    if (target-&gt;state != TARGET_HALTED) {
+        LOG_ERROR(&quot;Target not halted&quot;);
+        return ERROR_TARGET_NOT_HALTED;
+    }
+    memcpy(spi_buf, spi_test, sizeof(spi_test));
+    ath79_spi_bitbang_bytes(target, io_base, 1, 1,
+            spi_buf, 5);
+
+    memcpy(spi_buf, spi_test, sizeof(spi_test));
+    ath79_spi_bitbang_bytes(target, io_base, 1, 1,
+            spi_buf, 6);
+
+    memcpy(spi_buf, spi_test, sizeof(spi_test));
+    ath79_spi_bitbang_bytes(target, io_base, 1, 1,
+            spi_buf, 7);
+
+    memcpy(spi_buf, spi_test, sizeof(spi_test));
+    ath79_spi_bitbang_bytes(target, io_base, 1, 1,
+            spi_buf, 8);
+
+    memcpy(spi_buf, spi_test, sizeof(spi_test));
+    ath79_spi_bitbang_bytes(target, io_base, 1, 1,
+            spi_buf, 9);
+
+    memcpy(spi_buf, spi_test, sizeof(spi_test));
+    ath79_spi_bitbang_bytes(target, io_base, 1, 1,
+            spi_buf, 10);
+
+    memcpy(spi_buf, spi_test, sizeof(spi_test));
+    ath79_spi_bitbang_bytes(target, io_base, 1, 1,
+            spi_buf, 11);
+
+    memcpy(spi_buf, spi_test, sizeof(spi_test));
+    ath79_spi_bitbang_bytes(target, io_base, 1, 1,
+            spi_buf, 12);
+
+    /* Send SPI command &quot;read ID&quot; */
+    retval = ath79_spi_bitbang_bytes(target, io_base, 1, 1,
+                spi_bytes, sizeof(spi_bytes));
+    if (retval != ERROR_OK)
+        return retval;
+
+    *id = (spi_bytes[1] &lt;&lt; 0)
+        | (spi_bytes[2] &lt;&lt; 8)
+        | (spi_bytes[3] &lt;&lt; 16);
+    LOG_ERROR(&quot;read_flash_id: %06x&quot;, *id);
+
+    return ERROR_OK;
+}
+
+static int ath79_probe(struct flash_bank *bank)
+{
+    struct target *target = bank-&gt;target;
+    struct ath79_flash_bank *ath79_info = bank-&gt;driver_priv;
+    uint32_t io_base;
+    struct flash_sector *sectors;
+    uint32_t id = 0; /* silence uninitialized warning */
+    const struct ath79_target *target_device;
+    int retval;
+
+    if (ath79_info-&gt;probed)
+        free(bank-&gt;sectors);
+    ath79_info-&gt;probed = 0;
+
+    for (target_device = target_devices ; target_device-&gt;name ; ++target_device)
+        if (target_device-&gt;tap_idcode == target-&gt;tap-&gt;idcode)
+            break;
+    if (!target_device-&gt;name) {
+        LOG_ERROR(&quot;Device ID 0x%&quot; PRIx32 &quot; is not known as SMI capable&quot;,
+                target-&gt;tap-&gt;idcode);
+        return ERROR_FAIL;
+    }
+
+    io_base = target_device-&gt;io_base;
+    ath79_info-&gt;io_base = io_base;
+
+    LOG_DEBUG(&quot;Valid SMI on device %s at address 0x%&quot; PRIx32,
+        target_device-&gt;name, bank-&gt;base);
+
+    /* read and decode flash ID; returns in SW mode */
+    retval = read_flash_id(bank, &amp;id);
+    SMI_SET_HW_MODE();
+    if (retval != ERROR_OK)
+        return retval;
+
+    ath79_info-&gt;dev = NULL;
+    for (const struct flash_device *p = flash_devices; p-&gt;name ; p++)
+        if (p-&gt;device_id == id) {
+            ath79_info-&gt;dev = p;
+            break;
+        }
+
+    if (!ath79_info-&gt;dev) {
+        LOG_ERROR(&quot;Unknown flash device (ID 0x%08&quot; PRIx32 &quot;)&quot;, id);
+        return ERROR_FAIL;
+    }
+
+    LOG_INFO(&quot;Found flash device \&#039;%s\&#039; (ID 0x%08&quot; PRIx32 &quot;)&quot;,
+        ath79_info-&gt;dev-&gt;name, ath79_info-&gt;dev-&gt;device_id);
+
+    /* Set correct size value */
+    bank-&gt;size = ath79_info-&gt;dev-&gt;size_in_bytes;
+
+    /* create and fill sectors array */
+    bank-&gt;num_sectors =
+        ath79_info-&gt;dev-&gt;size_in_bytes / ath79_info-&gt;dev-&gt;sectorsize;
+    sectors = malloc(sizeof(struct flash_sector) * bank-&gt;num_sectors);
+    if (sectors == NULL) {
+        LOG_ERROR(&quot;not enough memory&quot;);
+        return ERROR_FAIL;
+    }
+
+    for (int sector = 0; sector &lt; bank-&gt;num_sectors; sector++) {
+        sectors[sector].offset = sector * ath79_info-&gt;dev-&gt;sectorsize;
+        sectors[sector].size = ath79_info-&gt;dev-&gt;sectorsize;
+        sectors[sector].is_erased = -1;
+        sectors[sector].is_protected = 1;
+    }
+
+    bank-&gt;sectors = sectors;
+    ath79_info-&gt;probed = 1;
+    return ERROR_OK;
+}
+
+static int ath79_auto_probe(struct flash_bank *bank)
+{
+    struct ath79_flash_bank *ath79_info = bank-&gt;driver_priv;
+    if (ath79_info-&gt;probed)
+        return ERROR_OK;
+    return ath79_probe(bank);
+}
+
+static int ath79_protect_check(struct flash_bank *bank)
+{
+    /* Nothing to do. Protection is only handled in SW. */
+    return ERROR_OK;
+}
+
+static int get_ath79_info(struct flash_bank *bank, char *buf, int buf_size)
+{
+    struct ath79_flash_bank *ath79_info = bank-&gt;driver_priv;
+
+    if (!(ath79_info-&gt;probed)) {
+        snprintf(buf, buf_size,
+            &quot;\nSMI flash bank not probed yet\n&quot;);
+        return ERROR_OK;
+    }
+
+    snprintf(buf, buf_size, &quot;\nSMI flash information:\n&quot;
+        &quot;  Device \&#039;%s\&#039; (ID 0x%08&quot; PRIx32 &quot;)\n&quot;,
+        ath79_info-&gt;dev-&gt;name, ath79_info-&gt;dev-&gt;device_id);
+
+    return ERROR_OK;
+}
+
+struct flash_driver ath79_flash = {
+    .name = &quot;ath79&quot;,
+    .flash_bank_command = ath79_flash_bank_command,
+    .erase = ath79_erase,
+    .protect = ath79_protect,
+    .write = ath79_write,
+    .read = default_flash_read,
+    .probe = ath79_probe,
+    .auto_probe = ath79_auto_probe,
+    .erase_check = default_flash_blank_check,
+    .protect_check = ath79_protect_check,
+    .info = get_ath79_info,
+};
diff -x minidriver_imp.h -x xscale_debug.inc -x startup_tcl.inc -x startup.tcl -x openocd -x Makefile.in -x Makefile -Nru openocd-0.9.0-vanilla/src/flash/nor/drivers.c openocd-0.9.0/src/flash/nor/drivers.c
--- openocd-0.9.0-vanilla/src/flash/nor/drivers.c    2015-04-24 17:09:54.000000000 +0200
+++ openocd-0.9.0/src/flash/nor/drivers.c    2015-10-23 09:15:35.390154487 +0200
@@ -22,6 +22,7 @@
 #endif
 #include &quot;imp.h&quot;
 
+extern struct flash_driver ath79_flash;
 extern struct flash_driver lpc2000_flash;
 extern struct flash_driver lpc288x_flash;
 extern struct flash_driver lpc2900_flash;
@@ -65,6 +66,7 @@
  * @todo Make this dynamically extendable with loadable modules.
  */
 static struct flash_driver *flash_drivers[] = {
+    &amp;ath79_flash,
     &amp;lpc2000_flash,
     &amp;lpc288x_flash,
     &amp;lpc2900_flash,
diff -x minidriver_imp.h -x xscale_debug.inc -x startup_tcl.inc -x startup.tcl -x openocd -x Makefile.in -x Makefile -Nru openocd-0.9.0-vanilla/src/flash/nor/Makefile.am openocd-0.9.0/src/flash/nor/Makefile.am
--- openocd-0.9.0-vanilla/src/flash/nor/Makefile.am    2015-04-24 17:09:54.000000000 +0200
+++ openocd-0.9.0/src/flash/nor/Makefile.am    2015-10-23 09:14:52.291677642 +0200
@@ -29,6 +29,7 @@
     pic32mx.c \
     spi.c \
     stmsmi.c \
+    ath79.c \
     stellaris.c \
     stm32f1x.c \
     stm32f2x.c \
diff -x minidriver_imp.h -x xscale_debug.inc -x startup_tcl.inc -x startup.tcl -x openocd -x Makefile.in -x Makefile -Nru openocd-0.9.0-vanilla/src/flash/nor/spi.c openocd-0.9.0/src/flash/nor/spi.c
--- openocd-0.9.0-vanilla/src/flash/nor/spi.c    2015-04-24 17:09:54.000000000 +0200
+++ openocd-0.9.0/src/flash/nor/spi.c    2015-10-23 10:03:08.459651011 +0200
@@ -74,6 +74,7 @@
     FLASH_ID(&quot;win w25q32fv&quot;,   0xd8, 0xc7, 0x001640ef, 0x100, 0x10000, 0x400000),
     FLASH_ID(&quot;win w25q32dw&quot;,   0xd8, 0xc7, 0x001660ef, 0x100, 0x10000, 0x400000),
     FLASH_ID(&quot;win w25q64cv&quot;,   0xd8, 0xc7, 0x001740ef, 0x100, 0x10000, 0x800000),
+    FLASH_ID(&quot;win w25q128&quot;,    0xd8, 0xc7, 0x001840ef, 0x100, 0x10000, 0x1000000),
     FLASH_ID(&quot;gd gd25q20&quot;,     0x20, 0xc7, 0x00c84012, 0x100, 0x1000, 0x80000),
     FLASH_ID(NULL,             0,    0,       0,          0,     0,       0)
 };</code></pre></div>									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p304018">
				<div class="post-metadata">
					<div class="post-num">Post #16</div>
					<div class="post-author">Deoptim</div>
					<div class="post-datetime">
						17 Dec 2015, 18:11					</div>
				</div>
				<div class="post-content content">
					<p>When make me have error:<br /></p><div class="quotebox"><blockquote><p>...<br />libtool: compile:&nbsp; gcc -std=gnu99 -DHAVE_CONFIG_H -I. -I../../.. -I../../../src -I../../../src -I../../../src/helper -DPKGDATADIR=\&quot;/usr/local/share/openocd\&quot; -DBINDIR=\&quot;/usr/local/bin\&quot; -I../../../jimtcl -I../../../jimtcl -g -O2 -Wall -Wstrict-prototypes -Wformat-security -Wshadow -Wextra -Wno-unused-parameter -Wbad-function-cast -Wcast-align -Wredundant-decls -Werror -MT ath79.lo -MD -MP -MF .deps/ath79.Tpo -c ath79.c -o ath79.o<br />ath79.c: In function &#039;ath79_write_page&#039;:<br /><strong><span style="color: #FF0000">ath79.c:516:9: error</span>: format &#039;%ld&#039; expects argument of type &#039;long int&#039;, but argument 6 has type &#039;unsigned int&#039; [-Werror=format=]<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LOG_ERROR(&quot;ath79_write_page: length bigger than page size %ld: %d\n&quot;,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^<br />cc1: all warnings being treated as errors<br />make[5]: *** [ath79.lo] Error 1<br />make[5]: Leaving directory `/home/xubuntu/openocd/src/flash/nor&#039;<br />make[4]: *** [all-recursive] Error 1<br />make[4]: Leaving directory `/home/xubuntu/openocd/src/flash&#039;<br />make[3]: *** [all-recursive] Error 1<br />make[3]: Leaving directory `/home/xubuntu/openocd/src&#039;<br />make[2]: *** [all] Error 2<br />make[2]: Leaving directory `/home/xubuntu/openocd/src&#039;<br />make[1]: *** [all-recursive] Error 1<br />make[1]: Leaving directory `/home/xubuntu/openocd&#039;<br />make: *** [all] Error 2</strong><br />xubuntu@xubuntu:~/openocd$</p></blockquote></div>									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p314615">
				<div class="post-metadata">
					<div class="post-num">Post #17</div>
					<div class="post-author">Deoptim</div>
					<div class="post-datetime">
						13 Mar 2016, 08:38					</div>
				</div>
				<div class="post-content content">
					<p><a href="https://wiki.openwrt.org/doc/recipes/debrick.ath79.using.jtag">https://wiki.openwrt.org/doc/recipes/de … using.jtag</a><br />Instruction, thx <strong>moroboshi</strong></p>									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p320241">
				<div class="post-metadata">
					<div class="post-num">Post #18</div>
					<div class="post-author">freezer2k</div>
					<div class="post-datetime">
						18 Apr 2016, 18:37					</div>
				</div>
				<div class="post-content content">
					<p>Hi, </p><p>Awesome work.</p><p>Successfully unbricked my TL-WDR3600, vastly based on your code/instructions, moroboshi! Thanks for sharing. </p><p>Wrote down my adventure here:<br /><a href="https://forum.openwrt.org/viewtopic.php?pid=320240#p320240">https://forum.openwrt.org/viewtopic.php … 40#p320240</a></p><p>Please note my remarks about the write_image &#039;erase&#039; option! Not sure if this is required, but seems like a good idea?</p><p>Otherwise, after fiddling with the (E)JTAG connection for quite a while, the target config and ath79.patch worked unmodified for this router, guessing this will be the case for a lot of Routers built upon these SoCs! <img src="https://forum.openwrt.org/img/smilies/smile.png" width="15" height="15" alt="smile" /></p><br /><p>PS: Started out using the Rpi1 for the JTAG interface, very very slow read/write operations. <br />The Rpi3 was still very slow,&nbsp; but about 4times faster (even though its single-threaded). Flashing uboot via the Pi1 will probably take about an hour. I want some fast Odroid for this stuff.</p>											<p class="post-edited">(Last edited by <strong>freezer2k</strong> on 18 Apr 2016, 18:47)</p>
									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p320259">
				<div class="post-metadata">
					<div class="post-num">Post #19</div>
					<div class="post-author">moroboshi</div>
					<div class="post-datetime">
						18 Apr 2016, 20:08					</div>
				</div>
				<div class="post-content content">
					<div class="quotebox"><cite>freezer2k wrote:</cite><blockquote><p>Hi, <br />PS: Started out using the Rpi1 for the JTAG interface, very very slow read/write operations. <br />The Rpi3 was still very slow,&nbsp; but about 4times faster (even though its single-threaded). Flashing uboot via the Pi1 will probably take about an hour. I want some fast Odroid for this stuff.</p></blockquote></div><p>I was using a USB FT2232 to JTAG adapter.<br />Rpi1 should be plenty fast as well, I&#039;d suspect the JTAG interface driver to be not very optimized?<br />I didn&#039;t try compiling on 32bit, so that explains the printf format issue.</p>									</div>
			</article>

			
		
	
			<div class="notice minor">
			<p>The discussion might have continued from here.</p>
		</div>
	
	<div class="pagination"><div class="pagination-number">Page 1 of 1</div><nav><ul><li class="pagination-current"><span>1</span></li></ul></nav></div>
</main>

</div>


<!-- Created in a hurry and not indicative of usual code quality. Here's a number: 0 -->

</body>
</html>