<!DOCTYPE html>
<html lang="en-US">
<head>

	<title>OpenWrt Forum Archive</title>

	<meta charset="UTF-8">

	<meta http-equiv="X-UA-Compatible" content="IE=edge">

	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="assets/css/common.css">

</head>
<body>

<div class="container">

<header class="main-header">
	<h1 class="logo"><a href="index.html"><img src="assets/img/logo.png" width="376" height="88" alt="OpenWrt Forum Archive"></a></h1>
</header>

<aside>
	<p>This is a read-only archive of the old OpenWrt forum. The current OpenWrt forum resides at <a href="https://forum.openwrt.org/">https://forum.openwrt.org/</a>.</p>
	<p class="minor">In May 2018, the OpenWrt forum suffered a total data loss. This archive is an effort to restore and make available as much content as possible. Content may be missing or not representing the latest edited version.</p>
</aside>

<main>
	<header>
		<h1><span class="minor">Topic:</span> 32MB Flash MR13U (AR9331) and BB 14.07 [SOLVED]</h1>
	</header>
	<div class="notice minor">
		<p>
			The content of this topic has been archived
							on 1 Apr 2018.
										There are no obvious gaps in this topic, but there may still be some posts missing at the end.
					</p>
	</div>

	<div class="pagination"><div class="pagination-number">Page 1 of 1</div><nav><ul><li class="pagination-current"><span>1</span></li></ul></nav></div>
			
		
		
			<article class="post" id="p257174">
				<div class="post-metadata">
					<div class="post-num">Post #1</div>
					<div class="post-author">Sorlas</div>
					<div class="post-datetime">
						10 Dec 2014, 11:11					</div>
				</div>
				<div class="post-content content">
					<p>Hello,</p><p>I bought an TP-LINK MR13U from taobao with 32MB Flash and 64MB RAM.</p><p>What i didn&#039;t know, is that only 16MB Flash are running without modifications. The 32MB adaptation requires some hacking to make it work.</p><p>The Router comes shipped with an openwrt Barrier breaker&nbsp; (14.07, r42406) and a custom bootrom (probably an adaptation from the pepe2k bootloader with 32mb flash changes)</p><p>Wifi is up, full 32MB are read/ writeable</p><div class="codebox"><pre><code>Filesystem                Size      Used Available Use% Mounted on
rootfs                   28.6M      8.0M     20.5M  28% /
/dev/root                 2.3M      2.3M         0 100% /rom
tmpfs                    30.0M     64.0K     30.0M   0% /tmp
/dev/mtdblock3           28.6M      8.0M     20.5M  28% /overlay
overlayfs:/overlay       28.6M      8.0M     20.5M  28% /
tmpfs                   512.0K         0    512.0K   0% /dev</code></pre></div><p>When i contaced the vendor, he told me that he used the source from here and i should compile myself.<br /><a href="https://code.csdn.net/hackpascal/openwrt_32m">https://code.csdn.net/hackpascal/openwrt_32m</a><br />This is an early barrier breaker trunk (39930).</p><p>The last days i was trying to adapt those changes to the 14.07 barrier breaker release without success (due to missing knowledge).</p><p>Can anybody tell/ help me how to adapt those changes to the 14.07 Barrier breaker final release?<br />Or<br />Does anybody have an already working image/ toolchain for the 32MB mod?</p><p>The code the chinese guy uses at least some parts from this OpenWRT forum post: <a href="https://forum.openwrt.org/viewtopic.php?id=45219">https://forum.openwrt.org/viewtopic.php?id=45219</a></p><p>Thanks in advance!</p>											<p class="post-edited">(Last edited by <strong>Sorlas</strong> on 13 Dec 2014, 02:31)</p>
									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p257226">
				<div class="post-metadata">
					<div class="post-num">Post #2</div>
					<div class="post-author">mk24</div>
					<div class="post-datetime">
						10 Dec 2014, 17:44					</div>
				</div>
				<div class="post-content content">
					<p>If the standard build works on this hardware except for limiting access to only 16 MB, it may be as simple as changing the mtd partition size in your model&#039;s dts file.</p><p>&lt;buildroot&gt;/target/linux/&lt;your CPU&gt;/dts/</p>											<p class="post-edited">(Last edited by <strong>mk24</strong> on 10 Dec 2014, 18:05)</p>
									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p257328">
				<div class="post-metadata">
					<div class="post-num">Post #3</div>
					<div class="post-author">Sorlas</div>
					<div class="post-datetime">
						11 Dec 2014, 07:51					</div>
				</div>
				<div class="post-content content">
					<p>Its actually not that easy.<br />The problem is the wifi from the ar9331.</p><p>As far as i understood this, the driver cannot support flash chips larger than 16MB. So modifications to the driver have to be made.</p><p>The chinese guy actually name them, but as is said i&#039;am actually not really sure what i&#039;am doing and need some help</p>									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p257371">
				<div class="post-metadata">
					<div class="post-num">Post #4</div>
					<div class="post-author">mk24</div>
					<div class="post-datetime">
						11 Dec 2014, 16:45					</div>
				</div>
				<div class="post-content content">
					<p>The problem is the 64 kB ART data needed to make wifi work.&nbsp; Ordinarily it is stored in the last block of the flash.&nbsp; But I think if you are writing the partition table yourself, you could move &#039;art&#039; to somewhere in the first 16 MB and as long as a copy of the ART exists where the table says it is, the wifi driver would find it.</p><p>Unless the wifi driver is not looking at mtd at all and just blindly goes to the last block of what it thinks is the flash size.</p>									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p257422">
				<div class="post-metadata">
					<div class="post-num">Post #5</div>
					<div class="post-author">mk24</div>
					<div class="post-datetime">
						12 Dec 2014, 04:01					</div>
				</div>
				<div class="post-content content">
					<p>And before messing with this too much, be sure to use the factory firmware to extract your ART and save it to a safe place.&nbsp; Because it&#039;s always going to get erased by accident from the flash at some point.</p>									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p257440">
				<div class="post-metadata">
					<div class="post-num">Post #6</div>
					<div class="post-author">Sorlas</div>
					<div class="post-datetime">
						12 Dec 2014, 10:17					</div>
				</div>
				<div class="post-content content">
					<p>I bought it here:</p><p><a href="http://item.taobao.com/item.htm?spm=a230r.1.14.1.11xSWf&amp;id=40352290157&amp;ns=1&amp;abbucket=11#detail">http://item.taobao.com/item.htm?spm=a23 â€¦ =11#detail</a></p><p>here the dmesg from the delivered openwrt:</p><div class="codebox"><pre><code>[    0.000000] Linux version 3.10.49 (hackpascal@HackPascalPC) (gcc version 4.8.3 (OpenWrt/Linaro GCC 4.8-2014.04 unknown) ) #43 Sun Sep 28 18:51:55 CST 2014
[    0.000000] MyLoader: sysp=6c5fed42, boardp=be725d54, parts=dc5393f0
[    0.000000] bootconsole [early0] enabled
[    0.000000] CPU revision is: 00019374 (MIPS 24Kc)
[    0.000000] SoC: Atheros AR9330 rev 1
[    0.000000] Clocks: CPU:400.000MHz, DDR:400.000MHz, AHB:200.000MHz, Ref:25.000MHz
[    0.000000] Determined physical RAM map:
[    0.000000]  memory: 04000000 @ 00000000 (usable)
[    0.000000] Initrd not found or empty - disabling initrd
[    0.000000] Zone ranges:
[    0.000000]   Normal   [mem 0x00000000-0x03ffffff]
[    0.000000] Movable zone start for each node
[    0.000000] Early memory node ranges
[    0.000000]   node   0: [mem 0x00000000-0x03ffffff]
[    0.000000] On node 0 totalpages: 16384
[    0.000000] free_area_init_node: node 0, pgdat 803109b0, node_mem_map 81000000
[    0.000000]   Normal zone: 128 pages used for memmap
[    0.000000]   Normal zone: 0 pages reserved
[    0.000000]   Normal zone: 16384 pages, LIFO batch:3
[    0.000000] Primary instruction cache 64kB, VIPT, 4-way, linesize 32 bytes.
[    0.000000] Primary data cache 32kB, 4-way, VIPT, cache aliases, linesize 32 bytes
[    0.000000] pcpu-alloc: s0 r0 d32768 u32768 alloc=1*32768
[    0.000000] pcpu-alloc: [0] 0 
[    0.000000] Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 16256
[    0.000000] Kernel command line:  board=TL-MR13U console=ttyATH0,115200 rootfstype=squashfs,jffs2 noinitrd
[    0.000000] PID hash table entries: 256 (order: -2, 1024 bytes)
[    0.000000] Dentry cache hash table entries: 8192 (order: 3, 32768 bytes)
[    0.000000] Inode-cache hash table entries: 4096 (order: 2, 16384 bytes)
[    0.000000] Writing ErrCtl register=00000000
[    0.000000] Readback ErrCtl register=00000000
[    0.000000] Memory: 61272k/65536k available (2239k kernel code, 4264k reserved, 604k data, 228k init, 0k highmem)
[    0.000000] SLUB: HWalign=32, Order=0-3, MinObjects=0, CPUs=1, Nodes=1
[    0.000000] NR_IRQS:51
[    0.080000] Calibrating delay loop... 265.42 BogoMIPS (lpj=1327104)
[    0.080000] pid_max: default: 32768 minimum: 301
[    0.080000] Mount-cache hash table entries: 512
[    0.090000] NET: Registered protocol family 16
[    0.100000] MIPS: machine is TP-LINK TL-MR13U v1
[    0.340000] bio: create slab &lt;bio-0&gt; at 0
[    0.350000] Switching to clocksource MIPS
[    0.350000] NET: Registered protocol family 2
[    0.360000] TCP established hash table entries: 512 (order: 0, 4096 bytes)
[    0.360000] TCP bind hash table entries: 512 (order: -1, 2048 bytes)
[    0.360000] TCP: Hash tables configured (established 512 bind 512)
[    0.370000] TCP: reno registered
[    0.370000] UDP hash table entries: 256 (order: 0, 4096 bytes)
[    0.380000] UDP-Lite hash table entries: 256 (order: 0, 4096 bytes)
[    0.390000] NET: Registered protocol family 1
[    0.390000] PCI: CLS 0 bytes, default 32
[    0.410000] squashfs: version 4.0 (2009/01/31) Phillip Lougher
[    0.410000] jffs2: version 2.2 (NAND) (SUMMARY) (LZMA) (RTIME) (CMODE_PRIORITY) (c) 2001-2006 Red Hat, Inc.
[    0.420000] msgmni has been set to 119
[    0.430000] io scheduler noop registered
[    0.430000] io scheduler deadline registered (default)
[    0.440000] Serial: 8250/16550 driver, 1 ports, IRQ sharing disabled
[    0.440000] ar933x-uart: ttyATH0 at MMIO 0x18020000 (irq = 11) is a AR933X UART
[    0.450000] console [ttyATH0] enabled, bootconsole disabled
[    0.460000] ath79-spi ath79-spi: master is unqueued, this is deprecated
[    0.470000] m25p80 spi0.0: found w25q256, expected m25p80
[    0.470000] m25p80 spi0.0: w25q256 (32768 Kbytes)
[    0.480000] 5 tp-link partitions found on MTD device spi0.0
[    0.480000] Creating 5 MTD partitions on &quot;spi0.0&quot;:
[    0.490000] 0x000000000000-0x000000020000 : &quot;u-boot&quot;
[    0.500000] 0x000000020000-0x000000122490 : &quot;kernel&quot;
[    0.500000] mtd: partition &quot;kernel&quot; must either start or end on erase block boundary or be smaller than an erase block -- forcing read-only
[    0.510000] 0x000000122490-0x000001ff0000 : &quot;rootfs&quot;
[    0.520000] mtd: partition &quot;rootfs&quot; must either start or end on erase block boundary or be smaller than an erase block -- forcing read-only
[    0.530000] mtd: device 2 (rootfs) set to be root filesystem
[    0.540000] 1 squashfs-split partitions found on MTD device rootfs
[    0.540000] 0x000000360000-0x000001ff0000 : &quot;rootfs_data&quot;
[    0.550000] 0x000001ff0000-0x000002000000 : &quot;art&quot;
[    0.560000] 0x000000020000-0x000001ff0000 : &quot;firmware&quot;
[    0.580000] libphy: ag71xx_mdio: probed
[    1.130000] ag71xx ag71xx.0: connected to PHY at ag71xx-mdio.1:04 [uid=004dd041, driver=Generic PHY]
[    1.140000] eth0: Atheros AG71xx at 0xb9000000, irq 4, mode:MII
[    1.150000] TCP: cubic registered
[    1.150000] NET: Registered protocol family 17
[    1.150000] 8021q: 802.1Q VLAN Support v1.8
[    1.190000] VFS: Mounted root (squashfs filesystem) readonly on device 31:2.
[    1.190000] Freeing unused kernel memory: 228K (80327000 - 80360000)
[    5.600000] usbcore: registered new interface driver usbfs
[    5.610000] usbcore: registered new interface driver hub
[    5.610000] usbcore: registered new device driver usb
[    5.670000] SCSI subsystem initialized
[    5.680000] ehci_hcd: USB 2.0 &#039;Enhanced&#039; Host Controller (EHCI) Driver
[    5.690000] ehci-platform: EHCI generic platform driver
[    5.690000] ehci-platform ehci-platform: EHCI Host Controller
[    5.700000] ehci-platform ehci-platform: new USB bus registered, assigned bus number 1
[    5.710000] ehci-platform ehci-platform: irq 3, io mem 0x1b000000
[    5.730000] ehci-platform ehci-platform: USB 2.0 started, EHCI 1.00
[    5.730000] hub 1-0:1.0: USB hub found
[    5.730000] hub 1-0:1.0: 1 port detected
[    5.740000] ohci_hcd: USB 1.1 &#039;Open&#039; Host Controller (OHCI) Driver
[    5.750000] usbcore: registered new interface driver usb-storage
[   10.450000] jffs2: notice: (331) jffs2_build_xattr_subsystem: complete building xattr subsystem, 1 of xdatum (1 unchecked, 0 orphan) and 15 of xref (0 dead, 2 orphan) found.
[   10.760000] jffs2: notice: (328) jffs2_build_xattr_subsystem: complete building xattr subsystem, 1 of xdatum (1 unchecked, 0 orphan) and 15 of xref (0 dead, 2 orphan) found.
[   12.600000] NET: Registered protocol family 10
[   12.610000] nf_conntrack version 0.5.0 (960 buckets, 3840 max)
[   12.630000] ip6_tables: (C) 2000-2006 Netfilter Core Team
[   12.650000] Loading modules backported from Linux version master-2014-05-22-0-gf2032ea
[   12.660000] Backport generated by backports.git backports-20140320-37-g5c33da0
[   12.670000] ip_tables: (C) 2000-2006 Netfilter Core Team
[   12.720000] xt_time: kernel timezone is -0000
[   12.760000] cfg80211: Calling CRDA to update world regulatory domain
[   12.760000] cfg80211: World regulatory domain updated:
[   12.770000] cfg80211:  DFS Master region: unset
[   12.770000] cfg80211:   (start_freq - end_freq @ bandwidth), (max_antenna_gain, max_eirp), (dfs_cac_time)
[   12.780000] cfg80211:   (2402000 KHz - 2472000 KHz @ 40000 KHz), (N/A, 2000 mBm), (N/A)
[   12.790000] cfg80211:   (2457000 KHz - 2482000 KHz @ 40000 KHz), (N/A, 2000 mBm), (N/A)
[   12.800000] cfg80211:   (2474000 KHz - 2494000 KHz @ 20000 KHz), (N/A, 2000 mBm), (N/A)
[   12.800000] cfg80211:   (5170000 KHz - 5250000 KHz @ 160000 KHz), (N/A, 2000 mBm), (N/A)
[   12.810000] cfg80211:   (5250000 KHz - 5330000 KHz @ 160000 KHz), (N/A, 2000 mBm), (0 s)
[   12.820000] cfg80211:   (5490000 KHz - 5730000 KHz @ 160000 KHz), (N/A, 2000 mBm), (0 s)
[   12.830000] cfg80211:   (5735000 KHz - 5835000 KHz @ 80000 KHz), (N/A, 2000 mBm), (N/A)
[   12.840000] cfg80211:   (57240000 KHz - 63720000 KHz @ 2160000 KHz), (N/A, 0 mBm), (N/A)
[   12.900000] PPP generic driver version 2.4.2
[   12.910000] NET: Registered protocol family 24
[   12.990000] ath: EEPROM regdomain: 0x0
[   12.990000] ath: EEPROM indicates default country code should be used
[   12.990000] ath: doing EEPROM country-&gt;regdmn map search
[   12.990000] ath: country maps to regdmn code: 0x3a
[   12.990000] ath: Country alpha2 being used: US
[   12.990000] ath: Regpair used: 0x3a
[   13.010000] ieee80211 phy0: Selected rate control algorithm &#039;minstrel_ht&#039;
[   13.020000] cfg80211: Calling CRDA for country: US
[   13.030000] cfg80211: Regulatory domain changed to country: US
[   13.030000] cfg80211:  DFS Master region: FCC
[   13.030000] cfg80211:   (start_freq - end_freq @ bandwidth), (max_antenna_gain, max_eirp), (dfs_cac_time)
[   13.040000] cfg80211:   (2402000 KHz - 2472000 KHz @ 40000 KHz), (N/A, 3000 mBm), (N/A)
[   13.050000] cfg80211:   (5170000 KHz - 5250000 KHz @ 80000 KHz), (N/A, 1700 mBm), (N/A)
[   13.060000] cfg80211:   (5250000 KHz - 5330000 KHz @ 80000 KHz), (N/A, 2300 mBm), (0 s)
[   13.070000] cfg80211:   (5735000 KHz - 5835000 KHz @ 80000 KHz), (N/A, 3000 mBm), (N/A)
[   13.080000] cfg80211:   (57240000 KHz - 63720000 KHz @ 2160000 KHz), (N/A, 4000 mBm), (N/A)
[   13.080000] ieee80211 phy0: Atheros AR9330 Rev:1 mem=0xb8100000, irq=2
[   22.770000] IPv6: ADDRCONF(NETDEV_UP): eth0: link is not ready
[   22.770000] device eth0 entered promiscuous mode
[   22.790000] IPv6: ADDRCONF(NETDEV_UP): br-lan: link is not ready
[   25.200000] IPv6: ADDRCONF(NETDEV_UP): wlan0: link is not ready
[   25.220000] device wlan0 entered promiscuous mode
[   25.220000] br-lan: port 2(wlan0) entered forwarding state
[   25.220000] br-lan: port 2(wlan0) entered forwarding state
[   25.400000] IPv6: ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready
[   25.400000] IPv6: ADDRCONF(NETDEV_CHANGE): br-lan: link becomes ready
[   27.220000] br-lan: port 2(wlan0) entered forwarding state
[   43.760000] eth0: link up (100Mbps/Full duplex)
[   43.760000] br-lan: port 1(eth0) entered forwarding state
[   43.770000] br-lan: port 1(eth0) entered forwarding state
[   43.770000] IPv6: ADDRCONF(NETDEV_CHANGE): eth0: link becomes ready
[   45.770000] br-lan: port 1(eth0) entered forwarding state</code></pre></div><div class="codebox"><pre><code>root@OpenWrt:/proc# cat mtd
dev:    size   erasesize  name
mtd0: 00020000 00010000 &quot;u-boot&quot;
mtd1: 00102490 00010000 &quot;kernel&quot;
mtd2: 01ecdb70 00010000 &quot;rootfs&quot;
mtd3: 01c90000 00010000 &quot;rootfs_data&quot;
mtd4: 00010000 00010000 &quot;art&quot;
mtd5: 01fd0000 00010000 &quot;firmware&quot;</code></pre></div>									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p257442">
				<div class="post-metadata">
					<div class="post-num">Post #7</div>
					<div class="post-author">Sorlas</div>
					<div class="post-datetime">
						12 Dec 2014, 10:25					</div>
				</div>
				<div class="post-content content">
					<p>I am currently working on the adaptation of the MR13U 32MB Flash changes made by <a href="https://code.csdn.net/hackpascal/openwrt_32m">HackPascal</a></p><p>Right now i&#039;am working on this (hopefully get all changes) and applied 2 patches (against BB 12.07 (43483), see below) and removed 4 patches (Patch 460 to 463) </p><p>Did not try this yet, but i&#039;am willing to do ^^</p><p>999-32MB-HackPascal<br /></p><div class="codebox"><pre><code>--- a/arch/mips/ath79/Makefile
+++ b/arch/mips/ath79/Makefile
@@ -142,3 +142,4 @@
 obj-$(CONFIG_ATH79_MACH_ZCN_1523H)    += mach-zcn-1523h.o
 obj-$(CONFIG_ATH79_MACH_CARAMBOLA2)    += mach-carambola2.o
 obj-$(CONFIG_ATH79_MACH_NBG6716)    += mach-nbg6716.o
+obj-y                    += eeprom.o
--- a/arch/mips/ath79/dev-m25p80.c
+++ a/arch/mips/ath79/dev-m25p80.c
@@ -51,7 +51,6 @@
 {
     ath79_spi_data.bus_num = 0;
     ath79_spi_data.num_chipselect = 1;
-    ath79_spi0_cdata.is_flash = true;
     ath79_spi_info[0].platform_data = pdata;
     ath79_register_spi(&amp;ath79_spi_data, ath79_spi_info, 1);
 }
@@ -113,6 +112,5 @@
     add_mtd_concat_notifier();
     ath79_spi_data.bus_num = 0;
     ath79_spi_data.num_chipselect = 2;
-    ath79_spi0_cdata.is_flash = true;
     ath79_register_spi(&amp;ath79_spi_data, ath79_spi_info, 2);
 }
--- a/arch/mips/ath79/mach-alfa-ap96.c
+++ a/arch/mips/ath79/mach-alfa-ap96.c
@@ -62,7 +62,6 @@
 static struct ath79_spi_controller_data ap96_spi0_cdata = {
     .cs_type = ATH79_SPI_CS_TYPE_INTERNAL,
     .cs_line = 0,
-    .is_flash = true,
 };
 
 static struct ath79_spi_controller_data ap96_spi1_cdata = {
--- a/arch/mips/ath79/mach-tl-mr13u.c
+++ a/arch/mips/ath79/mach-tl-mr13u.c
@@ -20,6 +20,7 @@
 #include &quot;dev-usb.h&quot;
 #include &quot;dev-wmac.h&quot;
 #include &quot;machtypes.h&quot;
+#include &quot;eeprom.h&quot;
 
 #define TL_MR13U_GPIO_LED_SYSTEM    27
 
@@ -79,7 +80,7 @@
 static void __init tl_mr13u_setup(void)
 {
     u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
-    u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+    u8 *ee = ath79_get_eeprom();
 
     /* disable PHY_SWAP and PHY_ADDR_SWAP bits */
     ath79_setup_ar933x_phy4_switch(false, false);
--- a/arch/mips/ath79/eeprom.c
+++ a/arch/mips/ath79/eeprom.c
@@ -0,0 +1,111 @@
+#include &lt;asm/mach-ath79/ath79.h&gt;
+#include &lt;asm/mach-ath79/ar71xx_regs.h&gt;
+
+#include &lt;linux/delay.h&gt;
+
+#include &quot;common.h&quot;
+#include &quot;eeprom.h&quot;
+
+static u32 flash_32m_jedec[] = {0x20BA19, 0xEF4019, 0xC22019};
+
+static void __iomem *ath79_spi_base;
+
+
+static char ath79_eeprom[64 * 1024];
+
+static u32 ath79_flash_read_id(void)
+{
+    u32 rd = 0;
+
+    ath79_spi_start();
+
+    ath79_spi_bit_banger(OPCODE_RDID);
+
+    ath79_spi_delay_8();
+    ath79_spi_delay_8();
+    ath79_spi_delay_8();
+
+    rd = ath79_spi_read(AR71XX_SPI_REG_RDS) &amp; 0xffffff;
+
+    ath79_spi_done();
+
+    return rd;
+}
+
+static void ath79_flash_reset(void)
+{
+    ath79_spi_send_instruction(OPCODE_RSTEN);
+    ath79_spi_send_instruction(OPCODE_RESET);
+
+    udelay(100);
+}
+
+static int ath79_flash_read(u32 addr, u32 len, void *buf)
+{
+    int i;
+    u32 bytes_left;
+    void *write_addr;
+
+    bytes_left = len;
+    write_addr = buf;
+
+    ath79_spi_start();
+    ath79_spi_deselect();
+
+    ath79_flash_reset();
+
+    ath79_spi_send_instruction(OPCODE_WREN);
+    ath79_spi_bit_banger(OPCODE_WREAR);
+    ath79_spi_bit_banger((addr &amp; 0xff000000) &gt;&gt; 24);
+    ath79_spi_go();
+
+    ath79_spi_bit_banger(OPCODE_READ);
+    ath79_spi_send_addr(addr);
+
+    while (bytes_left)
+    {
+        for (i = 0; i &lt; sizeof (u32); i++)
+            ath79_spi_delay_8();
+
+        *(u32 *)write_addr = ath79_spi_read(AR71XX_SPI_REG_RDS);
+
+        write_addr = (void *) ((u32) write_addr + sizeof (u32));
+        bytes_left -= sizeof (u32);
+    }
+
+    ath79_spi_go();
+    ath79_spi_deselect();
+
+    ath79_flash_reset();
+
+    ath79_spi_done();
+
+    return 0;
+}
+
+u8 *ath79_get_eeprom(void)
+{
+    int i;
+    u32 jedec_id;
+
+    ath79_spi_base = ioremap_nocache(AR71XX_SPI_BASE, AR71XX_SPI_SIZE);
+
+    jedec_id = ath79_flash_read_id();
+
+    for (i = 0; i &lt; ARRAY_SIZE(flash_32m_jedec); i++)
+    {
+        if (flash_32m_jedec[i] == jedec_id)
+            break;
+    }
+
+    if (flash_32m_jedec[i] != jedec_id)
+    {
+        iounmap(ath79_spi_base);
+        return (u8 *) KSEG1ADDR(0x1fff1000);
+    }
+
+    ath79_flash_read(0x01ff0000, 0x10000, ath79_eeprom);
+
+    iounmap(ath79_spi_base);
+    return (u8 *) ((u32) ath79_eeprom + 0x1000);
+}
--- a/arch/mips/ath79/eeprom.h
+++ a/arch/mips/ath79/eeprom.h
@@ -0,0 +1,62 @@
+#define AR71XX_SPI_CLK_HIGH    (1&lt;&lt;8)
+#define AR71XX_SPI_CS_DIS    (AR71XX_SPI_IOC_CS_ALL)
+#define AR71XX_SPI_CE_LOW    (AR71XX_SPI_IOC_CS1 | AR71XX_SPI_IOC_CS2)
+#define AR71XX_SPI_CE_HIGH    (AR71XX_SPI_CE_LOW | AR71XX_SPI_CLK_HIGH)
+
+#define OPCODE_READ        0x03
+#define OPCODE_WREN        0x06
+#define OPCODE_WREAR        0xc5
+#define OPCODE_RSTEN        0x66
+#define OPCODE_RESET        0x99
+#define OPCODE_RDID        0x9f
+
+#define ath79_spi_read(_phys)        __raw_readl(ath79_spi_base + (_phys))
+#define ath79_spi_write(_phys, _val)    __raw_writel((_val), ath79_spi_base + (_phys))
+
+#define ath79_be_msb(_val, _i) (((_val) &amp; (1 &lt;&lt; (7 - _i))) &gt;&gt; (7 - _i))
+
+
+#define ath79_spi_bit_banger(_byte) do \
+    { \
+        int i; \
+        for(i = 0; i &lt; 8; i++) \
+        { \
+            ath79_spi_write(AR71XX_SPI_REG_IOC, \
+                AR71XX_SPI_CE_LOW | ath79_be_msb(_byte, i)); \
+            ath79_spi_write(AR71XX_SPI_REG_IOC, \
+                AR71XX_SPI_CE_HIGH | ath79_be_msb(_byte, i)); \
+        } \
+    } while(0)
+
+
+#define ath79_spi_go() do \
+    { \
+        ath79_spi_write(AR71XX_SPI_REG_IOC, AR71XX_SPI_CE_LOW); \
+        ath79_spi_write(AR71XX_SPI_REG_IOC, AR71XX_SPI_CS_DIS); \
+    } while(0)
+
+
+#define ath79_spi_send_instruction(_byte) do \
+    { \
+        ath79_spi_bit_banger(_byte); \
+        ath79_spi_go(); \
+    } while(0)
+
+
+#define ath79_spi_send_addr(_addr) do \
+    { \
+        ath79_spi_bit_banger(((_addr &amp; 0xff0000) &gt;&gt; 16)); \
+        ath79_spi_bit_banger(((_addr &amp; 0xff00) &gt;&gt; 8)); \
+        ath79_spi_bit_banger(_addr &amp; 0xff); \
+    } while(0)
+
+
+#define ath79_spi_delay_8()    ath79_spi_bit_banger(0)
+
+#define ath79_spi_deselect()    ath79_spi_write(AR71XX_SPI_REG_IOC, AR71XX_SPI_CS_DIS)
+
+#define ath79_spi_start()    ath79_spi_write(AR71XX_SPI_REG_FS, 1)
+
+#define ath79_spi_done()    ath79_spi_write(AR71XX_SPI_REG_FS, 0)
+
+u8 *ath79_get_eeprom(void);</code></pre></div><p>415-mtd-m25p80-enable-reset-when-removed</p><div class="codebox"><pre><code>--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -70,6 +70,10 @@
 #define    SR_BP2            0x10    /* Block protect 2 */
 #define    SR_SRWD            0x80    /* SR write protect */
 
+/* Reset opcodes */
+#define OPCODE_RSTEN        0x66    /* Enable reset */
+#define OPCODE_RESET        0x99    /* Reset device */
+
 /* Define max times to check status register before we give up. */
 #define    MAX_READY_WAIT_JIFFIES    (40 * HZ)    /* M25P16 specs 40s max chip erase */
 #define    MAX_CMD_SIZE        5
@@ -205,6 +209,49 @@
 }
 
 /*
+ * Reset hole flash chip. Only be avaliable for chips size &gt;= 32MiB
+ */
+static inline int flash_reset(struct m25p *flash)
+{
+    struct spi_transfer t[2];
+    struct spi_message m;
+    char command[2];
+    int ret;
+
+    if (flash-&gt;addr_width != 4) return 1;
+
+    spi_message_init(&amp;m);
+    memset(t, 0, (sizeof t));
+
+    t[0].tx_buf = &amp;command[0];
+    t[0].len = 1;
+    t[0].cs_change = 1;
+    spi_message_add_tail(&amp;t[0], &amp;m);
+
+    t[1].tx_buf = &amp;command[1];
+    t[1].len = 1;
+    t[1].cs_change = 1;
+    spi_message_add_tail(&amp;t[1], &amp;m);
+
+    command[0] = OPCODE_RSTEN;
+    command[1] = OPCODE_RESET;
+
+    mutex_lock(&amp;flash-&gt;lock);
+
+    ret = wait_till_ready(flash);
+    if (ret) {
+        mutex_unlock(&amp;flash-&gt;lock);
+        return 1;
+    }
+
+    spi_sync(flash-&gt;spi, &amp;m);
+
+    mutex_unlock(&amp;flash-&gt;lock);
+
+    return 0;
+}
+
+/*
  * Erase the whole flash memory
  *
  * Returns 0 if successful, non-zero otherwise.
@@ -1135,6 +1182,9 @@
     struct m25p    *flash = dev_get_drvdata(&amp;spi-&gt;dev);
     int        status;
 
+    /* Reset flash. */
+    flash_reset(flash);
+
     /* Clean up MTD stuff. */
     status = mtd_device_unregister(&amp;flash-&gt;mtd);
     if (status == 0) {</code></pre></div>											<p class="post-edited">(Last edited by <strong>Sorlas</strong> on 12 Dec 2014, 10:35)</p>
									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p257443">
				<div class="post-metadata">
					<div class="post-num">Post #8</div>
					<div class="post-author">Sorlas</div>
					<div class="post-datetime">
						12 Dec 2014, 11:04					</div>
				</div>
				<div class="post-content content">
					<p>i compiled with the changes above but without success.<br />dmesg shows that everything after 16mb?! was formated?</p><p>dmesg from first boot:<br /></p><div class="codebox"><pre><code>[    0.000000] Linux version 3.10.49 (sorlas@SorlasDebian) (gcc version 4.8.3 (OpenWrt/Linaro GCC 4.8-2014.04 r43483) ) #1 Fri Dec 12 09:32:38 CET 2014
[    0.000000] MyLoader: sysp=6c5fed42, boardp=be725d54, parts=dc5393f0
[    0.000000] bootconsole [early0] enabled
[    0.000000] CPU revision is: 00019374 (MIPS 24Kc)
[    0.000000] SoC: Atheros AR9330 rev 1
[    0.000000] Clocks: CPU:400.000MHz, DDR:400.000MHz, AHB:200.000MHz, Ref:25.000MHz
[    0.000000] Determined physical RAM map:
[    0.000000]  memory: 04000000 @ 00000000 (usable)
[    0.000000] Initrd not found or empty - disabling initrd
[    0.000000] Zone ranges:
[    0.000000]   Normal   [mem 0x00000000-0x03ffffff]
[    0.000000] Movable zone start for each node
[    0.000000] Early memory node ranges
[    0.000000]   node   0: [mem 0x00000000-0x03ffffff]
[    0.000000] On node 0 totalpages: 16384
[    0.000000] free_area_init_node: node 0, pgdat 803109b0, node_mem_map 81000000
[    0.000000]   Normal zone: 128 pages used for memmap
[    0.000000]   Normal zone: 0 pages reserved
[    0.000000]   Normal zone: 16384 pages, LIFO batch:3
[    0.000000] Primary instruction cache 64kB, VIPT, 4-way, linesize 32 bytes.
[    0.000000] Primary data cache 32kB, 4-way, VIPT, cache aliases, linesize 32 bytes
[    0.000000] pcpu-alloc: s0 r0 d32768 u32768 alloc=1*32768
[    0.000000] pcpu-alloc: [0] 0 
[    0.000000] Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 16256
[    0.000000] Kernel command line:  board=TL-MR13U console=ttyATH0,115200 rootfstype=squashfs,jffs2 noinitrd
[    0.000000] PID hash table entries: 256 (order: -2, 1024 bytes)
[    0.000000] Dentry cache hash table entries: 8192 (order: 3, 32768 bytes)
[    0.000000] Inode-cache hash table entries: 4096 (order: 2, 16384 bytes)
[    0.000000] Writing ErrCtl register=00000000
[    0.000000] Readback ErrCtl register=00000000
[    0.000000] Memory: 61208k/65536k available (2240k kernel code, 4328k reserved, 602k data, 228k init, 0k highmem)
[    0.000000] SLUB: HWalign=32, Order=0-3, MinObjects=0, CPUs=1, Nodes=1
[    0.000000] NR_IRQS:51
[    0.080000] Calibrating delay loop... 265.42 BogoMIPS (lpj=1327104)
[    0.080000] pid_max: default: 32768 minimum: 301
[    0.080000] Mount-cache hash table entries: 512
[    0.090000] NET: Registered protocol family 16
[    0.100000] MIPS: machine is TP-LINK TL-MR13U v1
[    0.410000] bio: create slab &lt;bio-0&gt; at 0
[    0.420000] Switching to clocksource MIPS
[    0.430000] NET: Registered protocol family 2
[    0.430000] TCP established hash table entries: 512 (order: 0, 4096 bytes)
[    0.430000] TCP bind hash table entries: 512 (order: -1, 2048 bytes)
[    0.430000] TCP: Hash tables configured (established 512 bind 512)
[    0.440000] TCP: reno registered
[    0.440000] UDP hash table entries: 256 (order: 0, 4096 bytes)
[    0.450000] UDP-Lite hash table entries: 256 (order: 0, 4096 bytes)
[    0.460000] NET: Registered protocol family 1
[    0.460000] PCI: CLS 0 bytes, default 32
[    0.480000] squashfs: version 4.0 (2009/01/31) Phillip Lougher
[    0.480000] jffs2: version 2.2 (NAND) (SUMMARY) (LZMA) (RTIME) (CMODE_PRIORITY) (c) 2001-2006 Red Hat, Inc.
[    0.490000] msgmni has been set to 119
[    0.500000] io scheduler noop registered
[    0.500000] io scheduler deadline registered (default)
[    0.510000] Serial: 8250/16550 driver, 1 ports, IRQ sharing disabled
[    0.510000] ar933x-uart: ttyATH0 at MMIO 0x18020000 (irq = 11) is a AR933X UART
[    0.520000] console [ttyATH0] enabled, bootconsole disabled
[    0.530000] ath79-spi ath79-spi: master is unqueued, this is deprecated
[    0.540000] m25p80 spi0.0: found w25q256, expected m25p80
[    0.540000] m25p80 spi0.0: w25q256 (32768 Kbytes)
[    0.550000] 5 tp-link partitions found on MTD device spi0.0
[    0.550000] Creating 5 MTD partitions on &quot;spi0.0&quot;:
[    0.560000] 0x000000000000-0x000000020000 : &quot;u-boot&quot;
[    0.570000] 0x000000020000-0x000000122104 : &quot;kernel&quot;
[    0.570000] mtd: partition &quot;kernel&quot; must either start or end on erase block boundary or be smaller than an erase block -- forcing read-only
[    0.580000] 0x000000122104-0x000001ff0000 : &quot;rootfs&quot;
[    0.590000] mtd: partition &quot;rootfs&quot; must either start or end on erase block boundary or be smaller than an erase block -- forcing read-only
[    0.600000] mtd: device 2 (rootfs) set to be root filesystem
[    0.610000] 1 squashfs-split partitions found on MTD device rootfs
[    0.610000] 0x0000002f0000-0x000001ff0000 : &quot;rootfs_data&quot;
[    0.620000] 0x000001ff0000-0x000002000000 : &quot;art&quot;
[    0.620000] 0x000000020000-0x000001ff0000 : &quot;firmware&quot;
[    0.650000] libphy: ag71xx_mdio: probed
[    1.200000] ag71xx ag71xx.0: connected to PHY at ag71xx-mdio.1:04 [uid=004dd041, driver=Generic PHY]
[    1.210000] eth0: Atheros AG71xx at 0xb9000000, irq 4, mode:MII
[    1.210000] TCP: cubic registered
[    1.220000] NET: Registered protocol family 17
[    1.220000] 8021q: 802.1Q VLAN Support v1.8
[    1.240000] VFS: Mounted root (squashfs filesystem) readonly on device 31:2.
[    1.250000] Freeing unused kernel memory: 228K (80327000 - 80360000)
[    5.190000] usbcore: registered new interface driver usbfs
[    5.190000] usbcore: registered new interface driver hub
[    5.200000] usbcore: registered new device driver usb
[    5.210000] ehci_hcd: USB 2.0 &#039;Enhanced&#039; Host Controller (EHCI) Driver
[    5.210000] ehci-platform: EHCI generic platform driver
[    5.220000] ehci-platform ehci-platform: EHCI Host Controller
[    5.220000] ehci-platform ehci-platform: new USB bus registered, assigned bus number 1
[    5.230000] ehci-platform ehci-platform: irq 3, io mem 0x1b000000
[    5.260000] ehci-platform ehci-platform: USB 2.0 started, EHCI 1.00
[    5.260000] hub 1-0:1.0: USB hub found
[    5.260000] hub 1-0:1.0: 1 port detected
[    5.270000] ohci_hcd: USB 1.1 &#039;Open&#039; Host Controller (OHCI) Driver
[    9.290000] jffs2_scan_eraseblock(): End of filesystem marker found at 0x10000
[    9.290000] jffs2_build_filesystem(): unlocking the mtd device... done.
[   10.310000] eth0: link up (100Mbps/Full duplex)
[    9.300000] jffs2_build_filesystem(): erasing all blocks after the end marker... done.
[  158.460000] jffs2: notice: (307) jffs2_build_xattr_subsystem: complete building xattr subsystem, 0 of xdatum (0 unchecked, 0 orphan) and 0 of xref (0 dead, 0 orphan) found.
[  158.740000] eth0: link down
[  160.440000] NET: Registered protocol family 10
[  160.460000] nf_conntrack version 0.5.0 (959 buckets, 3836 max)
[  160.470000] ip6_tables: (C) 2000-2006 Netfilter Core Team
[  160.480000] Loading modules backported from Linux version master-2014-05-22-0-gf2032ea
[  160.490000] Backport generated by backports.git backports-20140320-37-g5c33da0
[  160.500000] ip_tables: (C) 2000-2006 Netfilter Core Team
[  160.550000] xt_time: kernel timezone is -0000
[  160.590000] cfg80211: Calling CRDA to update world regulatory domain
[  160.590000] cfg80211: World regulatory domain updated:
[  160.600000] cfg80211:  DFS Master region: unset
[  160.600000] cfg80211:   (start_freq - end_freq @ bandwidth), (max_antenna_gain, max_eirp), (dfs_cac_time)
[  160.610000] cfg80211:   (2402000 KHz - 2472000 KHz @ 40000 KHz), (N/A, 2000 mBm), (N/A)
[  160.620000] cfg80211:   (2457000 KHz - 2482000 KHz @ 40000 KHz), (N/A, 2000 mBm), (N/A)
[  160.630000] cfg80211:   (2474000 KHz - 2494000 KHz @ 20000 KHz), (N/A, 2000 mBm), (N/A)
[  160.630000] cfg80211:   (5170000 KHz - 5250000 KHz @ 160000 KHz), (N/A, 2000 mBm), (N/A)
[  160.640000] cfg80211:   (5250000 KHz - 5330000 KHz @ 160000 KHz), (N/A, 2000 mBm), (0 s)
[  160.650000] cfg80211:   (5490000 KHz - 5730000 KHz @ 160000 KHz), (N/A, 2000 mBm), (0 s)
[  160.660000] cfg80211:   (5735000 KHz - 5835000 KHz @ 80000 KHz), (N/A, 2000 mBm), (N/A)
[  160.670000] cfg80211:   (57240000 KHz - 63720000 KHz @ 2160000 KHz), (N/A, 0 mBm), (N/A)
[  160.750000] PPP generic driver version 2.4.2
[  160.750000] NET: Registered protocol family 24
[  160.810000] ath: EEPROM regdomain: 0x0
[  160.810000] ath: EEPROM indicates default country code should be used
[  160.810000] ath: doing EEPROM country-&gt;regdmn map search
[  160.810000] ath: country maps to regdmn code: 0x3a
[  160.810000] ath: Country alpha2 being used: US
[  160.810000] ath: Regpair used: 0x3a
[  160.830000] ieee80211 phy0: Selected rate control algorithm &#039;minstrel_ht&#039;
[  160.840000] cfg80211: Calling CRDA for country: US
[  160.850000] cfg80211: Regulatory domain changed to country: US
[  160.850000] cfg80211:  DFS Master region: FCC
[  160.850000] cfg80211:   (start_freq - end_freq @ bandwidth), (max_antenna_gain, max_eirp), (dfs_cac_time)
[  160.860000] cfg80211:   (2402000 KHz - 2472000 KHz @ 40000 KHz), (N/A, 3000 mBm), (N/A)
[  160.870000] cfg80211:   (5170000 KHz - 5250000 KHz @ 80000 KHz), (N/A, 1700 mBm), (N/A)
[  160.880000] cfg80211:   (5250000 KHz - 5330000 KHz @ 80000 KHz), (N/A, 2300 mBm), (0 s)
[  160.890000] cfg80211:   (5735000 KHz - 5835000 KHz @ 80000 KHz), (N/A, 3000 mBm), (N/A)
[  160.900000] cfg80211:   (57240000 KHz - 63720000 KHz @ 2160000 KHz), (N/A, 4000 mBm), (N/A)
[  160.900000] ieee80211 phy0: Atheros AR9330 Rev:1 mem=0xb8100000, irq=2
[  169.920000] IPv6: ADDRCONF(NETDEV_UP): eth0: link is not ready
[  169.920000] device eth0 entered promiscuous mode
[  169.930000] IPv6: ADDRCONF(NETDEV_UP): br-lan: link is not ready
[  170.480000] eth0: link up (100Mbps/Full duplex)
[  170.480000] br-lan: port 1(eth0) entered forwarding state
[  170.490000] br-lan: port 1(eth0) entered forwarding state
[  170.490000] IPv6: ADDRCONF(NETDEV_CHANGE): eth0: link becomes ready
[  170.510000] IPv6: ADDRCONF(NETDEV_CHANGE): br-lan: link becomes ready
[  172.490000] br-lan: port 1(eth0) entered forwarding state</code></pre></div><p>Then i recovered the art partition, but still no wifi<br />here&#039;s dmesg after art recovery<br /></p><div class="codebox"><pre><code>BusyBox v1.22.1 (2014-12-12 09:24:22 CET) built-in shell (ash)
Enter &#039;help&#039; for a list of built-in commands.

  _______                     ________        __
 |       |.-----.-----.-----.|  |  |  |.----.|  |_
 |   -   ||  _  |  -__|     ||  |  |  ||   _||   _|
 |_______||   __|_____|__|__||________||__|  |____|
          |__| W I R E L E S S   F R E E D O M
 -----------------------------------------------------
 BARRIER BREAKER (Barrier Breaker, r43483)
 -----------------------------------------------------
  * 1/2 oz Galliano         Pour all ingredients into
  * 4 oz cold Coffee        an irish coffee mug filled
  * 1 1/2 oz Dark Rum       with crushed ice. Stir.
  * 2 tsp. Creme de Cacao
 -----------------------------------------------------
root@OpenWrt:~# ifconfig
br-lan    Link encap:Ethernet  HWaddr 08:57:00:57:A2:2E  
          inet addr:192.168.2.236  Bcast:192.168.2.255  Mask:255.255.255.0
          inet6 addr: fe80::a57:ff:fe57:a22e/64 Scope:Link
          inet6 addr: fd1a:8487:654d::1/60 Scope:Global
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:77 errors:0 dropped:0 overruns:0 frame:0
          TX packets:76 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:9369 (9.1 KiB)  TX bytes:9650 (9.4 KiB)

eth0      Link encap:Ethernet  HWaddr 08:57:00:57:A2:2E  
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:77 errors:0 dropped:0 overruns:0 frame:0
          TX packets:77 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:10447 (10.2 KiB)  TX bytes:9696 (9.4 KiB)
          Interrupt:4 

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:18 errors:0 dropped:0 overruns:0 frame:0
          TX packets:18 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:1552 (1.5 KiB)  TX bytes:1552 (1.5 KiB)

root@OpenWrt:~# dmesg
[    0.000000] Linux version 3.10.49 (sorlas@SorlasDebian) (gcc version 4.8.3 (OpenWrt/Linaro GCC 4.8-2014.04 r43483) ) #1 Fri Dec 12 09:32:38 CET 2014
[    0.000000] MyLoader: sysp=6c5fed42, boardp=be725d54, parts=dc5393f0
[    0.000000] bootconsole [early0] enabled
[    0.000000] CPU revision is: 00019374 (MIPS 24Kc)
[    0.000000] SoC: Atheros AR9330 rev 1
[    0.000000] Clocks: CPU:400.000MHz, DDR:400.000MHz, AHB:200.000MHz, Ref:25.000MHz
[    0.000000] Determined physical RAM map:
[    0.000000]  memory: 04000000 @ 00000000 (usable)
[    0.000000] Initrd not found or empty - disabling initrd
[    0.000000] Zone ranges:
[    0.000000]   Normal   [mem 0x00000000-0x03ffffff]
[    0.000000] Movable zone start for each node
[    0.000000] Early memory node ranges
[    0.000000]   node   0: [mem 0x00000000-0x03ffffff]
[    0.000000] On node 0 totalpages: 16384
[    0.000000] free_area_init_node: node 0, pgdat 803109b0, node_mem_map 81000000
[    0.000000]   Normal zone: 128 pages used for memmap
[    0.000000]   Normal zone: 0 pages reserved
[    0.000000]   Normal zone: 16384 pages, LIFO batch:3
[    0.000000] Primary instruction cache 64kB, VIPT, 4-way, linesize 32 bytes.
[    0.000000] Primary data cache 32kB, 4-way, VIPT, cache aliases, linesize 32 bytes
[    0.000000] pcpu-alloc: s0 r0 d32768 u32768 alloc=1*32768
[    0.000000] pcpu-alloc: [0] 0 
[    0.000000] Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 16256
[    0.000000] Kernel command line:  board=TL-MR13U console=ttyATH0,115200 rootfstype=squashfs,jffs2 noinitrd
[    0.000000] PID hash table entries: 256 (order: -2, 1024 bytes)
[    0.000000] Dentry cache hash table entries: 8192 (order: 3, 32768 bytes)
[    0.000000] Inode-cache hash table entries: 4096 (order: 2, 16384 bytes)
[    0.000000] Writing ErrCtl register=00000000
[    0.000000] Readback ErrCtl register=00000000
[    0.000000] Memory: 61208k/65536k available (2240k kernel code, 4328k reserved, 602k data, 228k init, 0k highmem)
[    0.000000] SLUB: HWalign=32, Order=0-3, MinObjects=0, CPUs=1, Nodes=1
[    0.000000] NR_IRQS:51
[    0.080000] Calibrating delay loop... 265.42 BogoMIPS (lpj=1327104)
[    0.080000] pid_max: default: 32768 minimum: 301
[    0.080000] Mount-cache hash table entries: 512
[    0.090000] NET: Registered protocol family 16
[    0.100000] MIPS: machine is TP-LINK TL-MR13U v1
[    0.410000] bio: create slab &lt;bio-0&gt; at 0
[    0.420000] Switching to clocksource MIPS
[    0.430000] NET: Registered protocol family 2
[    0.430000] TCP established hash table entries: 512 (order: 0, 4096 bytes)
[    0.430000] TCP bind hash table entries: 512 (order: -1, 2048 bytes)
[    0.430000] TCP: Hash tables configured (established 512 bind 512)
[    0.440000] TCP: reno registered
[    0.440000] UDP hash table entries: 256 (order: 0, 4096 bytes)
[    0.450000] UDP-Lite hash table entries: 256 (order: 0, 4096 bytes)
[    0.460000] NET: Registered protocol family 1
[    0.460000] PCI: CLS 0 bytes, default 32
[    0.480000] squashfs: version 4.0 (2009/01/31) Phillip Lougher
[    0.480000] jffs2: version 2.2 (NAND) (SUMMARY) (LZMA) (RTIME) (CMODE_PRIORITY) (c) 2001-2006 Red Hat, Inc.
[    0.490000] msgmni has been set to 119
[    0.500000] io scheduler noop registered
[    0.500000] io scheduler deadline registered (default)
[    0.510000] Serial: 8250/16550 driver, 1 ports, IRQ sharing disabled
[    0.510000] ar933x-uart: ttyATH0 at MMIO 0x18020000 (irq = 11) is a AR933X UART
[    0.520000] console [ttyATH0] enabled, bootconsole disabled
[    0.530000] ath79-spi ath79-spi: master is unqueued, this is deprecated
[    0.540000] m25p80 spi0.0: found w25q256, expected m25p80
[    0.540000] m25p80 spi0.0: w25q256 (32768 Kbytes)
[    0.550000] 5 tp-link partitions found on MTD device spi0.0
[    0.550000] Creating 5 MTD partitions on &quot;spi0.0&quot;:
[    0.560000] 0x000000000000-0x000000020000 : &quot;u-boot&quot;
[    0.570000] 0x000000020000-0x000000122104 : &quot;kernel&quot;
[    0.570000] mtd: partition &quot;kernel&quot; must either start or end on erase block boundary or be smaller than an erase block -- forcing read-only
[    0.580000] 0x000000122104-0x000001ff0000 : &quot;rootfs&quot;
[    0.590000] mtd: partition &quot;rootfs&quot; must either start or end on erase block boundary or be smaller than an erase block -- forcing read-only
[    0.600000] mtd: device 2 (rootfs) set to be root filesystem
[    0.610000] 1 squashfs-split partitions found on MTD device rootfs
[    0.610000] 0x0000002f0000-0x000001ff0000 : &quot;rootfs_data&quot;
[    0.620000] 0x000001ff0000-0x000002000000 : &quot;art&quot;
[    0.620000] 0x000000020000-0x000001ff0000 : &quot;firmware&quot;
[    0.650000] libphy: ag71xx_mdio: probed
[    1.200000] ag71xx ag71xx.0: connected to PHY at ag71xx-mdio.1:04 [uid=004dd041, driver=Generic PHY]
[    1.210000] eth0: Atheros AG71xx at 0xb9000000, irq 4, mode:MII
[    1.210000] TCP: cubic registered
[    1.220000] NET: Registered protocol family 17
[    1.220000] 8021q: 802.1Q VLAN Support v1.8
[    1.240000] VFS: Mounted root (squashfs filesystem) readonly on device 31:2.
[    1.250000] Freeing unused kernel memory: 228K (80327000 - 80360000)
[    5.190000] usbcore: registered new interface driver usbfs
[    5.190000] usbcore: registered new interface driver hub
[    5.200000] usbcore: registered new device driver usb
[    5.210000] ehci_hcd: USB 2.0 &#039;Enhanced&#039; Host Controller (EHCI) Driver
[    5.210000] ehci-platform: EHCI generic platform driver
[    5.220000] ehci-platform ehci-platform: EHCI Host Controller
[    5.220000] ehci-platform ehci-platform: new USB bus registered, assigned bus number 1
[    5.230000] ehci-platform ehci-platform: irq 3, io mem 0x1b000000
[    5.260000] ehci-platform ehci-platform: USB 2.0 started, EHCI 1.00
[    5.260000] hub 1-0:1.0: USB hub found
[    5.260000] hub 1-0:1.0: 1 port detected
[    5.270000] ohci_hcd: USB 1.1 &#039;Open&#039; Host Controller (OHCI) Driver
[    8.240000] eth0: link up (100Mbps/Full duplex)
[    9.480000] jffs2: notice: (307) jffs2_build_xattr_subsystem: complete building xattr subsystem, 16 of xdatum (0 unchecked, 15 orphan) and 27 of xref (0 dead, 15 orphan) found.
[    9.520000] eth0: link down
[   11.090000] NET: Registered protocol family 10
[   11.110000] nf_conntrack version 0.5.0 (959 buckets, 3836 max)
[   11.120000] ip6_tables: (C) 2000-2006 Netfilter Core Team
[   11.130000] Loading modules backported from Linux version master-2014-05-22-0-gf2032ea
[   11.140000] Backport generated by backports.git backports-20140320-37-g5c33da0
[   11.150000] ip_tables: (C) 2000-2006 Netfilter Core Team
[   11.210000] xt_time: kernel timezone is -0000
[   11.250000] cfg80211: Calling CRDA to update world regulatory domain
[   11.250000] cfg80211: World regulatory domain updated:
[   11.260000] cfg80211:  DFS Master region: unset
[   11.260000] cfg80211:   (start_freq - end_freq @ bandwidth), (max_antenna_gain, max_eirp), (dfs_cac_time)
[   11.270000] cfg80211:   (2402000 KHz - 2472000 KHz @ 40000 KHz), (N/A, 2000 mBm), (N/A)
[   11.280000] cfg80211:   (2457000 KHz - 2482000 KHz @ 40000 KHz), (N/A, 2000 mBm), (N/A)
[   11.290000] cfg80211:   (2474000 KHz - 2494000 KHz @ 20000 KHz), (N/A, 2000 mBm), (N/A)
[   11.290000] cfg80211:   (5170000 KHz - 5250000 KHz @ 160000 KHz), (N/A, 2000 mBm), (N/A)
[   11.300000] cfg80211:   (5250000 KHz - 5330000 KHz @ 160000 KHz), (N/A, 2000 mBm), (0 s)
[   11.310000] cfg80211:   (5490000 KHz - 5730000 KHz @ 160000 KHz), (N/A, 2000 mBm), (0 s)
[   11.320000] cfg80211:   (5735000 KHz - 5835000 KHz @ 80000 KHz), (N/A, 2000 mBm), (N/A)
[   11.330000] cfg80211:   (57240000 KHz - 63720000 KHz @ 2160000 KHz), (N/A, 0 mBm), (N/A)
[   11.400000] PPP generic driver version 2.4.2
[   11.410000] NET: Registered protocol family 24
[   11.470000] ath: EEPROM regdomain: 0x0
[   11.470000] ath: EEPROM indicates default country code should be used
[   11.470000] ath: doing EEPROM country-&gt;regdmn map search
[   11.470000] ath: country maps to regdmn code: 0x3a
[   11.470000] ath: Country alpha2 being used: US
[   11.470000] ath: Regpair used: 0x3a
[   11.480000] ieee80211 phy0: Selected rate control algorithm &#039;minstrel_ht&#039;
[   11.490000] cfg80211: Calling CRDA for country: US
[   11.500000] cfg80211: Regulatory domain changed to country: US
[   11.500000] cfg80211:  DFS Master region: FCC
[   11.500000] cfg80211:   (start_freq - end_freq @ bandwidth), (max_antenna_gain, max_eirp), (dfs_cac_time)
[   11.510000] cfg80211:   (2402000 KHz - 2472000 KHz @ 40000 KHz), (N/A, 3000 mBm), (N/A)
[   11.520000] cfg80211:   (5170000 KHz - 5250000 KHz @ 80000 KHz), (N/A, 1700 mBm), (N/A)
[   11.530000] cfg80211:   (5250000 KHz - 5330000 KHz @ 80000 KHz), (N/A, 2300 mBm), (0 s)
[   11.540000] cfg80211:   (5735000 KHz - 5835000 KHz @ 80000 KHz), (N/A, 3000 mBm), (N/A)
[   11.550000] cfg80211:   (57240000 KHz - 63720000 KHz @ 2160000 KHz), (N/A, 4000 mBm), (N/A)
[   11.550000] ieee80211 phy0: Atheros AR9330 Rev:1 mem=0xb8100000, irq=2
[   20.260000] IPv6: ADDRCONF(NETDEV_UP): eth0: link is not ready
[   20.260000] device eth0 entered promiscuous mode
[   20.270000] IPv6: ADDRCONF(NETDEV_UP): br-lan: link is not ready
[   20.950000] eth0: link up (100Mbps/Full duplex)
[   20.950000] br-lan: port 1(eth0) entered forwarding state
[   20.960000] br-lan: port 1(eth0) entered forwarding state
[   20.960000] IPv6: ADDRCONF(NETDEV_CHANGE): eth0: link becomes ready
[   20.980000] IPv6: ADDRCONF(NETDEV_CHANGE): br-lan: link becomes ready
[   22.960000] br-lan: port 1(eth0) entered forwarding state</code></pre></div>											<p class="post-edited">(Last edited by <strong>Sorlas</strong> on 12 Dec 2014, 11:05)</p>
									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p257475">
				<div class="post-metadata">
					<div class="post-num">Post #9</div>
					<div class="post-author">mk24</div>
					<div class="post-datetime">
						12 Dec 2014, 17:35					</div>
				</div>
				<div class="post-content content">
					<p>The boot looks perfect.</p><p>You did, of course, edit /etc/config/wireless to enable wifi?</p>									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p257547">
				<div class="post-metadata">
					<div class="post-num">Post #10</div>
					<div class="post-author">Sorlas</div>
					<div class="post-datetime">
						13 Dec 2014, 02:29					</div>
				</div>
				<div class="post-content content">
					<p>And ... it works. Totaly forgot that i have to do that when i build it myself.<br /><strong>Thanks very much for your support!</strong></p><p>For everyone else here the complete changes i&#039;ve made in correct form/order for Barrier Breaker 14.07 43483:</p><p>Remove Patch:<br />460-spi-bitbang-export-spi_bitbang_bufs.patch<br />461-api-add-type-field-to-spi_transfer.patch<br />462-mtd-m25p80-set-spi-transfer-type.patch<br />463-spi-ath79-add-flash-read.patch</p><p>Add Patched:<br />999-32MB-Flash-SupportMR13U.patch<br /></p><div class="codebox"><pre><code>--- a/arch/mips/ath79/Makefile
+++ b/arch/mips/ath79/Makefile
@@ -142,3 +142,4 @@
 obj-$(CONFIG_ATH79_MACH_ZCN_1523H)    += mach-zcn-1523h.o
 obj-$(CONFIG_ATH79_MACH_CARAMBOLA2)    += mach-carambola2.o
 obj-$(CONFIG_ATH79_MACH_NBG6716)    += mach-nbg6716.o
+obj-y                    += eeprom.o
--- a/arch/mips/ath79/dev-m25p80.c
+++ a/arch/mips/ath79/dev-m25p80.c
@@ -51,7 +51,6 @@
 {
     ath79_spi_data.bus_num = 0;
     ath79_spi_data.num_chipselect = 1;
-    ath79_spi0_cdata.is_flash = true;
     ath79_spi_info[0].platform_data = pdata;
     ath79_register_spi(&amp;ath79_spi_data, ath79_spi_info, 1);
 }
@@ -113,6 +112,5 @@
     add_mtd_concat_notifier();
     ath79_spi_data.bus_num = 0;
     ath79_spi_data.num_chipselect = 2;
-    ath79_spi0_cdata.is_flash = true;
     ath79_register_spi(&amp;ath79_spi_data, ath79_spi_info, 2);
 }
--- a/arch/mips/ath79/mach-alfa-ap96.c
+++ a/arch/mips/ath79/mach-alfa-ap96.c
@@ -62,7 +62,6 @@
 static struct ath79_spi_controller_data ap96_spi0_cdata = {
     .cs_type = ATH79_SPI_CS_TYPE_INTERNAL,
     .cs_line = 0,
-    .is_flash = true,
 };
 
 static struct ath79_spi_controller_data ap96_spi1_cdata = {
--- a/arch/mips/ath79/mach-tl-mr13u.c
+++ a/arch/mips/ath79/mach-tl-mr13u.c
@@ -20,6 +20,7 @@
 #include &quot;dev-usb.h&quot;
 #include &quot;dev-wmac.h&quot;
 #include &quot;machtypes.h&quot;
+#include &quot;eeprom.h&quot;
 
 #define TL_MR13U_GPIO_LED_SYSTEM    27
 
@@ -79,7 +80,7 @@
 static void __init tl_mr13u_setup(void)
 {
     u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
-    u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+    u8 *ee = ath79_get_eeprom();
 
     /* disable PHY_SWAP and PHY_ADDR_SWAP bits */
     ath79_setup_ar933x_phy4_switch(false, false);
--- a/arch/mips/ath79/eeprom.c
+++ a/arch/mips/ath79/eeprom.c
@@ -0,0 +1,111 @@
+#include &lt;asm/mach-ath79/ath79.h&gt;
+#include &lt;asm/mach-ath79/ar71xx_regs.h&gt;
+
+#include &lt;linux/delay.h&gt;
+
+#include &quot;common.h&quot;
+#include &quot;eeprom.h&quot;
+
+static u32 flash_32m_jedec[] = {0x20BA19, 0xEF4019, 0xC22019};
+
+static void __iomem *ath79_spi_base;
+
+
+static char ath79_eeprom[64 * 1024];
+
+static u32 ath79_flash_read_id(void)
+{
+    u32 rd = 0;
+
+    ath79_spi_start();
+
+    ath79_spi_bit_banger(OPCODE_RDID);
+
+    ath79_spi_delay_8();
+    ath79_spi_delay_8();
+    ath79_spi_delay_8();
+
+    rd = ath79_spi_read(AR71XX_SPI_REG_RDS) &amp; 0xffffff;
+
+    ath79_spi_done();
+
+    return rd;
+}
+
+static void ath79_flash_reset(void)
+{
+    ath79_spi_send_instruction(OPCODE_RSTEN);
+    ath79_spi_send_instruction(OPCODE_RESET);
+
+    udelay(100);
+}
+
+static int ath79_flash_read(u32 addr, u32 len, void *buf)
+{
+    int i;
+    u32 bytes_left;
+    void *write_addr;
+
+    bytes_left = len;
+    write_addr = buf;
+
+    ath79_spi_start();
+    ath79_spi_deselect();
+
+    ath79_flash_reset();
+
+    ath79_spi_send_instruction(OPCODE_WREN);
+    ath79_spi_bit_banger(OPCODE_WREAR);
+    ath79_spi_bit_banger((addr &amp; 0xff000000) &gt;&gt; 24);
+    ath79_spi_go();
+
+    ath79_spi_bit_banger(OPCODE_READ);
+    ath79_spi_send_addr(addr);
+
+    while (bytes_left)
+    {
+        for (i = 0; i &lt; sizeof (u32); i++)
+            ath79_spi_delay_8();
+
+        *(u32 *)write_addr = ath79_spi_read(AR71XX_SPI_REG_RDS);
+
+        write_addr = (void *) ((u32) write_addr + sizeof (u32));
+        bytes_left -= sizeof (u32);
+    }
+
+    ath79_spi_go();
+    ath79_spi_deselect();
+
+    ath79_flash_reset();
+
+    ath79_spi_done();
+
+    return 0;
+}
+
+u8 *ath79_get_eeprom(void)
+{
+    int i;
+    u32 jedec_id;
+
+    ath79_spi_base = ioremap_nocache(AR71XX_SPI_BASE, AR71XX_SPI_SIZE);
+
+    jedec_id = ath79_flash_read_id();
+
+    for (i = 0; i &lt; ARRAY_SIZE(flash_32m_jedec); i++)
+    {
+        if (flash_32m_jedec[i] == jedec_id)
+            break;
+    }
+
+    if (flash_32m_jedec[i] != jedec_id)
+    {
+        iounmap(ath79_spi_base);
+        return (u8 *) KSEG1ADDR(0x1fff1000);
+    }
+
+    ath79_flash_read(0x01ff0000, 0x10000, ath79_eeprom);
+
+    iounmap(ath79_spi_base);
+    return (u8 *) ((u32) ath79_eeprom + 0x1000);
+}
--- a/arch/mips/ath79/eeprom.h
+++ a/arch/mips/ath79/eeprom.h
@@ -0,0 +1,62 @@
+#define AR71XX_SPI_CLK_HIGH    (1&lt;&lt;8)
+#define AR71XX_SPI_CS_DIS    (AR71XX_SPI_IOC_CS_ALL)
+#define AR71XX_SPI_CE_LOW    (AR71XX_SPI_IOC_CS1 | AR71XX_SPI_IOC_CS2)
+#define AR71XX_SPI_CE_HIGH    (AR71XX_SPI_CE_LOW | AR71XX_SPI_CLK_HIGH)
+
+#define OPCODE_READ        0x03
+#define OPCODE_WREN        0x06
+#define OPCODE_WREAR        0xc5
+#define OPCODE_RSTEN        0x66
+#define OPCODE_RESET        0x99
+#define OPCODE_RDID        0x9f
+
+#define ath79_spi_read(_phys)        __raw_readl(ath79_spi_base + (_phys))
+#define ath79_spi_write(_phys, _val)    __raw_writel((_val), ath79_spi_base + (_phys))
+
+#define ath79_be_msb(_val, _i) (((_val) &amp; (1 &lt;&lt; (7 - _i))) &gt;&gt; (7 - _i))
+
+
+#define ath79_spi_bit_banger(_byte) do \
+    { \
+        int i; \
+        for(i = 0; i &lt; 8; i++) \
+        { \
+            ath79_spi_write(AR71XX_SPI_REG_IOC, \
+                AR71XX_SPI_CE_LOW | ath79_be_msb(_byte, i)); \
+            ath79_spi_write(AR71XX_SPI_REG_IOC, \
+                AR71XX_SPI_CE_HIGH | ath79_be_msb(_byte, i)); \
+        } \
+    } while(0)
+
+
+#define ath79_spi_go() do \
+    { \
+        ath79_spi_write(AR71XX_SPI_REG_IOC, AR71XX_SPI_CE_LOW); \
+        ath79_spi_write(AR71XX_SPI_REG_IOC, AR71XX_SPI_CS_DIS); \
+    } while(0)
+
+
+#define ath79_spi_send_instruction(_byte) do \
+    { \
+        ath79_spi_bit_banger(_byte); \
+        ath79_spi_go(); \
+    } while(0)
+
+
+#define ath79_spi_send_addr(_addr) do \
+    { \
+        ath79_spi_bit_banger(((_addr &amp; 0xff0000) &gt;&gt; 16)); \
+        ath79_spi_bit_banger(((_addr &amp; 0xff00) &gt;&gt; 8)); \
+        ath79_spi_bit_banger(_addr &amp; 0xff); \
+    } while(0)
+
+
+#define ath79_spi_delay_8()    ath79_spi_bit_banger(0)
+
+#define ath79_spi_deselect()    ath79_spi_write(AR71XX_SPI_REG_IOC, AR71XX_SPI_CS_DIS)
+
+#define ath79_spi_start()    ath79_spi_write(AR71XX_SPI_REG_FS, 1)
+
+#define ath79_spi_done()    ath79_spi_write(AR71XX_SPI_REG_FS, 0)
+
+u8 *ath79_get_eeprom(void);</code></pre></div><p>415-mtd-m25p80-enable-reset-when-removed.patch<br /></p><div class="codebox"><pre><code>--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -70,6 +70,10 @@
 #define    SR_BP2            0x10    /* Block protect 2 */
 #define    SR_SRWD            0x80    /* SR write protect */
 
+/* Reset opcodes */
+#define OPCODE_RSTEN        0x66    /* Enable reset */
+#define OPCODE_RESET        0x99    /* Reset device */
+
 /* Define max times to check status register before we give up. */
 #define    MAX_READY_WAIT_JIFFIES    (40 * HZ)    /* M25P16 specs 40s max chip erase */
 #define    MAX_CMD_SIZE        5
@@ -205,6 +209,49 @@
 }
 
 /*
+ * Reset hole flash chip. Only be avaliable for chips size &gt;= 32MiB
+ */
+static inline int flash_reset(struct m25p *flash)
+{
+    struct spi_transfer t[2];
+    struct spi_message m;
+    char command[2];
+    int ret;
+
+    if (flash-&gt;addr_width != 4) return 1;
+
+    spi_message_init(&amp;m);
+    memset(t, 0, (sizeof t));
+
+    t[0].tx_buf = &amp;command[0];
+    t[0].len = 1;
+    t[0].cs_change = 1;
+    spi_message_add_tail(&amp;t[0], &amp;m);
+
+    t[1].tx_buf = &amp;command[1];
+    t[1].len = 1;
+    t[1].cs_change = 1;
+    spi_message_add_tail(&amp;t[1], &amp;m);
+
+    command[0] = OPCODE_RSTEN;
+    command[1] = OPCODE_RESET;
+
+    mutex_lock(&amp;flash-&gt;lock);
+
+    ret = wait_till_ready(flash);
+    if (ret) {
+        mutex_unlock(&amp;flash-&gt;lock);
+        return 1;
+    }
+
+    spi_sync(flash-&gt;spi, &amp;m);
+
+    mutex_unlock(&amp;flash-&gt;lock);
+
+    return 0;
+}
+
+/*
  * Erase the whole flash memory
  *
  * Returns 0 if successful, non-zero otherwise.
@@ -1135,6 +1182,9 @@
     struct m25p    *flash = dev_get_drvdata(&amp;spi-&gt;dev);
     int        status;
 
+    /* Reset flash. */
+    flash_reset(flash);
+
     /* Clean up MTD stuff. */
     status = mtd_device_unregister(&amp;flash-&gt;mtd);
     if (status == 0) {</code></pre></div><p>Make backup of your ART partition<br />Compile image, flash it, enable wifi</p><p>However my MR13U comes with a custom uboot where additional changes are made to support 32MB-Flash. I didn&#039;t (couldn&#039;t) do those changes so something else is missing.</p>									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p266919">
				<div class="post-metadata">
					<div class="post-num">Post #11</div>
					<div class="post-author">axishero</div>
					<div class="post-datetime">
						26 Feb 2015, 04:37					</div>
				</div>
				<div class="post-content content">
					<div class="quotebox"><cite>Sorlas wrote:</cite><blockquote><p>And ... it works. Totaly forgot that i have to do that when i build it myself.<br /><strong>Thanks very much for your support!</strong></p><p>For everyone else here the complete changes i&#039;ve made in correct form/order for Barrier Breaker 14.07 43483:</p><p>Remove Patch:<br />460-spi-bitbang-export-spi_bitbang_bufs.patch<br />461-api-add-type-field-to-spi_transfer.patch<br />462-mtd-m25p80-set-spi-transfer-type.patch<br />463-spi-ath79-add-flash-read.patch</p><p>Add Patched:<br />999-32MB-Flash-SupportMR13U.patch<br /></p><div class="codebox"><pre><code>--- a/arch/mips/ath79/Makefile
+++ b/arch/mips/ath79/Makefile
@@ -142,3 +142,4 @@
 obj-$(CONFIG_ATH79_MACH_ZCN_1523H)    += mach-zcn-1523h.o
 obj-$(CONFIG_ATH79_MACH_CARAMBOLA2)    += mach-carambola2.o
 obj-$(CONFIG_ATH79_MACH_NBG6716)    += mach-nbg6716.o
+obj-y                    += eeprom.o
--- a/arch/mips/ath79/dev-m25p80.c
+++ a/arch/mips/ath79/dev-m25p80.c
@@ -51,7 +51,6 @@
 {
     ath79_spi_data.bus_num = 0;
     ath79_spi_data.num_chipselect = 1;
-    ath79_spi0_cdata.is_flash = true;
     ath79_spi_info[0].platform_data = pdata;
     ath79_register_spi(&amp;ath79_spi_data, ath79_spi_info, 1);
 }
@@ -113,6 +112,5 @@
     add_mtd_concat_notifier();
     ath79_spi_data.bus_num = 0;
     ath79_spi_data.num_chipselect = 2;
-    ath79_spi0_cdata.is_flash = true;
     ath79_register_spi(&amp;ath79_spi_data, ath79_spi_info, 2);
 }
--- a/arch/mips/ath79/mach-alfa-ap96.c
+++ a/arch/mips/ath79/mach-alfa-ap96.c
@@ -62,7 +62,6 @@
 static struct ath79_spi_controller_data ap96_spi0_cdata = {
     .cs_type = ATH79_SPI_CS_TYPE_INTERNAL,
     .cs_line = 0,
-    .is_flash = true,
 };
 
 static struct ath79_spi_controller_data ap96_spi1_cdata = {
--- a/arch/mips/ath79/mach-tl-mr13u.c
+++ a/arch/mips/ath79/mach-tl-mr13u.c
@@ -20,6 +20,7 @@
 #include &quot;dev-usb.h&quot;
 #include &quot;dev-wmac.h&quot;
 #include &quot;machtypes.h&quot;
+#include &quot;eeprom.h&quot;
 
 #define TL_MR13U_GPIO_LED_SYSTEM    27
 
@@ -79,7 +80,7 @@
 static void __init tl_mr13u_setup(void)
 {
     u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
-    u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+    u8 *ee = ath79_get_eeprom();
 
     /* disable PHY_SWAP and PHY_ADDR_SWAP bits */
     ath79_setup_ar933x_phy4_switch(false, false);
--- a/arch/mips/ath79/eeprom.c
+++ a/arch/mips/ath79/eeprom.c
@@ -0,0 +1,111 @@
+#include &lt;asm/mach-ath79/ath79.h&gt;
+#include &lt;asm/mach-ath79/ar71xx_regs.h&gt;
+
+#include &lt;linux/delay.h&gt;
+
+#include &quot;common.h&quot;
+#include &quot;eeprom.h&quot;
+
+static u32 flash_32m_jedec[] = {0x20BA19, 0xEF4019, 0xC22019};
+
+static void __iomem *ath79_spi_base;
+
+
+static char ath79_eeprom[64 * 1024];
+
+static u32 ath79_flash_read_id(void)
+{
+    u32 rd = 0;
+
+    ath79_spi_start();
+
+    ath79_spi_bit_banger(OPCODE_RDID);
+
+    ath79_spi_delay_8();
+    ath79_spi_delay_8();
+    ath79_spi_delay_8();
+
+    rd = ath79_spi_read(AR71XX_SPI_REG_RDS) &amp; 0xffffff;
+
+    ath79_spi_done();
+
+    return rd;
+}
+
+static void ath79_flash_reset(void)
+{
+    ath79_spi_send_instruction(OPCODE_RSTEN);
+    ath79_spi_send_instruction(OPCODE_RESET);
+
+    udelay(100);
+}
+
+static int ath79_flash_read(u32 addr, u32 len, void *buf)
+{
+    int i;
+    u32 bytes_left;
+    void *write_addr;
+
+    bytes_left = len;
+    write_addr = buf;
+
+    ath79_spi_start();
+    ath79_spi_deselect();
+
+    ath79_flash_reset();
+
+    ath79_spi_send_instruction(OPCODE_WREN);
+    ath79_spi_bit_banger(OPCODE_WREAR);
+    ath79_spi_bit_banger((addr &amp; 0xff000000) &gt;&gt; 24);
+    ath79_spi_go();
+
+    ath79_spi_bit_banger(OPCODE_READ);
+    ath79_spi_send_addr(addr);
+
+    while (bytes_left)
+    {
+        for (i = 0; i &lt; sizeof (u32); i++)
+            ath79_spi_delay_8();
+
+        *(u32 *)write_addr = ath79_spi_read(AR71XX_SPI_REG_RDS);
+
+        write_addr = (void *) ((u32) write_addr + sizeof (u32));
+        bytes_left -= sizeof (u32);
+    }
+
+    ath79_spi_go();
+    ath79_spi_deselect();
+
+    ath79_flash_reset();
+
+    ath79_spi_done();
+
+    return 0;
+}
+
+u8 *ath79_get_eeprom(void)
+{
+    int i;
+    u32 jedec_id;
+
+    ath79_spi_base = ioremap_nocache(AR71XX_SPI_BASE, AR71XX_SPI_SIZE);
+
+    jedec_id = ath79_flash_read_id();
+
+    for (i = 0; i &lt; ARRAY_SIZE(flash_32m_jedec); i++)
+    {
+        if (flash_32m_jedec[i] == jedec_id)
+            break;
+    }
+
+    if (flash_32m_jedec[i] != jedec_id)
+    {
+        iounmap(ath79_spi_base);
+        return (u8 *) KSEG1ADDR(0x1fff1000);
+    }
+
+    ath79_flash_read(0x01ff0000, 0x10000, ath79_eeprom);
+
+    iounmap(ath79_spi_base);
+    return (u8 *) ((u32) ath79_eeprom + 0x1000);
+}
--- a/arch/mips/ath79/eeprom.h
+++ a/arch/mips/ath79/eeprom.h
@@ -0,0 +1,62 @@
+#define AR71XX_SPI_CLK_HIGH    (1&lt;&lt;8)
+#define AR71XX_SPI_CS_DIS    (AR71XX_SPI_IOC_CS_ALL)
+#define AR71XX_SPI_CE_LOW    (AR71XX_SPI_IOC_CS1 | AR71XX_SPI_IOC_CS2)
+#define AR71XX_SPI_CE_HIGH    (AR71XX_SPI_CE_LOW | AR71XX_SPI_CLK_HIGH)
+
+#define OPCODE_READ        0x03
+#define OPCODE_WREN        0x06
+#define OPCODE_WREAR        0xc5
+#define OPCODE_RSTEN        0x66
+#define OPCODE_RESET        0x99
+#define OPCODE_RDID        0x9f
+
+#define ath79_spi_read(_phys)        __raw_readl(ath79_spi_base + (_phys))
+#define ath79_spi_write(_phys, _val)    __raw_writel((_val), ath79_spi_base + (_phys))
+
+#define ath79_be_msb(_val, _i) (((_val) &amp; (1 &lt;&lt; (7 - _i))) &gt;&gt; (7 - _i))
+
+
+#define ath79_spi_bit_banger(_byte) do \
+    { \
+        int i; \
+        for(i = 0; i &lt; 8; i++) \
+        { \
+            ath79_spi_write(AR71XX_SPI_REG_IOC, \
+                AR71XX_SPI_CE_LOW | ath79_be_msb(_byte, i)); \
+            ath79_spi_write(AR71XX_SPI_REG_IOC, \
+                AR71XX_SPI_CE_HIGH | ath79_be_msb(_byte, i)); \
+        } \
+    } while(0)
+
+
+#define ath79_spi_go() do \
+    { \
+        ath79_spi_write(AR71XX_SPI_REG_IOC, AR71XX_SPI_CE_LOW); \
+        ath79_spi_write(AR71XX_SPI_REG_IOC, AR71XX_SPI_CS_DIS); \
+    } while(0)
+
+
+#define ath79_spi_send_instruction(_byte) do \
+    { \
+        ath79_spi_bit_banger(_byte); \
+        ath79_spi_go(); \
+    } while(0)
+
+
+#define ath79_spi_send_addr(_addr) do \
+    { \
+        ath79_spi_bit_banger(((_addr &amp; 0xff0000) &gt;&gt; 16)); \
+        ath79_spi_bit_banger(((_addr &amp; 0xff00) &gt;&gt; 8)); \
+        ath79_spi_bit_banger(_addr &amp; 0xff); \
+    } while(0)
+
+
+#define ath79_spi_delay_8()    ath79_spi_bit_banger(0)
+
+#define ath79_spi_deselect()    ath79_spi_write(AR71XX_SPI_REG_IOC, AR71XX_SPI_CS_DIS)
+
+#define ath79_spi_start()    ath79_spi_write(AR71XX_SPI_REG_FS, 1)
+
+#define ath79_spi_done()    ath79_spi_write(AR71XX_SPI_REG_FS, 0)
+
+u8 *ath79_get_eeprom(void);</code></pre></div><p>415-mtd-m25p80-enable-reset-when-removed.patch<br /></p><div class="codebox"><pre><code>--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -70,6 +70,10 @@
 #define    SR_BP2            0x10    /* Block protect 2 */
 #define    SR_SRWD            0x80    /* SR write protect */
 
+/* Reset opcodes */
+#define OPCODE_RSTEN        0x66    /* Enable reset */
+#define OPCODE_RESET        0x99    /* Reset device */
+
 /* Define max times to check status register before we give up. */
 #define    MAX_READY_WAIT_JIFFIES    (40 * HZ)    /* M25P16 specs 40s max chip erase */
 #define    MAX_CMD_SIZE        5
@@ -205,6 +209,49 @@
 }
 
 /*
+ * Reset hole flash chip. Only be avaliable for chips size &gt;= 32MiB
+ */
+static inline int flash_reset(struct m25p *flash)
+{
+    struct spi_transfer t[2];
+    struct spi_message m;
+    char command[2];
+    int ret;
+
+    if (flash-&gt;addr_width != 4) return 1;
+
+    spi_message_init(&amp;m);
+    memset(t, 0, (sizeof t));
+
+    t[0].tx_buf = &amp;command[0];
+    t[0].len = 1;
+    t[0].cs_change = 1;
+    spi_message_add_tail(&amp;t[0], &amp;m);
+
+    t[1].tx_buf = &amp;command[1];
+    t[1].len = 1;
+    t[1].cs_change = 1;
+    spi_message_add_tail(&amp;t[1], &amp;m);
+
+    command[0] = OPCODE_RSTEN;
+    command[1] = OPCODE_RESET;
+
+    mutex_lock(&amp;flash-&gt;lock);
+
+    ret = wait_till_ready(flash);
+    if (ret) {
+        mutex_unlock(&amp;flash-&gt;lock);
+        return 1;
+    }
+
+    spi_sync(flash-&gt;spi, &amp;m);
+
+    mutex_unlock(&amp;flash-&gt;lock);
+
+    return 0;
+}
+
+/*
  * Erase the whole flash memory
  *
  * Returns 0 if successful, non-zero otherwise.
@@ -1135,6 +1182,9 @@
     struct m25p    *flash = dev_get_drvdata(&amp;spi-&gt;dev);
     int        status;
 
+    /* Reset flash. */
+    flash_reset(flash);
+
     /* Clean up MTD stuff. */
     status = mtd_device_unregister(&amp;flash-&gt;mtd);
     if (status == 0) {</code></pre></div><p>Make backup of your ART partition<br />Compile image, flash it, enable wifi</p><p>However my MR13U comes with a custom uboot where additional changes are made to support 32MB-Flash. I didn&#039;t (couldn&#039;t) do those changes so something else is missing.</p></blockquote></div><p>Is this patch working for CC?</p>									</div>
			</article>

			
		
			
		
		
			<article class="post" id="p266933">
				<div class="post-metadata">
					<div class="post-num">Post #12</div>
					<div class="post-author">dony71</div>
					<div class="post-datetime">
						26 Feb 2015, 07:49					</div>
				</div>
				<div class="post-content content">
					<div class="quotebox"><cite>axishero wrote:</cite><blockquote><div class="quotebox"><cite>Sorlas wrote:</cite><blockquote><p>And ... it works. Totaly forgot that i have to do that when i build it myself.<br /><strong>Thanks very much for your support!</strong></p><p>For everyone else here the complete changes i&#039;ve made in correct form/order for Barrier Breaker 14.07 43483:</p><p>Remove Patch:<br />460-spi-bitbang-export-spi_bitbang_bufs.patch<br />461-api-add-type-field-to-spi_transfer.patch<br />462-mtd-m25p80-set-spi-transfer-type.patch<br />463-spi-ath79-add-flash-read.patch</p><p>Add Patched:<br />999-32MB-Flash-SupportMR13U.patch<br /></p><div class="codebox"><pre><code>--- a/arch/mips/ath79/Makefile
+++ b/arch/mips/ath79/Makefile
@@ -142,3 +142,4 @@
 obj-$(CONFIG_ATH79_MACH_ZCN_1523H)    += mach-zcn-1523h.o
 obj-$(CONFIG_ATH79_MACH_CARAMBOLA2)    += mach-carambola2.o
 obj-$(CONFIG_ATH79_MACH_NBG6716)    += mach-nbg6716.o
+obj-y                    += eeprom.o
--- a/arch/mips/ath79/dev-m25p80.c
+++ a/arch/mips/ath79/dev-m25p80.c
@@ -51,7 +51,6 @@
 {
     ath79_spi_data.bus_num = 0;
     ath79_spi_data.num_chipselect = 1;
-    ath79_spi0_cdata.is_flash = true;
     ath79_spi_info[0].platform_data = pdata;
     ath79_register_spi(&amp;ath79_spi_data, ath79_spi_info, 1);
 }
@@ -113,6 +112,5 @@
     add_mtd_concat_notifier();
     ath79_spi_data.bus_num = 0;
     ath79_spi_data.num_chipselect = 2;
-    ath79_spi0_cdata.is_flash = true;
     ath79_register_spi(&amp;ath79_spi_data, ath79_spi_info, 2);
 }
--- a/arch/mips/ath79/mach-alfa-ap96.c
+++ a/arch/mips/ath79/mach-alfa-ap96.c
@@ -62,7 +62,6 @@
 static struct ath79_spi_controller_data ap96_spi0_cdata = {
     .cs_type = ATH79_SPI_CS_TYPE_INTERNAL,
     .cs_line = 0,
-    .is_flash = true,
 };
 
 static struct ath79_spi_controller_data ap96_spi1_cdata = {
--- a/arch/mips/ath79/mach-tl-mr13u.c
+++ a/arch/mips/ath79/mach-tl-mr13u.c
@@ -20,6 +20,7 @@
 #include &quot;dev-usb.h&quot;
 #include &quot;dev-wmac.h&quot;
 #include &quot;machtypes.h&quot;
+#include &quot;eeprom.h&quot;
 
 #define TL_MR13U_GPIO_LED_SYSTEM    27
 
@@ -79,7 +80,7 @@
 static void __init tl_mr13u_setup(void)
 {
     u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
-    u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+    u8 *ee = ath79_get_eeprom();
 
     /* disable PHY_SWAP and PHY_ADDR_SWAP bits */
     ath79_setup_ar933x_phy4_switch(false, false);
--- a/arch/mips/ath79/eeprom.c
+++ a/arch/mips/ath79/eeprom.c
@@ -0,0 +1,111 @@
+#include &lt;asm/mach-ath79/ath79.h&gt;
+#include &lt;asm/mach-ath79/ar71xx_regs.h&gt;
+
+#include &lt;linux/delay.h&gt;
+
+#include &quot;common.h&quot;
+#include &quot;eeprom.h&quot;
+
+static u32 flash_32m_jedec[] = {0x20BA19, 0xEF4019, 0xC22019};
+
+static void __iomem *ath79_spi_base;
+
+
+static char ath79_eeprom[64 * 1024];
+
+static u32 ath79_flash_read_id(void)
+{
+    u32 rd = 0;
+
+    ath79_spi_start();
+
+    ath79_spi_bit_banger(OPCODE_RDID);
+
+    ath79_spi_delay_8();
+    ath79_spi_delay_8();
+    ath79_spi_delay_8();
+
+    rd = ath79_spi_read(AR71XX_SPI_REG_RDS) &amp; 0xffffff;
+
+    ath79_spi_done();
+
+    return rd;
+}
+
+static void ath79_flash_reset(void)
+{
+    ath79_spi_send_instruction(OPCODE_RSTEN);
+    ath79_spi_send_instruction(OPCODE_RESET);
+
+    udelay(100);
+}
+
+static int ath79_flash_read(u32 addr, u32 len, void *buf)
+{
+    int i;
+    u32 bytes_left;
+    void *write_addr;
+
+    bytes_left = len;
+    write_addr = buf;
+
+    ath79_spi_start();
+    ath79_spi_deselect();
+
+    ath79_flash_reset();
+
+    ath79_spi_send_instruction(OPCODE_WREN);
+    ath79_spi_bit_banger(OPCODE_WREAR);
+    ath79_spi_bit_banger((addr &amp; 0xff000000) &gt;&gt; 24);
+    ath79_spi_go();
+
+    ath79_spi_bit_banger(OPCODE_READ);
+    ath79_spi_send_addr(addr);
+
+    while (bytes_left)
+    {
+        for (i = 0; i &lt; sizeof (u32); i++)
+            ath79_spi_delay_8();
+
+        *(u32 *)write_addr = ath79_spi_read(AR71XX_SPI_REG_RDS);
+
+        write_addr = (void *) ((u32) write_addr + sizeof (u32));
+        bytes_left -= sizeof (u32);
+    }
+
+    ath79_spi_go();
+    ath79_spi_deselect();
+
+    ath79_flash_reset();
+
+    ath79_spi_done();
+
+    return 0;
+}
+
+u8 *ath79_get_eeprom(void)
+{
+    int i;
+    u32 jedec_id;
+
+    ath79_spi_base = ioremap_nocache(AR71XX_SPI_BASE, AR71XX_SPI_SIZE);
+
+    jedec_id = ath79_flash_read_id();
+
+    for (i = 0; i &lt; ARRAY_SIZE(flash_32m_jedec); i++)
+    {
+        if (flash_32m_jedec[i] == jedec_id)
+            break;
+    }
+
+    if (flash_32m_jedec[i] != jedec_id)
+    {
+        iounmap(ath79_spi_base);
+        return (u8 *) KSEG1ADDR(0x1fff1000);
+    }
+
+    ath79_flash_read(0x01ff0000, 0x10000, ath79_eeprom);
+
+    iounmap(ath79_spi_base);
+    return (u8 *) ((u32) ath79_eeprom + 0x1000);
+}
--- a/arch/mips/ath79/eeprom.h
+++ a/arch/mips/ath79/eeprom.h
@@ -0,0 +1,62 @@
+#define AR71XX_SPI_CLK_HIGH    (1&lt;&lt;8)
+#define AR71XX_SPI_CS_DIS    (AR71XX_SPI_IOC_CS_ALL)
+#define AR71XX_SPI_CE_LOW    (AR71XX_SPI_IOC_CS1 | AR71XX_SPI_IOC_CS2)
+#define AR71XX_SPI_CE_HIGH    (AR71XX_SPI_CE_LOW | AR71XX_SPI_CLK_HIGH)
+
+#define OPCODE_READ        0x03
+#define OPCODE_WREN        0x06
+#define OPCODE_WREAR        0xc5
+#define OPCODE_RSTEN        0x66
+#define OPCODE_RESET        0x99
+#define OPCODE_RDID        0x9f
+
+#define ath79_spi_read(_phys)        __raw_readl(ath79_spi_base + (_phys))
+#define ath79_spi_write(_phys, _val)    __raw_writel((_val), ath79_spi_base + (_phys))
+
+#define ath79_be_msb(_val, _i) (((_val) &amp; (1 &lt;&lt; (7 - _i))) &gt;&gt; (7 - _i))
+
+
+#define ath79_spi_bit_banger(_byte) do \
+    { \
+        int i; \
+        for(i = 0; i &lt; 8; i++) \
+        { \
+            ath79_spi_write(AR71XX_SPI_REG_IOC, \
+                AR71XX_SPI_CE_LOW | ath79_be_msb(_byte, i)); \
+            ath79_spi_write(AR71XX_SPI_REG_IOC, \
+                AR71XX_SPI_CE_HIGH | ath79_be_msb(_byte, i)); \
+        } \
+    } while(0)
+
+
+#define ath79_spi_go() do \
+    { \
+        ath79_spi_write(AR71XX_SPI_REG_IOC, AR71XX_SPI_CE_LOW); \
+        ath79_spi_write(AR71XX_SPI_REG_IOC, AR71XX_SPI_CS_DIS); \
+    } while(0)
+
+
+#define ath79_spi_send_instruction(_byte) do \
+    { \
+        ath79_spi_bit_banger(_byte); \
+        ath79_spi_go(); \
+    } while(0)
+
+
+#define ath79_spi_send_addr(_addr) do \
+    { \
+        ath79_spi_bit_banger(((_addr &amp; 0xff0000) &gt;&gt; 16)); \
+        ath79_spi_bit_banger(((_addr &amp; 0xff00) &gt;&gt; 8)); \
+        ath79_spi_bit_banger(_addr &amp; 0xff); \
+    } while(0)
+
+
+#define ath79_spi_delay_8()    ath79_spi_bit_banger(0)
+
+#define ath79_spi_deselect()    ath79_spi_write(AR71XX_SPI_REG_IOC, AR71XX_SPI_CS_DIS)
+
+#define ath79_spi_start()    ath79_spi_write(AR71XX_SPI_REG_FS, 1)
+
+#define ath79_spi_done()    ath79_spi_write(AR71XX_SPI_REG_FS, 0)
+
+u8 *ath79_get_eeprom(void);</code></pre></div><p>415-mtd-m25p80-enable-reset-when-removed.patch<br /></p><div class="codebox"><pre><code>--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -70,6 +70,10 @@
 #define    SR_BP2            0x10    /* Block protect 2 */
 #define    SR_SRWD            0x80    /* SR write protect */
 
+/* Reset opcodes */
+#define OPCODE_RSTEN        0x66    /* Enable reset */
+#define OPCODE_RESET        0x99    /* Reset device */
+
 /* Define max times to check status register before we give up. */
 #define    MAX_READY_WAIT_JIFFIES    (40 * HZ)    /* M25P16 specs 40s max chip erase */
 #define    MAX_CMD_SIZE        5
@@ -205,6 +209,49 @@
 }
 
 /*
+ * Reset hole flash chip. Only be avaliable for chips size &gt;= 32MiB
+ */
+static inline int flash_reset(struct m25p *flash)
+{
+    struct spi_transfer t[2];
+    struct spi_message m;
+    char command[2];
+    int ret;
+
+    if (flash-&gt;addr_width != 4) return 1;
+
+    spi_message_init(&amp;m);
+    memset(t, 0, (sizeof t));
+
+    t[0].tx_buf = &amp;command[0];
+    t[0].len = 1;
+    t[0].cs_change = 1;
+    spi_message_add_tail(&amp;t[0], &amp;m);
+
+    t[1].tx_buf = &amp;command[1];
+    t[1].len = 1;
+    t[1].cs_change = 1;
+    spi_message_add_tail(&amp;t[1], &amp;m);
+
+    command[0] = OPCODE_RSTEN;
+    command[1] = OPCODE_RESET;
+
+    mutex_lock(&amp;flash-&gt;lock);
+
+    ret = wait_till_ready(flash);
+    if (ret) {
+        mutex_unlock(&amp;flash-&gt;lock);
+        return 1;
+    }
+
+    spi_sync(flash-&gt;spi, &amp;m);
+
+    mutex_unlock(&amp;flash-&gt;lock);
+
+    return 0;
+}
+
+/*
  * Erase the whole flash memory
  *
  * Returns 0 if successful, non-zero otherwise.
@@ -1135,6 +1182,9 @@
     struct m25p    *flash = dev_get_drvdata(&amp;spi-&gt;dev);
     int        status;
 
+    /* Reset flash. */
+    flash_reset(flash);
+
     /* Clean up MTD stuff. */
     status = mtd_device_unregister(&amp;flash-&gt;mtd);
     if (status == 0) {</code></pre></div><p>Make backup of your ART partition<br />Compile image, flash it, enable wifi</p><p>However my MR13U comes with a custom uboot where additional changes are made to support 32MB-Flash. I didn&#039;t (couldn&#039;t) do those changes so something else is missing.</p></blockquote></div><p>Is this patch working for CC?</p></blockquote></div><p>NO</p>									</div>
			</article>

			
		
	
			<div class="notice minor">
			<p>The discussion might have continued from here.</p>
		</div>
	
	<div class="pagination"><div class="pagination-number">Page 1 of 1</div><nav><ul><li class="pagination-current"><span>1</span></li></ul></nav></div>
</main>

</div>


<!-- Created in a hurry and not indicative of usual code quality. Here's a number: 0 -->

</body>
</html>